// Auto-generated from Elasticsearch OpenAPI spec
// Do not edit manually - regenerate using generate-dsl.fsx
// This file contains all Elasticsearch types with mutual recursion support

namespace Fes.DSL.Models

open System
open System.Text.Json
open System.Text.Json.Serialization

[<AutoOpen>]
module Types =

    type Id = string

    and AcknowledgedResponseBase = {
        [<JsonPropertyName("acknowledged")>]
        Acknowledged: bool
    }

    /// <summary>
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    /// </summary>
    and Duration = string

    and ExplainExplanationDetail = {
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("details")>]
        Details: ExplainExplanationDetail array option
        [<JsonPropertyName("value")>]
        Value: float
    }

    and ExplainExplanation = {
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("details")>]
        Details: ExplainExplanationDetail array
        [<JsonPropertyName("value")>]
        Value: float
    }

    and SearchTypesInnerHitsResult = {
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHitsMetadata
    }

    /// <summary>
    /// Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
    /// </summary>
    and Field = string

    and SearchTypesNestedIdentity = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("_nested")>]
        Nested: SearchTypesNestedIdentity option
    }

    and IndexName = string

    and SequenceNumber = float

    /// <summary>
    /// A field value.
    /// </summary>
    and FieldValue = obj

    and SortResults = FieldValue array

    and VersionNumber = float

    and SearchTypesHit = {
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_score")>]
        Score: System.Text.Json.JsonElement option
        [<JsonPropertyName("_explanation")>]
        Explanation: ExplainExplanation option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("highlight")>]
        Highlight: Map<string, string array> option
        [<JsonPropertyName("inner_hits")>]
        InnerHits: Map<string, SearchTypesInnerHitsResult> option
        [<JsonPropertyName("matched_queries")>]
        MatchedQueries: System.Text.Json.JsonElement option
        [<JsonPropertyName("_nested")>]
        Nested: SearchTypesNestedIdentity option
        [<JsonPropertyName("_ignored")>]
        Ignored: string array option
        [<JsonPropertyName("ignored_field_values")>]
        IgnoredFieldValues: Map<string, obj array> option
        [<JsonPropertyName("_shard")>]
        Shard: string option
        [<JsonPropertyName("_node")>]
        Node: string option
        [<JsonPropertyName("_routing")>]
        Routing: string option
        [<JsonPropertyName("_source")>]
        Source: obj option
        [<JsonPropertyName("_rank")>]
        Rank: float option
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("_version")>]
        Version: VersionNumber option
        [<JsonPropertyName("sort")>]
        Sort: SortResults option
    }

    and SearchTypesTotalHitsRelationConverter() =
        inherit JsonConverter<SearchTypesTotalHitsRelation>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesTotalHitsRelation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesTotalHitsRelation.Eq -> "eq"
                | SearchTypesTotalHitsRelation.Gte -> "gte"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "eq" -> SearchTypesTotalHitsRelation.Eq
            | "gte" -> SearchTypesTotalHitsRelation.Gte
            | s -> failwith $"Unknown SearchTypesTotalHitsRelation: {s}"

    and [<JsonConverter(typeof<SearchTypesTotalHitsRelationConverter>)>]
        SearchTypesTotalHitsRelation =
        | Eq
        | Gte
        with
        override this.ToString() =
            match this with
            | Eq -> "eq"
            | Gte -> "gte"

    and SearchTypesTotalHits = {
        [<JsonPropertyName("relation")>]
        Relation: SearchTypesTotalHitsRelation
        [<JsonPropertyName("value")>]
        Value: float
    }

    and SearchTypesHitsMetadata = {
        [<JsonPropertyName("total")>]
        Total: System.Text.Json.JsonElement option
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHit array
        [<JsonPropertyName("max_score")>]
        MaxScore: System.Text.Json.JsonElement option
    }

    and SearchTypesAggregationBreakdown = {
        [<JsonPropertyName("build_aggregation")>]
        BuildAggregation: float
        [<JsonPropertyName("build_aggregation_count")>]
        BuildAggregationCount: float
        [<JsonPropertyName("build_leaf_collector")>]
        BuildLeafCollector: float
        [<JsonPropertyName("build_leaf_collector_count")>]
        BuildLeafCollectorCount: float
        [<JsonPropertyName("collect")>]
        Collect: float
        [<JsonPropertyName("collect_count")>]
        CollectCount: float
        [<JsonPropertyName("initialize")>]
        Initialize: float
        [<JsonPropertyName("initialize_count")>]
        InitializeCount: float
        [<JsonPropertyName("post_collection")>]
        PostCollection: float option
        [<JsonPropertyName("post_collection_count")>]
        PostCollectionCount: float option
        [<JsonPropertyName("reduce")>]
        Reduce: float
        [<JsonPropertyName("reduce_count")>]
        ReduceCount: float
    }

    and SearchTypesAggregationProfileDelegateDebugFilter = {
        [<JsonPropertyName("results_from_metadata")>]
        ResultsFromMetadata: float option
        [<JsonPropertyName("query")>]
        Query: string option
        [<JsonPropertyName("specialized_for")>]
        SpecializedFor: string option
        [<JsonPropertyName("segments_counted_in_constant_time")>]
        SegmentsCountedInConstantTime: float option
    }

    and SearchTypesAggregationProfileDebug = {
        [<JsonPropertyName("segments_with_multi_valued_ords")>]
        SegmentsWithMultiValuedOrds: float option
        [<JsonPropertyName("collection_strategy")>]
        CollectionStrategy: string option
        [<JsonPropertyName("segments_with_single_valued_ords")>]
        SegmentsWithSingleValuedOrds: float option
        [<JsonPropertyName("total_buckets")>]
        TotalBuckets: float option
        [<JsonPropertyName("built_buckets")>]
        BuiltBuckets: float option
        [<JsonPropertyName("result_strategy")>]
        ResultStrategy: string option
        [<JsonPropertyName("has_filter")>]
        HasFilter: bool option
        [<JsonPropertyName("delegate")>]
        Delegate: string option
        [<JsonPropertyName("delegate_debug")>]
        DelegateDebug: SearchTypesAggregationProfileDebug option
        [<JsonPropertyName("chars_fetched")>]
        CharsFetched: float option
        [<JsonPropertyName("extract_count")>]
        ExtractCount: float option
        [<JsonPropertyName("extract_ns")>]
        ExtractNs: float option
        [<JsonPropertyName("values_fetched")>]
        ValuesFetched: float option
        [<JsonPropertyName("collect_analyzed_ns")>]
        CollectAnalyzedNs: float option
        [<JsonPropertyName("collect_analyzed_count")>]
        CollectAnalyzedCount: float option
        [<JsonPropertyName("surviving_buckets")>]
        SurvivingBuckets: float option
        [<JsonPropertyName("ordinals_collectors_used")>]
        OrdinalsCollectorsUsed: float option
        [<JsonPropertyName("ordinals_collectors_overhead_too_high")>]
        OrdinalsCollectorsOverheadTooHigh: float option
        [<JsonPropertyName("string_hashing_collectors_used")>]
        StringHashingCollectorsUsed: float option
        [<JsonPropertyName("numeric_collectors_used")>]
        NumericCollectorsUsed: float option
        [<JsonPropertyName("empty_collectors_used")>]
        EmptyCollectorsUsed: float option
        [<JsonPropertyName("deferred_aggregators")>]
        DeferredAggregators: string array option
        [<JsonPropertyName("segments_with_doc_count_field")>]
        SegmentsWithDocCountField: float option
        [<JsonPropertyName("segments_with_deleted_docs")>]
        SegmentsWithDeletedDocs: float option
        [<JsonPropertyName("filters")>]
        Filters: SearchTypesAggregationProfileDelegateDebugFilter array option
        [<JsonPropertyName("segments_counted")>]
        SegmentsCounted: float option
        [<JsonPropertyName("segments_collected")>]
        SegmentsCollected: float option
        [<JsonPropertyName("map_reducer")>]
        MapReducer: string option
        [<JsonPropertyName("brute_force_used")>]
        BruteForceUsed: float option
        [<JsonPropertyName("dynamic_pruning_attempted")>]
        DynamicPruningAttempted: float option
        [<JsonPropertyName("dynamic_pruning_used")>]
        DynamicPruningUsed: float option
        [<JsonPropertyName("skipped_due_to_no_data")>]
        SkippedDueToNoData: float option
    }

    /// <summary>
    /// Time unit for nanoseconds
    /// </summary>
    and UnitNanos = float

    and DurationValueUnitNanos = obj

    and SearchTypesAggregationProfile = {
        [<JsonPropertyName("breakdown")>]
        Breakdown: SearchTypesAggregationBreakdown
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("debug")>]
        Debug: SearchTypesAggregationProfileDebug option
        [<JsonPropertyName("children")>]
        Children: SearchTypesAggregationProfile array option
    }

    and SearchTypesKnnCollectorResult = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("reason")>]
        Reason: string
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("children")>]
        Children: SearchTypesKnnCollectorResult array option
    }

    and SearchTypesKnnQueryProfileBreakdown = {
        [<JsonPropertyName("advance")>]
        Advance: float
        [<JsonPropertyName("advance_count")>]
        AdvanceCount: float
        [<JsonPropertyName("build_scorer")>]
        BuildScorer: float
        [<JsonPropertyName("build_scorer_count")>]
        BuildScorerCount: float
        [<JsonPropertyName("compute_max_score")>]
        ComputeMaxScore: float
        [<JsonPropertyName("compute_max_score_count")>]
        ComputeMaxScoreCount: float
        [<JsonPropertyName("count_weight")>]
        CountWeight: float
        [<JsonPropertyName("count_weight_count")>]
        CountWeightCount: float
        [<JsonPropertyName("create_weight")>]
        CreateWeight: float
        [<JsonPropertyName("create_weight_count")>]
        CreateWeightCount: float
        [<JsonPropertyName("match")>]
        Match: float
        [<JsonPropertyName("match_count")>]
        MatchCount: float
        [<JsonPropertyName("next_doc")>]
        NextDoc: float
        [<JsonPropertyName("next_doc_count")>]
        NextDocCount: float
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("score_count")>]
        ScoreCount: float
        [<JsonPropertyName("set_min_competitive_score")>]
        SetMinCompetitiveScore: float
        [<JsonPropertyName("set_min_competitive_score_count")>]
        SetMinCompetitiveScoreCount: float
        [<JsonPropertyName("shallow_advance")>]
        ShallowAdvance: float
        [<JsonPropertyName("shallow_advance_count")>]
        ShallowAdvanceCount: float
    }

    and SearchTypesKnnQueryProfileResult = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("breakdown")>]
        Breakdown: SearchTypesKnnQueryProfileBreakdown
        [<JsonPropertyName("debug")>]
        Debug: Map<string, obj> option
        [<JsonPropertyName("children")>]
        Children: SearchTypesKnnQueryProfileResult array option
    }

    and SearchTypesDfsKnnProfile = {
        [<JsonPropertyName("vector_operations_count")>]
        VectorOperationsCount: float option
        [<JsonPropertyName("query")>]
        Query: SearchTypesKnnQueryProfileResult array
        [<JsonPropertyName("rewrite_time")>]
        RewriteTime: float
        [<JsonPropertyName("collector")>]
        Collector: SearchTypesKnnCollectorResult array
    }

    and SearchTypesDfsStatisticsBreakdown = {
        [<JsonPropertyName("collection_statistics")>]
        CollectionStatistics: float
        [<JsonPropertyName("collection_statistics_count")>]
        CollectionStatisticsCount: float
        [<JsonPropertyName("create_weight")>]
        CreateWeight: float
        [<JsonPropertyName("create_weight_count")>]
        CreateWeightCount: float
        [<JsonPropertyName("rewrite")>]
        Rewrite: float
        [<JsonPropertyName("rewrite_count")>]
        RewriteCount: float
        [<JsonPropertyName("term_statistics")>]
        TermStatistics: float
        [<JsonPropertyName("term_statistics_count")>]
        TermStatisticsCount: float
    }

    and SearchTypesDfsStatisticsProfile = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("breakdown")>]
        Breakdown: SearchTypesDfsStatisticsBreakdown
        [<JsonPropertyName("debug")>]
        Debug: Map<string, obj> option
        [<JsonPropertyName("children")>]
        Children: SearchTypesDfsStatisticsProfile array option
    }

    and SearchTypesDfsProfile = {
        [<JsonPropertyName("statistics")>]
        Statistics: SearchTypesDfsStatisticsProfile option
        [<JsonPropertyName("knn")>]
        Knn: SearchTypesDfsKnnProfile array option
    }

    and SearchTypesFetchProfileBreakdown = {
        [<JsonPropertyName("load_source")>]
        LoadSource: float option
        [<JsonPropertyName("load_source_count")>]
        LoadSourceCount: float option
        [<JsonPropertyName("load_stored_fields")>]
        LoadStoredFields: float option
        [<JsonPropertyName("load_stored_fields_count")>]
        LoadStoredFieldsCount: float option
        [<JsonPropertyName("next_reader")>]
        NextReader: float option
        [<JsonPropertyName("next_reader_count")>]
        NextReaderCount: float option
        [<JsonPropertyName("process_count")>]
        ProcessCount: float option
        [<JsonPropertyName("process")>]
        Process: float option
    }

    and SearchTypesFetchProfileDebug = {
        [<JsonPropertyName("stored_fields")>]
        StoredFields: string array option
        [<JsonPropertyName("fast_path")>]
        FastPath: float option
    }

    and SearchTypesFetchProfile = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("breakdown")>]
        Breakdown: SearchTypesFetchProfileBreakdown
        [<JsonPropertyName("debug")>]
        Debug: SearchTypesFetchProfileDebug option
        [<JsonPropertyName("children")>]
        Children: SearchTypesFetchProfile array option
    }

    and SearchTypesCollector = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("reason")>]
        Reason: string
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("children")>]
        Children: SearchTypesCollector array option
    }

    and SearchTypesQueryBreakdown = {
        [<JsonPropertyName("advance")>]
        Advance: float
        [<JsonPropertyName("advance_count")>]
        AdvanceCount: float
        [<JsonPropertyName("build_scorer")>]
        BuildScorer: float
        [<JsonPropertyName("build_scorer_count")>]
        BuildScorerCount: float
        [<JsonPropertyName("create_weight")>]
        CreateWeight: float
        [<JsonPropertyName("create_weight_count")>]
        CreateWeightCount: float
        [<JsonPropertyName("match")>]
        Match: float
        [<JsonPropertyName("match_count")>]
        MatchCount: float
        [<JsonPropertyName("shallow_advance")>]
        ShallowAdvance: float
        [<JsonPropertyName("shallow_advance_count")>]
        ShallowAdvanceCount: float
        [<JsonPropertyName("next_doc")>]
        NextDoc: float
        [<JsonPropertyName("next_doc_count")>]
        NextDocCount: float
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("score_count")>]
        ScoreCount: float
        [<JsonPropertyName("compute_max_score")>]
        ComputeMaxScore: float
        [<JsonPropertyName("compute_max_score_count")>]
        ComputeMaxScoreCount: float
        [<JsonPropertyName("count_weight")>]
        CountWeight: float
        [<JsonPropertyName("count_weight_count")>]
        CountWeightCount: float
        [<JsonPropertyName("set_min_competitive_score")>]
        SetMinCompetitiveScore: float
        [<JsonPropertyName("set_min_competitive_score_count")>]
        SetMinCompetitiveScoreCount: float
    }

    and SearchTypesQueryProfile = {
        [<JsonPropertyName("breakdown")>]
        Breakdown: SearchTypesQueryBreakdown
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("time_in_nanos")>]
        TimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("children")>]
        Children: SearchTypesQueryProfile array option
    }

    and SearchTypesSearchProfile = {
        [<JsonPropertyName("collector")>]
        Collector: SearchTypesCollector array
        [<JsonPropertyName("query")>]
        Query: SearchTypesQueryProfile array
        [<JsonPropertyName("rewrite_time")>]
        RewriteTime: float
    }

    and NodeId = string

    and SearchTypesShardProfile = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: SearchTypesAggregationProfile array
        [<JsonPropertyName("cluster")>]
        Cluster: string
        [<JsonPropertyName("dfs")>]
        Dfs: SearchTypesDfsProfile option
        [<JsonPropertyName("fetch")>]
        Fetch: SearchTypesFetchProfile option
        [<JsonPropertyName("id")>]
        Id: string
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("node_id")>]
        NodeId: NodeId
        [<JsonPropertyName("searches")>]
        Searches: SearchTypesSearchProfile array
        [<JsonPropertyName("shard_id")>]
        ShardId: float
    }

    and SearchTypesProfile = {
        [<JsonPropertyName("shards")>]
        Shards: SearchTypesShardProfile array
    }

    and GeoHash = string

    and GeoHashLocation = {
        [<JsonPropertyName("geohash")>]
        Geohash: GeoHash
    }

    and LatLonGeoLocation = {
        [<JsonPropertyName("lat")>]
        Lat: float
        [<JsonPropertyName("lon")>]
        Lon: float
    }

    /// <summary>
    /// A latitude/longitude as a 2 dimensional point. It can be represented in various ways:
    /// - as a `{lat, long}` object
    /// - as a geo hash value
    /// </summary>
    and GeoLocation = obj

    /// <summary>
    /// Text or location that we want similar documents for or a lookup to a document's field for the text.
    /// </summary>
    and SearchTypesContext = obj

    and Routing = obj

    and SearchTypesCompletionSuggestOption = {
        [<JsonPropertyName("collate_match")>]
        CollateMatch: bool option
        [<JsonPropertyName("contexts")>]
        Contexts: Map<string, SearchTypesContext array> option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("_id")>]
        Id: string option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("_routing")>]
        Routing: Routing option
        [<JsonPropertyName("_score")>]
        Score: float option
        [<JsonPropertyName("_source")>]
        Source: obj option
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("score")>]
        Score2: float option
    }

    and SearchTypesSuggestBase = {
        [<JsonPropertyName("length")>]
        Length: float
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("text")>]
        Text: string
    }

    and SearchTypesCompletionSuggest = {
        [<JsonPropertyName("length")>]
        Length: float
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("options")>]
        Options: System.Text.Json.JsonElement
    }

    and SearchTypesPhraseSuggestOption = {
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("highlighted")>]
        Highlighted: string option
        [<JsonPropertyName("collate_match")>]
        CollateMatch: bool option
    }

    and SearchTypesPhraseSuggest = {
        [<JsonPropertyName("length")>]
        Length: float
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("options")>]
        Options: System.Text.Json.JsonElement
    }

    and SearchTypesTermSuggestOption = {
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("freq")>]
        Freq: float
        [<JsonPropertyName("highlighted")>]
        Highlighted: string option
        [<JsonPropertyName("collate_match")>]
        CollateMatch: bool option
    }

    and SearchTypesTermSuggest = {
        [<JsonPropertyName("length")>]
        Length: float
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("options")>]
        Options: System.Text.Json.JsonElement
    }

    and SearchTypesSuggest = obj

    and ClusterSearchStatusConverter() =
        inherit JsonConverter<ClusterSearchStatus>()

        override _.Write(writer: Utf8JsonWriter, value: ClusterSearchStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ClusterSearchStatus.Running -> "running"
                | ClusterSearchStatus.Successful -> "successful"
                | ClusterSearchStatus.Partial -> "partial"
                | ClusterSearchStatus.Skipped -> "skipped"
                | ClusterSearchStatus.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "running" -> ClusterSearchStatus.Running
            | "successful" -> ClusterSearchStatus.Successful
            | "partial" -> ClusterSearchStatus.Partial
            | "skipped" -> ClusterSearchStatus.Skipped
            | "failed" -> ClusterSearchStatus.Failed
            | s -> failwith $"Unknown ClusterSearchStatus: {s}"

    and [<JsonConverter(typeof<ClusterSearchStatusConverter>)>]
        ClusterSearchStatus =
        | Running
        | Successful
        | Partial
        | Skipped
        | Failed
        with
        override this.ToString() =
            match this with
            | Running -> "running"
            | Successful -> "successful"
            | Partial -> "partial"
            | Skipped -> "skipped"
            | Failed -> "failed"

    /// <summary>
    /// Time unit for milliseconds
    /// </summary>
    and UnitMillis = float

    and DurationValueUnitMillis = obj

    /// <summary>
    /// Cause and details about a request failure. This class defines the properties common to all error types.
    /// Additional details are also provided, that depend on the error type.
    /// </summary>
    and ErrorCause = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("reason")>]
        Reason: System.Text.Json.JsonElement option
        [<JsonPropertyName("stack_trace")>]
        StackTrace: string option
        [<JsonPropertyName("caused_by")>]
        CausedBy: ErrorCause option
        [<JsonPropertyName("root_cause")>]
        RootCause: ErrorCause array option
        [<JsonPropertyName("suppressed")>]
        Suppressed: ErrorCause array option
    }

    and ShardFailure = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("node")>]
        Node: string option
        [<JsonPropertyName("reason")>]
        Reason: ErrorCause
        [<JsonPropertyName("shard")>]
        Shard: float option
        [<JsonPropertyName("status")>]
        Status: string option
        [<JsonPropertyName("primary")>]
        Primary: bool option
    }

    and Uint = float

    and ShardStatistics = {
        [<JsonPropertyName("failed")>]
        Failed: Uint
        [<JsonPropertyName("successful")>]
        Successful: Uint
        [<JsonPropertyName("total")>]
        Total: Uint
        [<JsonPropertyName("failures")>]
        Failures: ShardFailure array option
        [<JsonPropertyName("skipped")>]
        Skipped: Uint option
    }

    and ClusterDetails = {
        [<JsonPropertyName("status")>]
        Status: ClusterSearchStatus
        [<JsonPropertyName("indices")>]
        Indices: string
        [<JsonPropertyName("took")>]
        Took: DurationValueUnitMillis option
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics option
        [<JsonPropertyName("failures")>]
        Failures: ShardFailure array option
    }

    and ClusterStatistics = {
        [<JsonPropertyName("skipped")>]
        Skipped: float
        [<JsonPropertyName("successful")>]
        Successful: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("running")>]
        Running: float
        [<JsonPropertyName("partial")>]
        Partial: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("details")>]
        Details: Map<string, ClusterDetails> option
    }

    and ScrollId = string

    and Metadata = Map<string, obj>

    and AggregationsAggregateBase = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
    }

    /// <summary>
    /// Base type for multi-bucket aggregation results that can hold sub-aggregations results.
    /// </summary>
    and AggregationsMultiBucketBase = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsAdjacencyMatrixBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: string
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsAdjacencyMatrixBucket = obj

    and AggregationsMultiBucketAggregateBaseAdjacencyMatrixBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsAdjacencyMatrixBucket
    }

    and AggregationsAdjacencyMatrixAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsAdjacencyMatrixBucket
    }

    /// <summary>
    /// A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and
    /// `y` (year)
    /// </summary>
    and DurationLarge = string

    and EpochTimeUnitMillis = obj

    and AggregationsDateHistogramBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
        [<JsonPropertyName("key")>]
        Key: EpochTimeUnitMillis
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsDateHistogramBucket = obj

    and AggregationsMultiBucketAggregateBaseDateHistogramBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDateHistogramBucket
    }

    and AggregationsAutoDateHistogramAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDateHistogramBucket
        [<JsonPropertyName("interval")>]
        Interval: DurationLarge
    }

    and AggregationsSingleMetricAggregateBase = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsAvgAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsBoxPlotAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("min")>]
        Min: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("q1")>]
        Q1: float
        [<JsonPropertyName("q2")>]
        Q2: float
        [<JsonPropertyName("q3")>]
        Q3: float
        [<JsonPropertyName("lower")>]
        Lower: float
        [<JsonPropertyName("upper")>]
        Upper: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
        [<JsonPropertyName("q1_as_string")>]
        Q1AsString: string option
        [<JsonPropertyName("q2_as_string")>]
        Q2AsString: string option
        [<JsonPropertyName("q3_as_string")>]
        Q3AsString: string option
        [<JsonPropertyName("lower_as_string")>]
        LowerAsString: string option
        [<JsonPropertyName("upper_as_string")>]
        UpperAsString: string option
    }

    and AggregationsBucketMetricValueAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
        [<JsonPropertyName("keys")>]
        Keys: string array
    }

    and AggregationsCardinalityAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: float
    }

    and TopLeftBottomRightGeoBounds = {
        [<JsonPropertyName("top_left")>]
        TopLeft: GeoLocation
        [<JsonPropertyName("bottom_right")>]
        BottomRight: GeoLocation
    }

    and AggregationsCartesianBoundsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("bounds")>]
        Bounds: TopLeftBottomRightGeoBounds option
    }

    and CartesianPoint = {
        [<JsonPropertyName("x")>]
        X: float
        [<JsonPropertyName("y")>]
        Y: float
    }

    and AggregationsCartesianCentroidAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("location")>]
        Location: CartesianPoint option
    }

    and AggregationsChangePointBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: FieldValue
    }

    and AggregationsAbstractChangePoint = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsDip = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsDistributionChange = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsIndeterminable = {
        [<JsonPropertyName("reason")>]
        Reason: string
    }

    and AggregationsNonStationary = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("r_value")>]
        RValue: float
        [<JsonPropertyName("trend")>]
        Trend: string
    }

    and AggregationsSpike = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsStationary = obj

    and AggregationsStepChange = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsTrendChange = {
        [<JsonPropertyName("p_value")>]
        PValue: float
        [<JsonPropertyName("r_value")>]
        RValue: float
        [<JsonPropertyName("change_point")>]
        ChangePoint: float
    }

    and AggregationsChangeType = {
        [<JsonPropertyName("dip")>]
        Dip: AggregationsDip option
        [<JsonPropertyName("distribution_change")>]
        DistributionChange: AggregationsDistributionChange option
        [<JsonPropertyName("indeterminable")>]
        Indeterminable: AggregationsIndeterminable option
        [<JsonPropertyName("non_stationary")>]
        NonStationary: AggregationsNonStationary option
        [<JsonPropertyName("spike")>]
        Spike: AggregationsSpike option
        [<JsonPropertyName("stationary")>]
        Stationary: AggregationsStationary option
        [<JsonPropertyName("step_change")>]
        StepChange: AggregationsStepChange option
        [<JsonPropertyName("trend_change")>]
        TrendChange: AggregationsTrendChange option
    }

    and AggregationsChangePointAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("type")>]
        Type: AggregationsChangeType
        [<JsonPropertyName("bucket")>]
        Bucket: AggregationsChangePointBucket option
    }

    /// <summary>
    /// Base type for single-bucket aggregation results that can hold sub-aggregations results.
    /// </summary>
    and AggregationsSingleBucketAggregateBase = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsChildrenAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsCompositeAggregateKey = Map<string, FieldValue>

    and AggregationsCompositeBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: AggregationsCompositeAggregateKey
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsCompositeBucket = obj

    and AggregationsMultiBucketAggregateBaseCompositeBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsCompositeBucket
    }

    and AggregationsCompositeAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsCompositeBucket
        [<JsonPropertyName("after_key")>]
        AfterKey: AggregationsCompositeAggregateKey option
    }

    /// <summary>
    /// Result of the `cumulative_cardinality` aggregation
    /// </summary>
    and AggregationsCumulativeCardinalityAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: float
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsDateHistogramAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDateHistogramBucket
    }

    and AggregationsRangeBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("to")>]
        To: float option
        [<JsonPropertyName("from_as_string")>]
        FromAsString: string option
        [<JsonPropertyName("to_as_string")>]
        ToAsString: string option
        [<JsonPropertyName("key")>]
        Key: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsRangeBucket = obj

    and AggregationsMultiBucketAggregateBaseRangeBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsRangeBucket
    }

    and AggregationsRangeAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsRangeBucket
    }

    /// <summary>
    /// Result of a `date_range` aggregation. Same format as a for a `range` aggregation: `from` and `to`
    /// in `buckets` are milliseconds since the Epoch, represented as a floating point number.
    /// </summary>
    and AggregationsDateRangeAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsRangeBucket
    }

    and AggregationsDerivativeAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
        [<JsonPropertyName("normalized_value")>]
        NormalizedValue: float option
        [<JsonPropertyName("normalized_value_as_string")>]
        NormalizedValueAsString: string option
    }

    and AggregationsTermsBucketBase = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
    }

    and AggregationsDoubleTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsDoubleTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseDoubleTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDoubleTermsBucket
    }

    and AggregationsTermsAggregateBaseDoubleTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDoubleTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Result of a `terms` aggregation when the field is some kind of decimal number like a float, double, or distance.
    /// </summary>
    and AggregationsDoubleTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsDoubleTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    and AggregationsStandardDeviationBounds = {
        [<JsonPropertyName("upper")>]
        Upper: System.Text.Json.JsonElement
        [<JsonPropertyName("lower")>]
        Lower: System.Text.Json.JsonElement
        [<JsonPropertyName("upper_population")>]
        UpperPopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("lower_population")>]
        LowerPopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("upper_sampling")>]
        UpperSampling: System.Text.Json.JsonElement
        [<JsonPropertyName("lower_sampling")>]
        LowerSampling: System.Text.Json.JsonElement
    }

    and AggregationsStandardDeviationBoundsAsString = {
        [<JsonPropertyName("upper")>]
        Upper: string
        [<JsonPropertyName("lower")>]
        Lower: string
        [<JsonPropertyName("upper_population")>]
        UpperPopulation: string
        [<JsonPropertyName("lower_population")>]
        LowerPopulation: string
        [<JsonPropertyName("upper_sampling")>]
        UpperSampling: string
        [<JsonPropertyName("lower_sampling")>]
        LowerSampling: string
    }

    /// <summary>
    /// Statistics aggregation result. `min`, `max` and `avg` are missing if there were no values to process
    /// (`count` is zero).
    /// </summary>
    and AggregationsStatsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("min")>]
        Min: System.Text.Json.JsonElement
        [<JsonPropertyName("max")>]
        Max: System.Text.Json.JsonElement
        [<JsonPropertyName("avg")>]
        Avg: System.Text.Json.JsonElement
        [<JsonPropertyName("sum")>]
        Sum: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
        [<JsonPropertyName("avg_as_string")>]
        AvgAsString: string option
        [<JsonPropertyName("sum_as_string")>]
        SumAsString: string option
    }

    and AggregationsExtendedStatsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("min")>]
        Min: System.Text.Json.JsonElement
        [<JsonPropertyName("max")>]
        Max: System.Text.Json.JsonElement
        [<JsonPropertyName("avg")>]
        Avg: System.Text.Json.JsonElement
        [<JsonPropertyName("sum")>]
        Sum: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
        [<JsonPropertyName("avg_as_string")>]
        AvgAsString: string option
        [<JsonPropertyName("sum_as_string")>]
        SumAsString: string option
        [<JsonPropertyName("sum_of_squares")>]
        SumOfSquares: System.Text.Json.JsonElement
        [<JsonPropertyName("variance")>]
        Variance: System.Text.Json.JsonElement
        [<JsonPropertyName("variance_population")>]
        VariancePopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("variance_sampling")>]
        VarianceSampling: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation")>]
        StdDeviation: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_population")>]
        StdDeviationPopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_sampling")>]
        StdDeviationSampling: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_bounds")>]
        StdDeviationBounds: AggregationsStandardDeviationBounds option
        [<JsonPropertyName("sum_of_squares_as_string")>]
        SumOfSquaresAsString: string option
        [<JsonPropertyName("variance_as_string")>]
        VarianceAsString: string option
        [<JsonPropertyName("variance_population_as_string")>]
        VariancePopulationAsString: string option
        [<JsonPropertyName("variance_sampling_as_string")>]
        VarianceSamplingAsString: string option
        [<JsonPropertyName("std_deviation_as_string")>]
        StdDeviationAsString: string option
        [<JsonPropertyName("std_deviation_bounds_as_string")>]
        StdDeviationBoundsAsString: AggregationsStandardDeviationBoundsAsString option
    }

    and AggregationsExtendedStatsBucketAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("min")>]
        Min: System.Text.Json.JsonElement
        [<JsonPropertyName("max")>]
        Max: System.Text.Json.JsonElement
        [<JsonPropertyName("avg")>]
        Avg: System.Text.Json.JsonElement
        [<JsonPropertyName("sum")>]
        Sum: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
        [<JsonPropertyName("avg_as_string")>]
        AvgAsString: string option
        [<JsonPropertyName("sum_as_string")>]
        SumAsString: string option
        [<JsonPropertyName("sum_of_squares")>]
        SumOfSquares: System.Text.Json.JsonElement
        [<JsonPropertyName("variance")>]
        Variance: System.Text.Json.JsonElement
        [<JsonPropertyName("variance_population")>]
        VariancePopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("variance_sampling")>]
        VarianceSampling: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation")>]
        StdDeviation: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_population")>]
        StdDeviationPopulation: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_sampling")>]
        StdDeviationSampling: System.Text.Json.JsonElement
        [<JsonPropertyName("std_deviation_bounds")>]
        StdDeviationBounds: AggregationsStandardDeviationBounds option
        [<JsonPropertyName("sum_of_squares_as_string")>]
        SumOfSquaresAsString: string option
        [<JsonPropertyName("variance_as_string")>]
        VarianceAsString: string option
        [<JsonPropertyName("variance_population_as_string")>]
        VariancePopulationAsString: string option
        [<JsonPropertyName("variance_sampling_as_string")>]
        VarianceSamplingAsString: string option
        [<JsonPropertyName("std_deviation_as_string")>]
        StdDeviationAsString: string option
        [<JsonPropertyName("std_deviation_bounds_as_string")>]
        StdDeviationBoundsAsString: AggregationsStandardDeviationBoundsAsString option
    }

    and AggregationsFilterAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsFiltersBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsFiltersBucket = obj

    and AggregationsMultiBucketAggregateBaseFiltersBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsFiltersBucket
    }

    and AggregationsFiltersAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsFiltersBucket
    }

    and AggregationsFrequentItemSetsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: Map<string, string array>
        [<JsonPropertyName("support")>]
        Support: float
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsFrequentItemSetsBucket = obj

    and AggregationsMultiBucketAggregateBaseFrequentItemSetsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsFrequentItemSetsBucket
    }

    and AggregationsFrequentItemSetsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsFrequentItemSetsBucket
    }

    and CoordsGeoBounds = {
        [<JsonPropertyName("top")>]
        Top: float
        [<JsonPropertyName("bottom")>]
        Bottom: float
        [<JsonPropertyName("left")>]
        Left: float
        [<JsonPropertyName("right")>]
        Right: float
    }

    and TopRightBottomLeftGeoBounds = {
        [<JsonPropertyName("top_right")>]
        TopRight: GeoLocation
        [<JsonPropertyName("bottom_left")>]
        BottomLeft: GeoLocation
    }

    and WktGeoBounds = {
        [<JsonPropertyName("wkt")>]
        Wkt: string
    }

    /// <summary>
    /// A geo bounding box. It can be represented in various ways:
    /// - as 4 top/bottom/left/right coordinates
    /// - as 2 top_left / bottom_right points
    /// </summary>
    and GeoBounds = obj

    and AggregationsGeoBoundsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("bounds")>]
        Bounds: GeoBounds option
    }

    and AggregationsGeoCentroidAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("location")>]
        Location: GeoLocation option
    }

    /// <summary>
    /// Result of a `geo_distance` aggregation. The unit for `from` and `to` is meters by default.
    /// </summary>
    and AggregationsGeoDistanceAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsRangeBucket
    }

    and AggregationsGeoHashGridBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: GeoHash
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsGeoHashGridBucket = obj

    and AggregationsMultiBucketAggregateBaseGeoHashGridBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoHashGridBucket
    }

    and AggregationsGeoHashGridAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoHashGridBucket
    }

    /// <summary>
    /// A map hex cell (H3) reference
    /// </summary>
    and GeoHexCell = string

    and AggregationsGeoHexGridBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: GeoHexCell
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsGeoHexGridBucket = obj

    and AggregationsMultiBucketAggregateBaseGeoHexGridBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoHexGridBucket
    }

    and AggregationsGeoHexGridAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoHexGridBucket
    }

    /// <summary>
    /// A GeoJson GeoLine.
    /// </summary>
    and GeoLine = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("coordinates")>]
        Coordinates: float array array
    }

    and AggregationsGeoLineAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("geometry")>]
        Geometry: GeoLine
        [<JsonPropertyName("properties")>]
        Properties: obj
    }

    /// <summary>
    /// A map tile reference, represented as `{zoom}/{x}/{y}`
    /// </summary>
    and GeoTile = string

    and AggregationsGeoTileGridBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: GeoTile
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsGeoTileGridBucket = obj

    and AggregationsMultiBucketAggregateBaseGeoTileGridBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoTileGridBucket
    }

    and AggregationsGeoTileGridAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsGeoTileGridBucket
    }

    and AggregationsGlobalAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsArrayPercentilesItem = {
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsKeyedPercentiles = Map<string, System.Text.Json.JsonElement>

    and AggregationsPercentiles = obj

    and AggregationsPercentilesAggregateBase = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsHdrPercentileRanksAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsHdrPercentilesAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsHistogramBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
        [<JsonPropertyName("key")>]
        Key: float
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsHistogramBucket = obj

    and AggregationsMultiBucketAggregateBaseHistogramBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsHistogramBucket
    }

    and AggregationsHistogramAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsHistogramBucket
    }

    and AggregationsInferenceClassImportance = {
        [<JsonPropertyName("class_name")>]
        ClassName: string
        [<JsonPropertyName("importance")>]
        Importance: float
    }

    and AggregationsInferenceFeatureImportance = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("importance")>]
        Importance: float option
        [<JsonPropertyName("classes")>]
        Classes: AggregationsInferenceClassImportance array option
    }

    and AggregationsInferenceTopClassEntry = {
        [<JsonPropertyName("class_name")>]
        ClassName: FieldValue
        [<JsonPropertyName("class_probability")>]
        ClassProbability: float
        [<JsonPropertyName("class_score")>]
        ClassScore: float
    }

    and AggregationsInferenceAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: FieldValue option
        [<JsonPropertyName("feature_importance")>]
        FeatureImportance: AggregationsInferenceFeatureImportance array option
        [<JsonPropertyName("top_classes")>]
        TopClasses: AggregationsInferenceTopClassEntry array option
        [<JsonPropertyName("warning")>]
        Warning: string option
    }

    and AggregationsIpPrefixBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("is_ipv6")>]
        IsIpv6: bool
        [<JsonPropertyName("key")>]
        Key: string
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float
        [<JsonPropertyName("netmask")>]
        Netmask: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsIpPrefixBucket = obj

    and AggregationsMultiBucketAggregateBaseIpPrefixBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsIpPrefixBucket
    }

    and AggregationsIpPrefixAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsIpPrefixBucket
    }

    and AggregationsIpRangeBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: string option
        [<JsonPropertyName("from")>]
        From: string option
        [<JsonPropertyName("to")>]
        To: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsIpRangeBucket = obj

    and AggregationsMultiBucketAggregateBaseIpRangeBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsIpRangeBucket
    }

    and AggregationsIpRangeAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsIpRangeBucket
    }

    and AggregationsLongRareTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsLongRareTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseLongRareTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsLongRareTermsBucket
    }

    /// <summary>
    /// Result of the `rare_terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
    /// </summary>
    and AggregationsLongRareTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsLongRareTermsBucket
    }

    and AggregationsLongTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsLongTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseLongTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsLongTermsBucket
    }

    and AggregationsTermsAggregateBaseLongTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsLongTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Result of a `terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
    /// </summary>
    and AggregationsLongTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsLongTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    and AggregationsMatrixStatsFields = {
        [<JsonPropertyName("name")>]
        Name: Field
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("mean")>]
        Mean: float
        [<JsonPropertyName("variance")>]
        Variance: float
        [<JsonPropertyName("skewness")>]
        Skewness: float
        [<JsonPropertyName("kurtosis")>]
        Kurtosis: float
        [<JsonPropertyName("covariance")>]
        Covariance: Map<string, float>
        [<JsonPropertyName("correlation")>]
        Correlation: Map<string, float>
    }

    and AggregationsMatrixStatsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("fields")>]
        Fields: AggregationsMatrixStatsFields array option
    }

    and AggregationsMaxAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsMedianAbsoluteDeviationAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsMinAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsMissingAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsMultiTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: FieldValue array
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsMultiTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseMultiTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsMultiTermsBucket
    }

    and AggregationsTermsAggregateBaseMultiTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsMultiTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    and AggregationsMultiTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsMultiTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    and AggregationsNestedAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsParentAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsPercentilesBucketAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsRateAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: float
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsReverseNestedAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsSamplerAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsScriptedMetricAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: obj
    }

    and AggregationsSignificantTermsBucketBase = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("bg_count")>]
        BgCount: float
    }

    and AggregationsSignificantLongTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("bg_count")>]
        BgCount: float
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsSignificantLongTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseSignificantLongTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantLongTermsBucket
    }

    and AggregationsSignificantTermsAggregateBaseSignificantLongTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantLongTermsBucket
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    and AggregationsSignificantLongTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantLongTermsBucket
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    and AggregationsSignificantStringTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("score")>]
        Score: float
        [<JsonPropertyName("bg_count")>]
        BgCount: float
        [<JsonPropertyName("key")>]
        Key: string
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsSignificantStringTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseSignificantStringTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantStringTermsBucket
    }

    and AggregationsSignificantTermsAggregateBaseSignificantStringTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantStringTermsBucket
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    and AggregationsSignificantStringTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsSignificantStringTermsBucket
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    and AggregationsSimpleValueAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsStatsBucketAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("min")>]
        Min: System.Text.Json.JsonElement
        [<JsonPropertyName("max")>]
        Max: System.Text.Json.JsonElement
        [<JsonPropertyName("avg")>]
        Avg: System.Text.Json.JsonElement
        [<JsonPropertyName("sum")>]
        Sum: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
        [<JsonPropertyName("avg_as_string")>]
        AvgAsString: string option
        [<JsonPropertyName("sum_as_string")>]
        SumAsString: string option
    }

    and AggregationsStringRareTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: string
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsStringRareTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseStringRareTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsStringRareTermsBucket
    }

    /// <summary>
    /// Result of the `rare_terms` aggregation when the field is a string.
    /// </summary>
    and AggregationsStringRareTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsStringRareTermsBucket
    }

    and AggregationsStringStatsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("min_length")>]
        MinLength: System.Text.Json.JsonElement
        [<JsonPropertyName("max_length")>]
        MaxLength: System.Text.Json.JsonElement
        [<JsonPropertyName("avg_length")>]
        AvgLength: System.Text.Json.JsonElement
        [<JsonPropertyName("entropy")>]
        Entropy: System.Text.Json.JsonElement
        [<JsonPropertyName("distribution")>]
        Distribution: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_length_as_string")>]
        MinLengthAsString: string option
        [<JsonPropertyName("max_length_as_string")>]
        MaxLengthAsString: string option
        [<JsonPropertyName("avg_length_as_string")>]
        AvgLengthAsString: string option
    }

    and AggregationsStringTermsBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("key")>]
        Key: FieldValue
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsStringTermsBucket = obj

    and AggregationsMultiBucketAggregateBaseStringTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsStringTermsBucket
    }

    and AggregationsTermsAggregateBaseStringTermsBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsStringTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Result of a `terms` aggregation when the field is a string.
    /// </summary>
    and AggregationsStringTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsStringTermsBucket
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Sum aggregation result. `value` is always present and is zero if there were no values to process.
    /// </summary>
    and AggregationsSumAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsTDigestPercentileRanksAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsTDigestPercentilesAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("values")>]
        Values: AggregationsPercentiles
    }

    and AggregationsTTestAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsTimeSeriesBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("key")>]
        Key: Map<string, FieldValue>
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsTimeSeriesBucket = obj

    and AggregationsMultiBucketAggregateBaseTimeSeriesBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsTimeSeriesBucket
    }

    and AggregationsTimeSeriesAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsTimeSeriesBucket
    }

    and AggregationsTopHitsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHitsMetadata
    }

    and AggregationsTopMetrics = {
        [<JsonPropertyName("sort")>]
        Sort: System.Text.Json.JsonElement array
        [<JsonPropertyName("metrics")>]
        Metrics: Map<string, System.Text.Json.JsonElement>
    }

    and AggregationsTopMetricsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("top")>]
        Top: AggregationsTopMetrics array
    }

    /// <summary>
    /// The absence of any type. This is commonly used in APIs that don't return a body.
    /// Although "void" is generally used for the unit type that has only one value, this is to be interpreted as
    /// </summary>
    and Void = obj

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsVoid = obj

    and AggregationsMultiBucketAggregateBaseVoid = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
    }

    /// <summary>
    /// Result of a `rare_terms` aggregation when the field is unmapped. `buckets` is always empty.
    /// </summary>
    and AggregationsUnmappedRareTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
    }

    and AggregationsUnmappedSamplerAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("doc_count")>]
        DocCount: float
    }

    and AggregationsSignificantTermsAggregateBaseVoid = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    /// <summary>
    /// Result of the `significant_terms` aggregation on an unmapped field. `buckets` is always empty.
    /// </summary>
    and AggregationsUnmappedSignificantTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
        [<JsonPropertyName("bg_count")>]
        BgCount: float option
        [<JsonPropertyName("doc_count")>]
        DocCount: float option
    }

    and AggregationsTermsAggregateBaseVoid = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Result of a `terms` aggregation when the field is unmapped. `buckets` is always empty.
    /// </summary>
    and AggregationsUnmappedTermsAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVoid
        [<JsonPropertyName("doc_count_error_upper_bound")>]
        DocCountErrorUpperBound: float option
        [<JsonPropertyName("sum_other_doc_count")>]
        SumOtherDocCount: float option
    }

    /// <summary>
    /// Value count aggregation result. `value` is always present.
    /// </summary>
    and AggregationsValueCountAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsVariableWidthHistogramBucket = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("min")>]
        Min: float
        [<JsonPropertyName("key")>]
        Key: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min_as_string")>]
        MinAsString: string option
        [<JsonPropertyName("key_as_string")>]
        KeyAsString: string option
        [<JsonPropertyName("max_as_string")>]
        MaxAsString: string option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsVariableWidthHistogramBucket = obj

    and AggregationsMultiBucketAggregateBaseVariableWidthHistogramBucket = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVariableWidthHistogramBucket
    }

    and AggregationsVariableWidthHistogramAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("buckets")>]
        Buckets: AggregationsBucketsVariableWidthHistogramBucket
    }

    /// <summary>
    /// Weighted average aggregation result. `value` is missing if the weight was set to zero.
    /// </summary>
    and AggregationsWeightedAvgAggregate = {
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
        [<JsonPropertyName("value_as_string")>]
        ValueAsString: string option
    }

    and AggregationsAggregate = obj

    and TypesAsyncSearch = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregate> option
        [<JsonPropertyName("_clusters")>]
        Clusters: ClusterStatistics option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHitsMetadata
        [<JsonPropertyName("max_score")>]
        MaxScore: float option
        [<JsonPropertyName("num_reduce_phases")>]
        NumReducePhases: float option
        [<JsonPropertyName("profile")>]
        Profile: SearchTypesProfile option
        [<JsonPropertyName("pit_id")>]
        PitId: Id option
        [<JsonPropertyName("_scroll_id")>]
        ScrollId: ScrollId option
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("suggest")>]
        Suggest: Map<string, SearchTypesSuggest array> option
        [<JsonPropertyName("terminated_early")>]
        TerminatedEarly: bool option
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool
        [<JsonPropertyName("took")>]
        Took: float
    }

    /// <summary>
    /// A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a
    /// number of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string
    /// representation.
    /// </summary>
    and DateTime = obj

    and TypesAsyncSearchResponseBase = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool
        [<JsonPropertyName("is_running")>]
        IsRunning: bool
        [<JsonPropertyName("expiration_time")>]
        ExpirationTime: DateTime option
        [<JsonPropertyName("expiration_time_in_millis")>]
        ExpirationTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("completion_time")>]
        CompletionTime: DateTime option
        [<JsonPropertyName("completion_time_in_millis")>]
        CompletionTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
    }

    and TypesAsyncSearchDocumentResponseBase = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool
        [<JsonPropertyName("is_running")>]
        IsRunning: bool
        [<JsonPropertyName("expiration_time")>]
        ExpirationTime: DateTime option
        [<JsonPropertyName("expiration_time_in_millis")>]
        ExpirationTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("completion_time")>]
        CompletionTime: DateTime option
        [<JsonPropertyName("completion_time_in_millis")>]
        CompletionTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
        [<JsonPropertyName("response")>]
        Response: TypesAsyncSearch
    }

    and StatusStatusResponseBase = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool
        [<JsonPropertyName("is_running")>]
        IsRunning: bool
        [<JsonPropertyName("expiration_time")>]
        ExpirationTime: DateTime option
        [<JsonPropertyName("expiration_time_in_millis")>]
        ExpirationTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("completion_time")>]
        CompletionTime: DateTime option
        [<JsonPropertyName("completion_time_in_millis")>]
        CompletionTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("_clusters")>]
        Clusters: ClusterStatistics option
        [<JsonPropertyName("completion_status")>]
        CompletionStatus: float option
    }

    and Indices = obj

    and QueryDslOperatorConverter() =
        inherit JsonConverter<QueryDslOperator>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslOperator, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslOperator.And -> "and"
                | QueryDslOperator.AND -> "AND"
                | QueryDslOperator.Or -> "or"
                | QueryDslOperator.OR -> "OR"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "and" -> QueryDslOperator.And
            | "AND" -> QueryDslOperator.AND
            | "or" -> QueryDslOperator.Or
            | "OR" -> QueryDslOperator.OR
            | s -> failwith $"Unknown QueryDslOperator: {s}"

    and [<JsonConverter(typeof<QueryDslOperatorConverter>)>]
        QueryDslOperator =
        | And
        | AND
        | Or
        | OR
        with
        override this.ToString() =
            match this with
            | And -> "and"
            | AND -> "AND"
            | Or -> "or"
            | OR -> "OR"

    and Fields = obj

    and ExpandWildcardConverter() =
        inherit JsonConverter<ExpandWildcard>()

        override _.Write(writer: Utf8JsonWriter, value: ExpandWildcard, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ExpandWildcard.All -> "all"
                | ExpandWildcard.Open -> "open"
                | ExpandWildcard.Closed -> "closed"
                | ExpandWildcard.Hidden -> "hidden"
                | ExpandWildcard.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> ExpandWildcard.All
            | "open" -> ExpandWildcard.Open
            | "closed" -> ExpandWildcard.Closed
            | "hidden" -> ExpandWildcard.Hidden
            | "none" -> ExpandWildcard.None
            | s -> failwith $"Unknown ExpandWildcard: {s}"

    and [<JsonConverter(typeof<ExpandWildcardConverter>)>]
        ExpandWildcard =
        | All
        | Open
        | Closed
        | Hidden
        | None
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | Open -> "open"
            | Closed -> "closed"
            | Hidden -> "hidden"
            | None -> "none"

    and ExpandWildcards = obj

    and SearchTypeConverter() =
        inherit JsonConverter<SearchType>()

        override _.Write(writer: Utf8JsonWriter, value: SearchType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchType.QueryThenFetch -> "query_then_fetch"
                | SearchType.DfsQueryThenFetch -> "dfs_query_then_fetch"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "query_then_fetch" -> SearchType.QueryThenFetch
            | "dfs_query_then_fetch" -> SearchType.DfsQueryThenFetch
            | s -> failwith $"Unknown SearchType: {s}"

    and [<JsonConverter(typeof<SearchTypeConverter>)>]
        SearchType =
        | QueryThenFetch
        | DfsQueryThenFetch
        with
        override this.ToString() =
            match this with
            | QueryThenFetch -> "query_then_fetch"
            | DfsQueryThenFetch -> "dfs_query_then_fetch"

    and SuggestModeConverter() =
        inherit JsonConverter<SuggestMode>()

        override _.Write(writer: Utf8JsonWriter, value: SuggestMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SuggestMode.Missing -> "missing"
                | SuggestMode.Popular -> "popular"
                | SuggestMode.Always -> "always"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "missing" -> SuggestMode.Missing
            | "popular" -> SuggestMode.Popular
            | "always" -> SuggestMode.Always
            | s -> failwith $"Unknown SuggestMode: {s}"

    and [<JsonConverter(typeof<SuggestModeConverter>)>]
        SuggestMode =
        | Missing
        | Popular
        | Always
        with
        override this.ToString() =
            match this with
            | Missing -> "missing"
            | Popular -> "popular"
            | Always -> "always"

    /// <summary>
    /// Number of hits matching the query to count accurately. If true, the exact
    /// number of hits is returned at the cost of some performance. If false, the
    /// response does not include the total number of hits matching the query.
    /// </summary>
    and SearchTypesTrackHits = obj

    /// <summary>
    /// Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
    /// Used as a query parameter along with the `_source_includes` and `_source_excludes` parameters.
    /// </summary>
    and SearchTypesSourceConfigParam = obj

    and AggregationsAggregation = obj

    /// <summary>
    /// Base type for bucket aggregations. These aggregations also accept sub-aggregations.
    /// </summary>
    and AggregationsBucketAggregationBase = obj

    and QueryVector = float array

    and TextEmbedding = {
        [<JsonPropertyName("model_id")>]
        ModelId: string option
        [<JsonPropertyName("model_text")>]
        ModelText: string
    }

    and QueryVectorBuilder = {
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: TextEmbedding option
    }

    and RescoreVector = {
        [<JsonPropertyName("oversample")>]
        Oversample: float
    }

    and QueryDslQueryBase = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
    }

    and KnnQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("query_vector")>]
        QueryVector: QueryVector option
        [<JsonPropertyName("query_vector_builder")>]
        QueryVectorBuilder: QueryVectorBuilder option
        [<JsonPropertyName("num_candidates")>]
        NumCandidates: float option
        [<JsonPropertyName("visit_percentage")>]
        VisitPercentage: float option
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("similarity")>]
        Similarity: float option
        [<JsonPropertyName("rescore_vector")>]
        RescoreVector: RescoreVector option
    }

    /// <summary>
    /// The minimum number of terms that should match as integer, percentage or range
    /// </summary>
    and MinimumShouldMatch = obj

    and QueryDslBoolQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("must")>]
        Must: System.Text.Json.JsonElement option
        [<JsonPropertyName("must_not")>]
        MustNot: System.Text.Json.JsonElement option
        [<JsonPropertyName("should")>]
        Should: System.Text.Json.JsonElement option
    }

    and QueryDslBoostingQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("negative_boost")>]
        NegativeBoost: float
        [<JsonPropertyName("negative")>]
        Negative: QueryDslQueryContainer
        [<JsonPropertyName("positive")>]
        Positive: QueryDslQueryContainer
    }

    and QueryDslCombinedFieldsOperatorConverter() =
        inherit JsonConverter<QueryDslCombinedFieldsOperator>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslCombinedFieldsOperator, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslCombinedFieldsOperator.Or -> "or"
                | QueryDslCombinedFieldsOperator.And -> "and"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "or" -> QueryDslCombinedFieldsOperator.Or
            | "and" -> QueryDslCombinedFieldsOperator.And
            | s -> failwith $"Unknown QueryDslCombinedFieldsOperator: {s}"

    and [<JsonConverter(typeof<QueryDslCombinedFieldsOperatorConverter>)>]
        QueryDslCombinedFieldsOperator =
        | Or
        | And
        with
        override this.ToString() =
            match this with
            | Or -> "or"
            | And -> "and"

    and QueryDslCombinedFieldsZeroTermsConverter() =
        inherit JsonConverter<QueryDslCombinedFieldsZeroTerms>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslCombinedFieldsZeroTerms, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslCombinedFieldsZeroTerms.None -> "none"
                | QueryDslCombinedFieldsZeroTerms.All -> "all"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> QueryDslCombinedFieldsZeroTerms.None
            | "all" -> QueryDslCombinedFieldsZeroTerms.All
            | s -> failwith $"Unknown QueryDslCombinedFieldsZeroTerms: {s}"

    and [<JsonConverter(typeof<QueryDslCombinedFieldsZeroTermsConverter>)>]
        QueryDslCombinedFieldsZeroTerms =
        | None
        | All
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | All -> "all"

    and QueryDslCombinedFieldsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("fields")>]
        Fields: Field array
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("auto_generate_synonyms_phrase_query")>]
        AutoGenerateSynonymsPhraseQuery: bool option
        [<JsonPropertyName("operator")>]
        Operator: QueryDslCombinedFieldsOperator option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("zero_terms_query")>]
        ZeroTermsQuery: QueryDslCombinedFieldsZeroTerms option
    }

    and QueryDslCommonTermsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("cutoff_frequency")>]
        CutoffFrequency: float option
        [<JsonPropertyName("high_freq_operator")>]
        HighFreqOperator: QueryDslOperator option
        [<JsonPropertyName("low_freq_operator")>]
        LowFreqOperator: QueryDslOperator option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("query")>]
        Query: string
    }

    and QueryDslConstantScoreQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer
    }

    and QueryDslDisMaxQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("queries")>]
        Queries: QueryDslQueryContainer array
        [<JsonPropertyName("tie_breaker")>]
        TieBreaker: float option
    }

    and DateMath = string

    and QueryDslDistanceFeatureQueryBaseDateMathDuration = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: DateMath
        [<JsonPropertyName("pivot")>]
        Pivot: Duration
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslDateDistanceFeatureQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: DateMath
        [<JsonPropertyName("pivot")>]
        Pivot: Duration
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and Distance = string

    and QueryDslDistanceFeatureQueryBaseGeoLocationDistance = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: GeoLocation
        [<JsonPropertyName("pivot")>]
        Pivot: Distance
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslGeoDistanceFeatureQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: GeoLocation
        [<JsonPropertyName("pivot")>]
        Pivot: Distance
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslDistanceFeatureQueryBase = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: obj
        [<JsonPropertyName("pivot")>]
        Pivot: obj
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslUntypedDistanceFeatureQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("origin")>]
        Origin: obj
        [<JsonPropertyName("pivot")>]
        Pivot: obj
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslDistanceFeatureQuery = obj

    and QueryDslExistsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and QueryDslFunctionBoostModeConverter() =
        inherit JsonConverter<QueryDslFunctionBoostMode>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslFunctionBoostMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslFunctionBoostMode.Multiply -> "multiply"
                | QueryDslFunctionBoostMode.Replace -> "replace"
                | QueryDslFunctionBoostMode.Sum -> "sum"
                | QueryDslFunctionBoostMode.Avg -> "avg"
                | QueryDslFunctionBoostMode.Max -> "max"
                | QueryDslFunctionBoostMode.Min -> "min"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "multiply" -> QueryDslFunctionBoostMode.Multiply
            | "replace" -> QueryDslFunctionBoostMode.Replace
            | "sum" -> QueryDslFunctionBoostMode.Sum
            | "avg" -> QueryDslFunctionBoostMode.Avg
            | "max" -> QueryDslFunctionBoostMode.Max
            | "min" -> QueryDslFunctionBoostMode.Min
            | s -> failwith $"Unknown QueryDslFunctionBoostMode: {s}"

    and [<JsonConverter(typeof<QueryDslFunctionBoostModeConverter>)>]
        QueryDslFunctionBoostMode =
        | Multiply
        | Replace
        | Sum
        | Avg
        | Max
        | Min
        with
        override this.ToString() =
            match this with
            | Multiply -> "multiply"
            | Replace -> "replace"
            | Sum -> "sum"
            | Avg -> "avg"
            | Max -> "max"
            | Min -> "min"

    and QueryDslMultiValueModeConverter() =
        inherit JsonConverter<QueryDslMultiValueMode>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslMultiValueMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslMultiValueMode.Min -> "min"
                | QueryDslMultiValueMode.Max -> "max"
                | QueryDslMultiValueMode.Avg -> "avg"
                | QueryDslMultiValueMode.Sum -> "sum"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "min" -> QueryDslMultiValueMode.Min
            | "max" -> QueryDslMultiValueMode.Max
            | "avg" -> QueryDslMultiValueMode.Avg
            | "sum" -> QueryDslMultiValueMode.Sum
            | s -> failwith $"Unknown QueryDslMultiValueMode: {s}"

    and [<JsonConverter(typeof<QueryDslMultiValueModeConverter>)>]
        QueryDslMultiValueMode =
        | Min
        | Max
        | Avg
        | Sum
        with
        override this.ToString() =
            match this with
            | Min -> "min"
            | Max -> "max"
            | Avg -> "avg"
            | Sum -> "sum"

    and QueryDslDecayFunctionBaseDateMathDuration = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslDateDecayFunction = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslDecayFunctionBaseGeoLocationDistance = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslGeoDecayFunction = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslDecayFunctionBasedoubledouble = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslNumericDecayFunction = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslDecayFunctionBase = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslUntypedDecayFunction = {
        [<JsonPropertyName("multi_value_mode")>]
        MultiValueMode: QueryDslMultiValueMode option
    }

    and QueryDslDecayFunction = obj

    and QueryDslFieldValueFactorModifierConverter() =
        inherit JsonConverter<QueryDslFieldValueFactorModifier>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslFieldValueFactorModifier, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslFieldValueFactorModifier.None -> "none"
                | QueryDslFieldValueFactorModifier.Log -> "log"
                | QueryDslFieldValueFactorModifier.Log1p -> "log1p"
                | QueryDslFieldValueFactorModifier.Log2p -> "log2p"
                | QueryDslFieldValueFactorModifier.Ln -> "ln"
                | QueryDslFieldValueFactorModifier.Ln1p -> "ln1p"
                | QueryDslFieldValueFactorModifier.Ln2p -> "ln2p"
                | QueryDslFieldValueFactorModifier.Square -> "square"
                | QueryDslFieldValueFactorModifier.Sqrt -> "sqrt"
                | QueryDslFieldValueFactorModifier.Reciprocal -> "reciprocal"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> QueryDslFieldValueFactorModifier.None
            | "log" -> QueryDslFieldValueFactorModifier.Log
            | "log1p" -> QueryDslFieldValueFactorModifier.Log1p
            | "log2p" -> QueryDslFieldValueFactorModifier.Log2p
            | "ln" -> QueryDslFieldValueFactorModifier.Ln
            | "ln1p" -> QueryDslFieldValueFactorModifier.Ln1p
            | "ln2p" -> QueryDslFieldValueFactorModifier.Ln2p
            | "square" -> QueryDslFieldValueFactorModifier.Square
            | "sqrt" -> QueryDslFieldValueFactorModifier.Sqrt
            | "reciprocal" -> QueryDslFieldValueFactorModifier.Reciprocal
            | s -> failwith $"Unknown QueryDslFieldValueFactorModifier: {s}"

    and [<JsonConverter(typeof<QueryDslFieldValueFactorModifierConverter>)>]
        QueryDslFieldValueFactorModifier =
        | None
        | Log
        | Log1p
        | Log2p
        | Ln
        | Ln1p
        | Ln2p
        | Square
        | Sqrt
        | Reciprocal
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | Log -> "log"
            | Log1p -> "log1p"
            | Log2p -> "log2p"
            | Ln -> "ln"
            | Ln1p -> "ln1p"
            | Ln2p -> "ln2p"
            | Square -> "square"
            | Sqrt -> "sqrt"
            | Reciprocal -> "reciprocal"

    and QueryDslFieldValueFactorScoreFunction = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("factor")>]
        Factor: float option
        [<JsonPropertyName("missing")>]
        Missing: float option
        [<JsonPropertyName("modifier")>]
        Modifier: QueryDslFieldValueFactorModifier option
    }

    and QueryDslRandomScoreFunction = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("seed")>]
        Seed: System.Text.Json.JsonElement option
    }

    and ScriptLanguage = obj

    and SearchTypesBoundaryScannerConverter() =
        inherit JsonConverter<SearchTypesBoundaryScanner>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesBoundaryScanner, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesBoundaryScanner.Chars -> "chars"
                | SearchTypesBoundaryScanner.Sentence -> "sentence"
                | SearchTypesBoundaryScanner.Word -> "word"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chars" -> SearchTypesBoundaryScanner.Chars
            | "sentence" -> SearchTypesBoundaryScanner.Sentence
            | "word" -> SearchTypesBoundaryScanner.Word
            | s -> failwith $"Unknown SearchTypesBoundaryScanner: {s}"

    and [<JsonConverter(typeof<SearchTypesBoundaryScannerConverter>)>]
        SearchTypesBoundaryScanner =
        | Chars
        | Sentence
        | Word
        with
        override this.ToString() =
            match this with
            | Chars -> "chars"
            | Sentence -> "sentence"
            | Word -> "word"

    and SearchTypesHighlighterFragmenterConverter() =
        inherit JsonConverter<SearchTypesHighlighterFragmenter>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesHighlighterFragmenter, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesHighlighterFragmenter.Simple -> "simple"
                | SearchTypesHighlighterFragmenter.Span -> "span"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "simple" -> SearchTypesHighlighterFragmenter.Simple
            | "span" -> SearchTypesHighlighterFragmenter.Span
            | s -> failwith $"Unknown SearchTypesHighlighterFragmenter: {s}"

    and [<JsonConverter(typeof<SearchTypesHighlighterFragmenterConverter>)>]
        SearchTypesHighlighterFragmenter =
        | Simple
        | Span
        with
        override this.ToString() =
            match this with
            | Simple -> "simple"
            | Span -> "span"

    and SearchTypesHighlighterOrderConverter() =
        inherit JsonConverter<SearchTypesHighlighterOrder>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesHighlighterOrder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesHighlighterOrder.Score -> "score"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "score" -> SearchTypesHighlighterOrder.Score
            | s -> failwith $"Unknown SearchTypesHighlighterOrder: {s}"

    and [<JsonConverter(typeof<SearchTypesHighlighterOrderConverter>)>]
        SearchTypesHighlighterOrder =
        | Score
        with
        override this.ToString() =
            match this with
            | Score -> "score"

    and SearchTypesHighlighterTagsSchemaConverter() =
        inherit JsonConverter<SearchTypesHighlighterTagsSchema>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesHighlighterTagsSchema, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesHighlighterTagsSchema.Styled -> "styled"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "styled" -> SearchTypesHighlighterTagsSchema.Styled
            | s -> failwith $"Unknown SearchTypesHighlighterTagsSchema: {s}"

    and [<JsonConverter(typeof<SearchTypesHighlighterTagsSchemaConverter>)>]
        SearchTypesHighlighterTagsSchema =
        | Styled
        with
        override this.ToString() =
            match this with
            | Styled -> "styled"

    and SearchTypesHighlighterType = obj

    and SearchTypesHighlightBase = {
        [<JsonPropertyName("type")>]
        Type: SearchTypesHighlighterType option
        [<JsonPropertyName("boundary_chars")>]
        BoundaryChars: string option
        [<JsonPropertyName("boundary_max_scan")>]
        BoundaryMaxScan: float option
        [<JsonPropertyName("boundary_scanner")>]
        BoundaryScanner: SearchTypesBoundaryScanner option
        [<JsonPropertyName("boundary_scanner_locale")>]
        BoundaryScannerLocale: string option
        [<JsonPropertyName("force_source")>]
        ForceSource: bool option
        [<JsonPropertyName("fragmenter")>]
        Fragmenter: SearchTypesHighlighterFragmenter option
        [<JsonPropertyName("fragment_size")>]
        FragmentSize: float option
        [<JsonPropertyName("highlight_filter")>]
        HighlightFilter: bool option
        [<JsonPropertyName("highlight_query")>]
        HighlightQuery: QueryDslQueryContainer option
        [<JsonPropertyName("max_fragment_length")>]
        MaxFragmentLength: float option
        [<JsonPropertyName("max_analyzed_offset")>]
        MaxAnalyzedOffset: float option
        [<JsonPropertyName("no_match_size")>]
        NoMatchSize: float option
        [<JsonPropertyName("number_of_fragments")>]
        NumberOfFragments: float option
        [<JsonPropertyName("options")>]
        Options: Map<string, obj> option
        [<JsonPropertyName("order")>]
        Order: SearchTypesHighlighterOrder option
        [<JsonPropertyName("phrase_limit")>]
        PhraseLimit: float option
        [<JsonPropertyName("post_tags")>]
        PostTags: string array option
        [<JsonPropertyName("pre_tags")>]
        PreTags: string array option
        [<JsonPropertyName("require_field_match")>]
        RequireFieldMatch: bool option
        [<JsonPropertyName("tags_schema")>]
        TagsSchema: SearchTypesHighlighterTagsSchema option
    }

    and SearchTypesHighlightField = {
        [<JsonPropertyName("type")>]
        Type: SearchTypesHighlighterType option
        [<JsonPropertyName("boundary_chars")>]
        BoundaryChars: string option
        [<JsonPropertyName("boundary_max_scan")>]
        BoundaryMaxScan: float option
        [<JsonPropertyName("boundary_scanner")>]
        BoundaryScanner: SearchTypesBoundaryScanner option
        [<JsonPropertyName("boundary_scanner_locale")>]
        BoundaryScannerLocale: string option
        [<JsonPropertyName("force_source")>]
        ForceSource: bool option
        [<JsonPropertyName("fragmenter")>]
        Fragmenter: SearchTypesHighlighterFragmenter option
        [<JsonPropertyName("fragment_size")>]
        FragmentSize: float option
        [<JsonPropertyName("highlight_filter")>]
        HighlightFilter: bool option
        [<JsonPropertyName("highlight_query")>]
        HighlightQuery: QueryDslQueryContainer option
        [<JsonPropertyName("max_fragment_length")>]
        MaxFragmentLength: float option
        [<JsonPropertyName("max_analyzed_offset")>]
        MaxAnalyzedOffset: float option
        [<JsonPropertyName("no_match_size")>]
        NoMatchSize: float option
        [<JsonPropertyName("number_of_fragments")>]
        NumberOfFragments: float option
        [<JsonPropertyName("options")>]
        Options: Map<string, obj> option
        [<JsonPropertyName("order")>]
        Order: SearchTypesHighlighterOrder option
        [<JsonPropertyName("phrase_limit")>]
        PhraseLimit: float option
        [<JsonPropertyName("post_tags")>]
        PostTags: string array option
        [<JsonPropertyName("pre_tags")>]
        PreTags: string array option
        [<JsonPropertyName("require_field_match")>]
        RequireFieldMatch: bool option
        [<JsonPropertyName("tags_schema")>]
        TagsSchema: SearchTypesHighlighterTagsSchema option
        [<JsonPropertyName("fragment_offset")>]
        FragmentOffset: float option
        [<JsonPropertyName("matched_fields")>]
        MatchedFields: Fields option
    }

    and SearchTypesHighlighterEncoderConverter() =
        inherit JsonConverter<SearchTypesHighlighterEncoder>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesHighlighterEncoder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesHighlighterEncoder.Default -> "default"
                | SearchTypesHighlighterEncoder.Html -> "html"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "default" -> SearchTypesHighlighterEncoder.Default
            | "html" -> SearchTypesHighlighterEncoder.Html
            | s -> failwith $"Unknown SearchTypesHighlighterEncoder: {s}"

    and [<JsonConverter(typeof<SearchTypesHighlighterEncoderConverter>)>]
        SearchTypesHighlighterEncoder =
        | Default
        | Html
        with
        override this.ToString() =
            match this with
            | Default -> "default"
            | Html -> "html"

    and SearchTypesHighlight = {
        [<JsonPropertyName("type")>]
        Type: SearchTypesHighlighterType option
        [<JsonPropertyName("boundary_chars")>]
        BoundaryChars: string option
        [<JsonPropertyName("boundary_max_scan")>]
        BoundaryMaxScan: float option
        [<JsonPropertyName("boundary_scanner")>]
        BoundaryScanner: SearchTypesBoundaryScanner option
        [<JsonPropertyName("boundary_scanner_locale")>]
        BoundaryScannerLocale: string option
        [<JsonPropertyName("force_source")>]
        ForceSource: bool option
        [<JsonPropertyName("fragmenter")>]
        Fragmenter: SearchTypesHighlighterFragmenter option
        [<JsonPropertyName("fragment_size")>]
        FragmentSize: float option
        [<JsonPropertyName("highlight_filter")>]
        HighlightFilter: bool option
        [<JsonPropertyName("highlight_query")>]
        HighlightQuery: QueryDslQueryContainer option
        [<JsonPropertyName("max_fragment_length")>]
        MaxFragmentLength: float option
        [<JsonPropertyName("max_analyzed_offset")>]
        MaxAnalyzedOffset: float option
        [<JsonPropertyName("no_match_size")>]
        NoMatchSize: float option
        [<JsonPropertyName("number_of_fragments")>]
        NumberOfFragments: float option
        [<JsonPropertyName("options")>]
        Options: Map<string, obj> option
        [<JsonPropertyName("order")>]
        Order: SearchTypesHighlighterOrder option
        [<JsonPropertyName("phrase_limit")>]
        PhraseLimit: float option
        [<JsonPropertyName("post_tags")>]
        PostTags: string array option
        [<JsonPropertyName("pre_tags")>]
        PreTags: string array option
        [<JsonPropertyName("require_field_match")>]
        RequireFieldMatch: bool option
        [<JsonPropertyName("tags_schema")>]
        TagsSchema: SearchTypesHighlighterTagsSchema option
        [<JsonPropertyName("encoder")>]
        Encoder: SearchTypesHighlighterEncoder option
        [<JsonPropertyName("fields")>]
        Fields: System.Text.Json.JsonElement
    }

    and SearchTypesSourceFilter = {
        [<JsonPropertyName("exclude_vectors")>]
        ExcludeVectors: bool option
        [<JsonPropertyName("excludes")>]
        Excludes: Fields option
        [<JsonPropertyName("includes")>]
        Includes: Fields option
    }

    /// <summary>
    /// Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
    /// </summary>
    and SearchTypesSourceConfig = obj

    and Name = string

    and ScriptField = {
        [<JsonPropertyName("script")>]
        Script: Script
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
    }

    and DistanceUnitConverter() =
        inherit JsonConverter<DistanceUnit>()

        override _.Write(writer: Utf8JsonWriter, value: DistanceUnit, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DistanceUnit.In -> "in"
                | DistanceUnit.Ft -> "ft"
                | DistanceUnit.Yd -> "yd"
                | DistanceUnit.Mi -> "mi"
                | DistanceUnit.Nmi -> "nmi"
                | DistanceUnit.Km -> "km"
                | DistanceUnit.M -> "m"
                | DistanceUnit.Cm -> "cm"
                | DistanceUnit.Mm -> "mm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "in" -> DistanceUnit.In
            | "ft" -> DistanceUnit.Ft
            | "yd" -> DistanceUnit.Yd
            | "mi" -> DistanceUnit.Mi
            | "nmi" -> DistanceUnit.Nmi
            | "km" -> DistanceUnit.Km
            | "m" -> DistanceUnit.M
            | "cm" -> DistanceUnit.Cm
            | "mm" -> DistanceUnit.Mm
            | s -> failwith $"Unknown DistanceUnit: {s}"

    and [<JsonConverter(typeof<DistanceUnitConverter>)>]
        DistanceUnit =
        | In
        | Ft
        | Yd
        | Mi
        | Nmi
        | Km
        | M
        | Cm
        | Mm
        with
        override this.ToString() =
            match this with
            | In -> "in"
            | Ft -> "ft"
            | Yd -> "yd"
            | Mi -> "mi"
            | Nmi -> "nmi"
            | Km -> "km"
            | M -> "m"
            | Cm -> "cm"
            | Mm -> "mm"

    and GeoDistanceTypeConverter() =
        inherit JsonConverter<GeoDistanceType>()

        override _.Write(writer: Utf8JsonWriter, value: GeoDistanceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GeoDistanceType.Arc -> "arc"
                | GeoDistanceType.Plane -> "plane"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "arc" -> GeoDistanceType.Arc
            | "plane" -> GeoDistanceType.Plane
            | s -> failwith $"Unknown GeoDistanceType: {s}"

    and [<JsonConverter(typeof<GeoDistanceTypeConverter>)>]
        GeoDistanceType =
        | Arc
        | Plane
        with
        override this.ToString() =
            match this with
            | Arc -> "arc"
            | Plane -> "plane"

    and NestedSortValue = {
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("max_children")>]
        MaxChildren: float option
        [<JsonPropertyName("nested")>]
        Nested: NestedSortValue option
        [<JsonPropertyName("path")>]
        Path: Field
    }

    and SortModeConverter() =
        inherit JsonConverter<SortMode>()

        override _.Write(writer: Utf8JsonWriter, value: SortMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SortMode.Min -> "min"
                | SortMode.Max -> "max"
                | SortMode.Sum -> "sum"
                | SortMode.Avg -> "avg"
                | SortMode.Median -> "median"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "min" -> SortMode.Min
            | "max" -> SortMode.Max
            | "sum" -> SortMode.Sum
            | "avg" -> SortMode.Avg
            | "median" -> SortMode.Median
            | s -> failwith $"Unknown SortMode: {s}"

    and [<JsonConverter(typeof<SortModeConverter>)>]
        SortMode =
        | Min
        | Max
        | Sum
        | Avg
        | Median
        with
        override this.ToString() =
            match this with
            | Min -> "min"
            | Max -> "max"
            | Sum -> "sum"
            | Avg -> "avg"
            | Median -> "median"

    and SortOrderConverter() =
        inherit JsonConverter<SortOrder>()

        override _.Write(writer: Utf8JsonWriter, value: SortOrder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SortOrder.Asc -> "asc"
                | SortOrder.Desc -> "desc"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "asc" -> SortOrder.Asc
            | "desc" -> SortOrder.Desc
            | s -> failwith $"Unknown SortOrder: {s}"

    and [<JsonConverter(typeof<SortOrderConverter>)>]
        SortOrder =
        | Asc
        | Desc
        with
        override this.ToString() =
            match this with
            | Asc -> "asc"
            | Desc -> "desc"

    and GeoDistanceSort = {
        [<JsonPropertyName("mode")>]
        Mode: SortMode option
        [<JsonPropertyName("distance_type")>]
        DistanceType: GeoDistanceType option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("unit")>]
        Unit: DistanceUnit option
        [<JsonPropertyName("nested")>]
        Nested: NestedSortValue option
    }

    and ScoreSort = {
        [<JsonPropertyName("order")>]
        Order: SortOrder option
    }

    and ScriptSortTypeConverter() =
        inherit JsonConverter<ScriptSortType>()

        override _.Write(writer: Utf8JsonWriter, value: ScriptSortType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ScriptSortType.String -> "string"
                | ScriptSortType.Number -> "number"
                | ScriptSortType.Version -> "version"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "string" -> ScriptSortType.String
            | "number" -> ScriptSortType.Number
            | "version" -> ScriptSortType.Version
            | s -> failwith $"Unknown ScriptSortType: {s}"

    and [<JsonConverter(typeof<ScriptSortTypeConverter>)>]
        ScriptSortType =
        | String
        | Number
        | Version
        with
        override this.ToString() =
            match this with
            | String -> "string"
            | Number -> "number"
            | Version -> "version"

    and ScriptSort = {
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("script")>]
        Script: Script
        [<JsonPropertyName("type")>]
        Type: ScriptSortType option
        [<JsonPropertyName("mode")>]
        Mode: SortMode option
        [<JsonPropertyName("nested")>]
        Nested: NestedSortValue option
    }

    and SortOptions = {
        [<JsonPropertyName("_score")>]
        Score: ScoreSort option
        [<JsonPropertyName("_doc")>]
        Doc: ScoreSort option
        [<JsonPropertyName("_geo_distance")>]
        GeoDistance: GeoDistanceSort option
        [<JsonPropertyName("_script")>]
        Script: ScriptSort option
    }

    and SortCombinations = obj

    and Sort = obj

    /// <summary>
    /// A reference to a field with formatting instructions on how to return the value
    /// </summary>
    and QueryDslFieldAndFormat = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("include_unmapped")>]
        IncludeUnmapped: bool option
    }

    and SearchTypesInnerHits = {
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("collapse")>]
        Collapse: SearchTypesFieldCollapse option
        [<JsonPropertyName("docvalue_fields")>]
        DocvalueFields: QueryDslFieldAndFormat array option
        [<JsonPropertyName("explain")>]
        Explain: bool option
        [<JsonPropertyName("highlight")>]
        Highlight: SearchTypesHighlight option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("script_fields")>]
        ScriptFields: Map<string, ScriptField> option
        [<JsonPropertyName("seq_no_primary_term")>]
        SeqNoPrimaryTerm: bool option
        [<JsonPropertyName("fields")>]
        Fields: Field array option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("stored_fields")>]
        StoredFields: Fields option
        [<JsonPropertyName("track_scores")>]
        TrackScores: bool option
        [<JsonPropertyName("version")>]
        Version: bool option
    }

    and SearchTypesFieldCollapse = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("inner_hits")>]
        InnerHits: System.Text.Json.JsonElement option
        [<JsonPropertyName("max_concurrent_group_searches")>]
        MaxConcurrentGroupSearches: float option
        [<JsonPropertyName("collapse")>]
        Collapse: SearchTypesFieldCollapse option
    }

    and SearchTypesPointInTimeReference = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("keep_alive")>]
        KeepAlive: Duration option
    }

    and SearchTypesLearningToRank = {
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
    }

    and SearchTypesScoreModeConverter() =
        inherit JsonConverter<SearchTypesScoreMode>()

        override _.Write(writer: Utf8JsonWriter, value: SearchTypesScoreMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchTypesScoreMode.Avg -> "avg"
                | SearchTypesScoreMode.Max -> "max"
                | SearchTypesScoreMode.Min -> "min"
                | SearchTypesScoreMode.Multiply -> "multiply"
                | SearchTypesScoreMode.Total -> "total"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "avg" -> SearchTypesScoreMode.Avg
            | "max" -> SearchTypesScoreMode.Max
            | "min" -> SearchTypesScoreMode.Min
            | "multiply" -> SearchTypesScoreMode.Multiply
            | "total" -> SearchTypesScoreMode.Total
            | s -> failwith $"Unknown SearchTypesScoreMode: {s}"

    and [<JsonConverter(typeof<SearchTypesScoreModeConverter>)>]
        SearchTypesScoreMode =
        | Avg
        | Max
        | Min
        | Multiply
        | Total
        with
        override this.ToString() =
            match this with
            | Avg -> "avg"
            | Max -> "max"
            | Min -> "min"
            | Multiply -> "multiply"
            | Total -> "total"

    and SearchTypesRescoreQuery = {
        [<JsonPropertyName("rescore_query")>]
        RescoreQuery: QueryDslQueryContainer
        [<JsonPropertyName("query_weight")>]
        QueryWeight: float option
        [<JsonPropertyName("rescore_query_weight")>]
        RescoreQueryWeight: float option
        [<JsonPropertyName("score_mode")>]
        ScoreMode: SearchTypesScoreMode option
    }

    and SearchTypesScriptRescore = {
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and SearchTypesRescore = {
        [<JsonPropertyName("window_size")>]
        WindowSize: float option
        [<JsonPropertyName("query")>]
        Query: SearchTypesRescoreQuery option
        [<JsonPropertyName("learning_to_rank")>]
        LearningToRank: SearchTypesLearningToRank option
        [<JsonPropertyName("script")>]
        Script: SearchTypesScriptRescore option
    }

    and SearchTypesSuggester = {
        [<JsonPropertyName("text")>]
        Text: string option
    }

    and KnnSearch = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("query_vector")>]
        QueryVector: QueryVector option
        [<JsonPropertyName("query_vector_builder")>]
        QueryVectorBuilder: QueryVectorBuilder option
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("num_candidates")>]
        NumCandidates: float option
        [<JsonPropertyName("visit_percentage")>]
        VisitPercentage: float option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("similarity")>]
        Similarity: float option
        [<JsonPropertyName("inner_hits")>]
        InnerHits: SearchTypesInnerHits option
        [<JsonPropertyName("rescore_vector")>]
        RescoreVector: RescoreVector option
    }

    and RankBase = obj

    and RrfRank = {
        [<JsonPropertyName("rank_constant")>]
        RankConstant: float option
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
    }

    and RankContainer = {
        [<JsonPropertyName("rrf")>]
        Rrf: RrfRank option
    }

    and DiversifyRetrieverTypesConverter() =
        inherit JsonConverter<DiversifyRetrieverTypes>()

        override _.Write(writer: Utf8JsonWriter, value: DiversifyRetrieverTypes, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DiversifyRetrieverTypes.Mmr -> "mmr"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "mmr" -> DiversifyRetrieverTypes.Mmr
            | s -> failwith $"Unknown DiversifyRetrieverTypes: {s}"

    and [<JsonConverter(typeof<DiversifyRetrieverTypesConverter>)>]
        DiversifyRetrieverTypes =
        | Mmr
        with
        override this.ToString() =
            match this with
            | Mmr -> "mmr"

    and RetrieverBase = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
    }

    and DiversifyRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("type")>]
        Type: DiversifyRetrieverTypes
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
        [<JsonPropertyName("query_vector")>]
        QueryVector: QueryVector option
        [<JsonPropertyName("query_vector_builder")>]
        QueryVectorBuilder: QueryVectorBuilder option
        [<JsonPropertyName("lambda")>]
        Lambda: float option
    }

    and KnnRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("query_vector")>]
        QueryVector: QueryVector option
        [<JsonPropertyName("query_vector_builder")>]
        QueryVectorBuilder: QueryVectorBuilder option
        [<JsonPropertyName("k")>]
        K: float
        [<JsonPropertyName("num_candidates")>]
        NumCandidates: float
        [<JsonPropertyName("visit_percentage")>]
        VisitPercentage: float option
        [<JsonPropertyName("similarity")>]
        Similarity: float option
        [<JsonPropertyName("rescore_vector")>]
        RescoreVector: RescoreVector option
    }

    and ScoreNormalizerConverter() =
        inherit JsonConverter<ScoreNormalizer>()

        override _.Write(writer: Utf8JsonWriter, value: ScoreNormalizer, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ScoreNormalizer.None -> "none"
                | ScoreNormalizer.Minmax -> "minmax"
                | ScoreNormalizer.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> ScoreNormalizer.None
            | "minmax" -> ScoreNormalizer.Minmax
            | "l2_norm" -> ScoreNormalizer.L2Norm
            | s -> failwith $"Unknown ScoreNormalizer: {s}"

    and [<JsonConverter(typeof<ScoreNormalizerConverter>)>]
        ScoreNormalizer =
        | None
        | Minmax
        | L2Norm
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | Minmax -> "minmax"
            | L2Norm -> "l2_norm"

    and InnerRetriever = {
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("weight")>]
        Weight: float
        [<JsonPropertyName("normalizer")>]
        Normalizer: ScoreNormalizer
    }

    and LinearRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("retrievers")>]
        Retrievers: InnerRetriever array option
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
        [<JsonPropertyName("query")>]
        Query: string option
        [<JsonPropertyName("fields")>]
        Fields: string array option
        [<JsonPropertyName("normalizer")>]
        Normalizer: ScoreNormalizer option
    }

    and SpecifiedDocument = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("id")>]
        Id: Id
    }

    and PinnedRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("ids")>]
        Ids: string array option
        [<JsonPropertyName("docs")>]
        Docs: SpecifiedDocument array option
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
    }

    /// <summary>
    /// Wraps a retriever with an optional weight for RRF scoring.
    /// </summary>
    and RRFRetrieverComponent = {
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("weight")>]
        Weight: float option
    }

    /// <summary>
    /// Either a direct RetrieverContainer (backward compatible) or an RRFRetrieverComponent with weight.
    /// </summary>
    and RRFRetrieverEntry = obj

    and RRFRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("retrievers")>]
        Retrievers: RRFRetrieverEntry array
        [<JsonPropertyName("rank_constant")>]
        RankConstant: float option
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
        [<JsonPropertyName("query")>]
        Query: string option
        [<JsonPropertyName("fields")>]
        Fields: string array option
    }

    and RescorerRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("rescore")>]
        Rescore: System.Text.Json.JsonElement
    }

    and RuleRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ruleset_ids")>]
        RulesetIds: System.Text.Json.JsonElement
        [<JsonPropertyName("match_criteria")>]
        MatchCriteria: obj
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
    }

    and StandardRetriever = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("search_after")>]
        SearchAfter: SortResults option
        [<JsonPropertyName("terminate_after")>]
        TerminateAfter: float option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
        [<JsonPropertyName("collapse")>]
        Collapse: SearchTypesFieldCollapse option
    }

    and MappingChunkRescorerChunkingSettings = {
        [<JsonPropertyName("strategy")>]
        Strategy: string option
        [<JsonPropertyName("separator_group")>]
        SeparatorGroup: string option
        [<JsonPropertyName("separators")>]
        Separators: string array option
        [<JsonPropertyName("max_chunk_size")>]
        MaxChunkSize: float
        [<JsonPropertyName("overlap")>]
        Overlap: float option
        [<JsonPropertyName("sentence_overlap")>]
        SentenceOverlap: float option
    }

    and ChunkRescorer = {
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: MappingChunkRescorerChunkingSettings option
    }

    and TextSimilarityReranker = {
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer
        [<JsonPropertyName("rank_window_size")>]
        RankWindowSize: float option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string option
        [<JsonPropertyName("inference_text")>]
        InferenceText: string
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("chunk_rescorer")>]
        ChunkRescorer: ChunkRescorer option
    }

    and RetrieverContainer = {
        [<JsonPropertyName("standard")>]
        Standard: StandardRetriever option
        [<JsonPropertyName("knn")>]
        Knn: KnnRetriever option
        [<JsonPropertyName("rrf")>]
        Rrf: RRFRetriever option
        [<JsonPropertyName("text_similarity_reranker")>]
        TextSimilarityReranker: TextSimilarityReranker option
        [<JsonPropertyName("rule")>]
        Rule: RuleRetriever option
        [<JsonPropertyName("rescorer")>]
        Rescorer: RescorerRetriever option
        [<JsonPropertyName("linear")>]
        Linear: LinearRetriever option
        [<JsonPropertyName("pinned")>]
        Pinned: PinnedRetriever option
        [<JsonPropertyName("diversify")>]
        Diversify: DiversifyRetriever option
    }

    and SlicedScroll = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("max")>]
        Max: float
    }

    and MappingRuntimeFieldTypeConverter() =
        inherit JsonConverter<MappingRuntimeFieldType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingRuntimeFieldType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingRuntimeFieldType.Boolean -> "boolean"
                | MappingRuntimeFieldType.Composite -> "composite"
                | MappingRuntimeFieldType.Date -> "date"
                | MappingRuntimeFieldType.Double -> "double"
                | MappingRuntimeFieldType.GeoPoint -> "geo_point"
                | MappingRuntimeFieldType.GeoShape -> "geo_shape"
                | MappingRuntimeFieldType.Ip -> "ip"
                | MappingRuntimeFieldType.Keyword -> "keyword"
                | MappingRuntimeFieldType.Long -> "long"
                | MappingRuntimeFieldType.Lookup -> "lookup"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "boolean" -> MappingRuntimeFieldType.Boolean
            | "composite" -> MappingRuntimeFieldType.Composite
            | "date" -> MappingRuntimeFieldType.Date
            | "double" -> MappingRuntimeFieldType.Double
            | "geo_point" -> MappingRuntimeFieldType.GeoPoint
            | "geo_shape" -> MappingRuntimeFieldType.GeoShape
            | "ip" -> MappingRuntimeFieldType.Ip
            | "keyword" -> MappingRuntimeFieldType.Keyword
            | "long" -> MappingRuntimeFieldType.Long
            | "lookup" -> MappingRuntimeFieldType.Lookup
            | s -> failwith $"Unknown MappingRuntimeFieldType: {s}"

    and [<JsonConverter(typeof<MappingRuntimeFieldTypeConverter>)>]
        MappingRuntimeFieldType =
        | Boolean
        | Composite
        | Date
        | Double
        | GeoPoint
        | GeoShape
        | Ip
        | Keyword
        | Long
        | Lookup
        with
        override this.ToString() =
            match this with
            | Boolean -> "boolean"
            | Composite -> "composite"
            | Date -> "date"
            | Double -> "double"
            | GeoPoint -> "geo_point"
            | GeoShape -> "geo_shape"
            | Ip -> "ip"
            | Keyword -> "keyword"
            | Long -> "long"
            | Lookup -> "lookup"

    and MappingCompositeSubField = {
        [<JsonPropertyName("type")>]
        Type: MappingRuntimeFieldType
    }

    and MappingRuntimeFieldFetchFields = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and MappingRuntimeField = {
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingCompositeSubField> option
        [<JsonPropertyName("fetch_fields")>]
        FetchFields: MappingRuntimeFieldFetchFields array option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("input_field")>]
        InputField: Field option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("target_index")>]
        TargetIndex: IndexName option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("type")>]
        Type: MappingRuntimeFieldType
    }

    and MappingRuntimeFields = Map<string, MappingRuntimeField>

    and SearchTypesSearchRequestBody = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregationContainer> option
        [<JsonPropertyName("collapse")>]
        Collapse: SearchTypesFieldCollapse option
        [<JsonPropertyName("explain")>]
        Explain: bool option
        [<JsonPropertyName("ext")>]
        Ext: Map<string, obj> option
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("highlight")>]
        Highlight: SearchTypesHighlight option
        [<JsonPropertyName("track_total_hits")>]
        TrackTotalHits: SearchTypesTrackHits option
        [<JsonPropertyName("indices_boost")>]
        IndicesBoost: Map<string, float> array option
        [<JsonPropertyName("docvalue_fields")>]
        DocvalueFields: QueryDslFieldAndFormat array option
        [<JsonPropertyName("knn")>]
        Knn: System.Text.Json.JsonElement option
        [<JsonPropertyName("rank")>]
        Rank: RankContainer option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("post_filter")>]
        PostFilter: QueryDslQueryContainer option
        [<JsonPropertyName("profile")>]
        Profile: bool option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("rescore")>]
        Rescore: System.Text.Json.JsonElement option
        [<JsonPropertyName("retriever")>]
        Retriever: RetrieverContainer option
        [<JsonPropertyName("script_fields")>]
        ScriptFields: Map<string, ScriptField> option
        [<JsonPropertyName("search_after")>]
        SearchAfter: SortResults option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("slice")>]
        Slice: SlicedScroll option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("fields")>]
        Fields: QueryDslFieldAndFormat array option
        [<JsonPropertyName("suggest")>]
        Suggest: SearchTypesSuggester option
        [<JsonPropertyName("terminate_after")>]
        TerminateAfter: float option
        [<JsonPropertyName("timeout")>]
        Timeout: string option
        [<JsonPropertyName("track_scores")>]
        TrackScores: bool option
        [<JsonPropertyName("version")>]
        Version: bool option
        [<JsonPropertyName("seq_no_primary_term")>]
        SeqNoPrimaryTerm: bool option
        [<JsonPropertyName("stored_fields")>]
        StoredFields: Fields option
        [<JsonPropertyName("pit")>]
        Pit: SearchTypesPointInTimeReference option
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
        [<JsonPropertyName("stats")>]
        Stats: string array option
    }

    and ScriptSource = obj

    and Script = {
        [<JsonPropertyName("source")>]
        Source: ScriptSource option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("lang")>]
        Lang: ScriptLanguage option
        [<JsonPropertyName("options")>]
        Options: Map<string, string> option
    }

    and QueryDslScriptScoreFunction = {
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and QueryDslFunctionScoreContainer = {
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("weight")>]
        Weight: float option
        [<JsonPropertyName("exp")>]
        Exp: QueryDslDecayFunction option
        [<JsonPropertyName("gauss")>]
        Gauss: QueryDslDecayFunction option
        [<JsonPropertyName("linear")>]
        Linear: QueryDslDecayFunction option
        [<JsonPropertyName("field_value_factor")>]
        FieldValueFactor: QueryDslFieldValueFactorScoreFunction option
        [<JsonPropertyName("random_score")>]
        RandomScore: QueryDslRandomScoreFunction option
        [<JsonPropertyName("script_score")>]
        ScriptScore: QueryDslScriptScoreFunction option
    }

    and QueryDslFunctionScoreModeConverter() =
        inherit JsonConverter<QueryDslFunctionScoreMode>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslFunctionScoreMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslFunctionScoreMode.Multiply -> "multiply"
                | QueryDslFunctionScoreMode.Sum -> "sum"
                | QueryDslFunctionScoreMode.Avg -> "avg"
                | QueryDslFunctionScoreMode.First -> "first"
                | QueryDslFunctionScoreMode.Max -> "max"
                | QueryDslFunctionScoreMode.Min -> "min"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "multiply" -> QueryDslFunctionScoreMode.Multiply
            | "sum" -> QueryDslFunctionScoreMode.Sum
            | "avg" -> QueryDslFunctionScoreMode.Avg
            | "first" -> QueryDslFunctionScoreMode.First
            | "max" -> QueryDslFunctionScoreMode.Max
            | "min" -> QueryDslFunctionScoreMode.Min
            | s -> failwith $"Unknown QueryDslFunctionScoreMode: {s}"

    and [<JsonConverter(typeof<QueryDslFunctionScoreModeConverter>)>]
        QueryDslFunctionScoreMode =
        | Multiply
        | Sum
        | Avg
        | First
        | Max
        | Min
        with
        override this.ToString() =
            match this with
            | Multiply -> "multiply"
            | Sum -> "sum"
            | Avg -> "avg"
            | First -> "first"
            | Max -> "max"
            | Min -> "min"

    and QueryDslFunctionScoreQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("boost_mode")>]
        BoostMode: QueryDslFunctionBoostMode option
        [<JsonPropertyName("functions")>]
        Functions: QueryDslFunctionScoreContainer array option
        [<JsonPropertyName("max_boost")>]
        MaxBoost: float option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("score_mode")>]
        ScoreMode: QueryDslFunctionScoreMode option
    }

    and Fuzziness = obj

    and MultiTermQueryRewrite = string

    and QueryDslFuzzyQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("max_expansions")>]
        MaxExpansions: float option
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float option
        [<JsonPropertyName("rewrite")>]
        Rewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("transpositions")>]
        Transpositions: bool option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement
    }

    and QueryDslGeoExecutionConverter() =
        inherit JsonConverter<QueryDslGeoExecution>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslGeoExecution, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslGeoExecution.Memory -> "memory"
                | QueryDslGeoExecution.Indexed -> "indexed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "memory" -> QueryDslGeoExecution.Memory
            | "indexed" -> QueryDslGeoExecution.Indexed
            | s -> failwith $"Unknown QueryDslGeoExecution: {s}"

    and [<JsonConverter(typeof<QueryDslGeoExecutionConverter>)>]
        QueryDslGeoExecution =
        | Memory
        | Indexed
        with
        override this.ToString() =
            match this with
            | Memory -> "memory"
            | Indexed -> "indexed"

    and QueryDslGeoValidationMethodConverter() =
        inherit JsonConverter<QueryDslGeoValidationMethod>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslGeoValidationMethod, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslGeoValidationMethod.Coerce -> "coerce"
                | QueryDslGeoValidationMethod.IgnoreMalformed -> "ignore_malformed"
                | QueryDslGeoValidationMethod.Strict -> "strict"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "coerce" -> QueryDslGeoValidationMethod.Coerce
            | "ignore_malformed" -> QueryDslGeoValidationMethod.IgnoreMalformed
            | "strict" -> QueryDslGeoValidationMethod.Strict
            | s -> failwith $"Unknown QueryDslGeoValidationMethod: {s}"

    and [<JsonConverter(typeof<QueryDslGeoValidationMethodConverter>)>]
        QueryDslGeoValidationMethod =
        | Coerce
        | IgnoreMalformed
        | Strict
        with
        override this.ToString() =
            match this with
            | Coerce -> "coerce"
            | IgnoreMalformed -> "ignore_malformed"
            | Strict -> "strict"

    and QueryDslGeoBoundingBoxQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("type")>]
        Type: QueryDslGeoExecution option
        [<JsonPropertyName("validation_method")>]
        ValidationMethod: QueryDslGeoValidationMethod option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
    }

    and QueryDslGeoDistanceQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("distance")>]
        Distance: Distance
        [<JsonPropertyName("distance_type")>]
        DistanceType: GeoDistanceType option
        [<JsonPropertyName("validation_method")>]
        ValidationMethod: QueryDslGeoValidationMethod option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
    }

    and QueryDslGeoGridQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("geotile")>]
        Geotile: GeoTile option
        [<JsonPropertyName("geohash")>]
        Geohash: GeoHash option
        [<JsonPropertyName("geohex")>]
        Geohex: GeoHexCell option
    }

    and QueryDslGeoPolygonQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("validation_method")>]
        ValidationMethod: QueryDslGeoValidationMethod option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
    }

    and QueryDslGeoShapeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
    }

    and RelationName = string

    and QueryDslChildScoreModeConverter() =
        inherit JsonConverter<QueryDslChildScoreMode>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslChildScoreMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslChildScoreMode.None -> "none"
                | QueryDslChildScoreMode.Avg -> "avg"
                | QueryDslChildScoreMode.Sum -> "sum"
                | QueryDslChildScoreMode.Max -> "max"
                | QueryDslChildScoreMode.Min -> "min"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> QueryDslChildScoreMode.None
            | "avg" -> QueryDslChildScoreMode.Avg
            | "sum" -> QueryDslChildScoreMode.Sum
            | "max" -> QueryDslChildScoreMode.Max
            | "min" -> QueryDslChildScoreMode.Min
            | s -> failwith $"Unknown QueryDslChildScoreMode: {s}"

    and [<JsonConverter(typeof<QueryDslChildScoreModeConverter>)>]
        QueryDslChildScoreMode =
        | None
        | Avg
        | Sum
        | Max
        | Min
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | Avg -> "avg"
            | Sum -> "sum"
            | Max -> "max"
            | Min -> "min"

    and QueryDslHasChildQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("inner_hits")>]
        InnerHits: SearchTypesInnerHits option
        [<JsonPropertyName("max_children")>]
        MaxChildren: float option
        [<JsonPropertyName("min_children")>]
        MinChildren: float option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
        [<JsonPropertyName("score_mode")>]
        ScoreMode: QueryDslChildScoreMode option
        [<JsonPropertyName("type")>]
        Type: RelationName
    }

    and QueryDslHasParentQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("inner_hits")>]
        InnerHits: SearchTypesInnerHits option
        [<JsonPropertyName("parent_type")>]
        ParentType: RelationName
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
        [<JsonPropertyName("score")>]
        Score: bool option
    }

    and Ids = obj

    and QueryDslIdsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("values")>]
        Values: Ids option
    }

    and QueryDslIntervalsFilter = {
        [<JsonPropertyName("after")>]
        After: QueryDslIntervalsContainer option
        [<JsonPropertyName("before")>]
        Before: QueryDslIntervalsContainer option
        [<JsonPropertyName("contained_by")>]
        ContainedBy: QueryDslIntervalsContainer option
        [<JsonPropertyName("containing")>]
        Containing: QueryDslIntervalsContainer option
        [<JsonPropertyName("not_contained_by")>]
        NotContainedBy: QueryDslIntervalsContainer option
        [<JsonPropertyName("not_containing")>]
        NotContaining: QueryDslIntervalsContainer option
        [<JsonPropertyName("not_overlapping")>]
        NotOverlapping: QueryDslIntervalsContainer option
        [<JsonPropertyName("overlapping")>]
        Overlapping: QueryDslIntervalsContainer option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and QueryDslIntervalsAnyOf = {
        [<JsonPropertyName("intervals")>]
        Intervals: QueryDslIntervalsContainer array
        [<JsonPropertyName("filter")>]
        Filter: QueryDslIntervalsFilter option
    }

    and QueryDslIntervalsFuzzy = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float option
        [<JsonPropertyName("term")>]
        Term: string
        [<JsonPropertyName("transpositions")>]
        Transpositions: bool option
        [<JsonPropertyName("use_field")>]
        UseField: Field option
    }

    and QueryDslIntervalsMatch = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("max_gaps")>]
        MaxGaps: float option
        [<JsonPropertyName("ordered")>]
        Ordered: bool option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("use_field")>]
        UseField: Field option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslIntervalsFilter option
    }

    and QueryDslIntervalsPrefix = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("prefix")>]
        Prefix: string
        [<JsonPropertyName("use_field")>]
        UseField: Field option
    }

    and QueryDslIntervalsRange = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("gte")>]
        Gte: string option
        [<JsonPropertyName("gt")>]
        Gt: string option
        [<JsonPropertyName("lte")>]
        Lte: string option
        [<JsonPropertyName("lt")>]
        Lt: string option
        [<JsonPropertyName("use_field")>]
        UseField: Field option
    }

    and QueryDslIntervalsRegexp = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("pattern")>]
        Pattern: string
        [<JsonPropertyName("use_field")>]
        UseField: Field option
    }

    and QueryDslIntervalsWildcard = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("pattern")>]
        Pattern: string
        [<JsonPropertyName("use_field")>]
        UseField: Field option
    }

    and QueryDslIntervalsContainer = {
        [<JsonPropertyName("all_of")>]
        AllOf: QueryDslIntervalsAllOf option
        [<JsonPropertyName("any_of")>]
        AnyOf: QueryDslIntervalsAnyOf option
        [<JsonPropertyName("fuzzy")>]
        Fuzzy: QueryDslIntervalsFuzzy option
        [<JsonPropertyName("match")>]
        Match: QueryDslIntervalsMatch option
        [<JsonPropertyName("prefix")>]
        Prefix: QueryDslIntervalsPrefix option
        [<JsonPropertyName("range")>]
        Range: QueryDslIntervalsRange option
        [<JsonPropertyName("regexp")>]
        Regexp: QueryDslIntervalsRegexp option
        [<JsonPropertyName("wildcard")>]
        Wildcard: QueryDslIntervalsWildcard option
    }

    and QueryDslIntervalsAllOf = {
        [<JsonPropertyName("intervals")>]
        Intervals: QueryDslIntervalsContainer array
        [<JsonPropertyName("max_gaps")>]
        MaxGaps: float option
        [<JsonPropertyName("ordered")>]
        Ordered: bool option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslIntervalsFilter option
    }

    and QueryDslIntervalsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("all_of")>]
        AllOf: QueryDslIntervalsAllOf option
        [<JsonPropertyName("any_of")>]
        AnyOf: QueryDslIntervalsAnyOf option
        [<JsonPropertyName("fuzzy")>]
        Fuzzy: QueryDslIntervalsFuzzy option
        [<JsonPropertyName("match")>]
        Match: QueryDslIntervalsMatch option
        [<JsonPropertyName("prefix")>]
        Prefix: QueryDslIntervalsPrefix option
        [<JsonPropertyName("range")>]
        Range: QueryDslIntervalsRange option
        [<JsonPropertyName("regexp")>]
        Regexp: QueryDslIntervalsRegexp option
        [<JsonPropertyName("wildcard")>]
        Wildcard: QueryDslIntervalsWildcard option
    }

    and QueryDslMatchAllQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
    }

    and QueryDslMatchBoolPrefixQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("fuzzy_rewrite")>]
        FuzzyRewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("fuzzy_transpositions")>]
        FuzzyTranspositions: bool option
        [<JsonPropertyName("max_expansions")>]
        MaxExpansions: float option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("operator")>]
        Operator: QueryDslOperator option
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float option
        [<JsonPropertyName("query")>]
        Query: string
    }

    and QueryDslMatchNoneQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
    }

    and QueryDslZeroTermsQueryConverter() =
        inherit JsonConverter<QueryDslZeroTermsQuery>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslZeroTermsQuery, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslZeroTermsQuery.All -> "all"
                | QueryDslZeroTermsQuery.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> QueryDslZeroTermsQuery.All
            | "none" -> QueryDslZeroTermsQuery.None
            | s -> failwith $"Unknown QueryDslZeroTermsQuery: {s}"

    and [<JsonConverter(typeof<QueryDslZeroTermsQueryConverter>)>]
        QueryDslZeroTermsQuery =
        | All
        | None
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | None -> "none"

    and QueryDslMatchPhrasePrefixQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("max_expansions")>]
        MaxExpansions: float option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("slop")>]
        Slop: float option
        [<JsonPropertyName("zero_terms_query")>]
        ZeroTermsQuery: QueryDslZeroTermsQuery option
    }

    and QueryDslMatchPhraseQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("slop")>]
        Slop: float option
        [<JsonPropertyName("zero_terms_query")>]
        ZeroTermsQuery: QueryDslZeroTermsQuery option
    }

    and QueryDslMatchQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("auto_generate_synonyms_phrase_query")>]
        AutoGenerateSynonymsPhraseQuery: bool option
        [<JsonPropertyName("cutoff_frequency")>]
        CutoffFrequency: float option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("fuzzy_rewrite")>]
        FuzzyRewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("fuzzy_transpositions")>]
        FuzzyTranspositions: bool option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("max_expansions")>]
        MaxExpansions: float option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("operator")>]
        Operator: QueryDslOperator option
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float option
        [<JsonPropertyName("query")>]
        Query: System.Text.Json.JsonElement
        [<JsonPropertyName("zero_terms_query")>]
        ZeroTermsQuery: QueryDslZeroTermsQuery option
    }

    and VersionTypeConverter() =
        inherit JsonConverter<VersionType>()

        override _.Write(writer: Utf8JsonWriter, value: VersionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | VersionType.Internal -> "internal"
                | VersionType.External -> "external"
                | VersionType.ExternalGte -> "external_gte"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "internal" -> VersionType.Internal
            | "external" -> VersionType.External
            | "external_gte" -> VersionType.ExternalGte
            | s -> failwith $"Unknown VersionType: {s}"

    and [<JsonConverter(typeof<VersionTypeConverter>)>]
        VersionType =
        | Internal
        | External
        | ExternalGte
        with
        override this.ToString() =
            match this with
            | Internal -> "internal"
            | External -> "external"
            | ExternalGte -> "external_gte"

    and AnalysisStopWordLanguageConverter() =
        inherit JsonConverter<AnalysisStopWordLanguage>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisStopWordLanguage, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisStopWordLanguage.Arabic -> "_arabic_"
                | AnalysisStopWordLanguage.Armenian -> "_armenian_"
                | AnalysisStopWordLanguage.Basque -> "_basque_"
                | AnalysisStopWordLanguage.Bengali -> "_bengali_"
                | AnalysisStopWordLanguage.Brazilian -> "_brazilian_"
                | AnalysisStopWordLanguage.Bulgarian -> "_bulgarian_"
                | AnalysisStopWordLanguage.Catalan -> "_catalan_"
                | AnalysisStopWordLanguage.Cjk -> "_cjk_"
                | AnalysisStopWordLanguage.Czech -> "_czech_"
                | AnalysisStopWordLanguage.Danish -> "_danish_"
                | AnalysisStopWordLanguage.Dutch -> "_dutch_"
                | AnalysisStopWordLanguage.English -> "_english_"
                | AnalysisStopWordLanguage.Estonian -> "_estonian_"
                | AnalysisStopWordLanguage.Finnish -> "_finnish_"
                | AnalysisStopWordLanguage.French -> "_french_"
                | AnalysisStopWordLanguage.Galician -> "_galician_"
                | AnalysisStopWordLanguage.German -> "_german_"
                | AnalysisStopWordLanguage.Greek -> "_greek_"
                | AnalysisStopWordLanguage.Hindi -> "_hindi_"
                | AnalysisStopWordLanguage.Hungarian -> "_hungarian_"
                | AnalysisStopWordLanguage.Indonesian -> "_indonesian_"
                | AnalysisStopWordLanguage.Irish -> "_irish_"
                | AnalysisStopWordLanguage.Italian -> "_italian_"
                | AnalysisStopWordLanguage.Latvian -> "_latvian_"
                | AnalysisStopWordLanguage.Lithuanian -> "_lithuanian_"
                | AnalysisStopWordLanguage.Norwegian -> "_norwegian_"
                | AnalysisStopWordLanguage.Persian -> "_persian_"
                | AnalysisStopWordLanguage.Portuguese -> "_portuguese_"
                | AnalysisStopWordLanguage.Romanian -> "_romanian_"
                | AnalysisStopWordLanguage.Russian -> "_russian_"
                | AnalysisStopWordLanguage.Serbian -> "_serbian_"
                | AnalysisStopWordLanguage.Sorani -> "_sorani_"
                | AnalysisStopWordLanguage.Spanish -> "_spanish_"
                | AnalysisStopWordLanguage.Swedish -> "_swedish_"
                | AnalysisStopWordLanguage.Thai -> "_thai_"
                | AnalysisStopWordLanguage.Turkish -> "_turkish_"
                | AnalysisStopWordLanguage.None -> "_none_"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_arabic_" -> AnalysisStopWordLanguage.Arabic
            | "_armenian_" -> AnalysisStopWordLanguage.Armenian
            | "_basque_" -> AnalysisStopWordLanguage.Basque
            | "_bengali_" -> AnalysisStopWordLanguage.Bengali
            | "_brazilian_" -> AnalysisStopWordLanguage.Brazilian
            | "_bulgarian_" -> AnalysisStopWordLanguage.Bulgarian
            | "_catalan_" -> AnalysisStopWordLanguage.Catalan
            | "_cjk_" -> AnalysisStopWordLanguage.Cjk
            | "_czech_" -> AnalysisStopWordLanguage.Czech
            | "_danish_" -> AnalysisStopWordLanguage.Danish
            | "_dutch_" -> AnalysisStopWordLanguage.Dutch
            | "_english_" -> AnalysisStopWordLanguage.English
            | "_estonian_" -> AnalysisStopWordLanguage.Estonian
            | "_finnish_" -> AnalysisStopWordLanguage.Finnish
            | "_french_" -> AnalysisStopWordLanguage.French
            | "_galician_" -> AnalysisStopWordLanguage.Galician
            | "_german_" -> AnalysisStopWordLanguage.German
            | "_greek_" -> AnalysisStopWordLanguage.Greek
            | "_hindi_" -> AnalysisStopWordLanguage.Hindi
            | "_hungarian_" -> AnalysisStopWordLanguage.Hungarian
            | "_indonesian_" -> AnalysisStopWordLanguage.Indonesian
            | "_irish_" -> AnalysisStopWordLanguage.Irish
            | "_italian_" -> AnalysisStopWordLanguage.Italian
            | "_latvian_" -> AnalysisStopWordLanguage.Latvian
            | "_lithuanian_" -> AnalysisStopWordLanguage.Lithuanian
            | "_norwegian_" -> AnalysisStopWordLanguage.Norwegian
            | "_persian_" -> AnalysisStopWordLanguage.Persian
            | "_portuguese_" -> AnalysisStopWordLanguage.Portuguese
            | "_romanian_" -> AnalysisStopWordLanguage.Romanian
            | "_russian_" -> AnalysisStopWordLanguage.Russian
            | "_serbian_" -> AnalysisStopWordLanguage.Serbian
            | "_sorani_" -> AnalysisStopWordLanguage.Sorani
            | "_spanish_" -> AnalysisStopWordLanguage.Spanish
            | "_swedish_" -> AnalysisStopWordLanguage.Swedish
            | "_thai_" -> AnalysisStopWordLanguage.Thai
            | "_turkish_" -> AnalysisStopWordLanguage.Turkish
            | "_none_" -> AnalysisStopWordLanguage.None
            | s -> failwith $"Unknown AnalysisStopWordLanguage: {s}"

    and [<JsonConverter(typeof<AnalysisStopWordLanguageConverter>)>]
        AnalysisStopWordLanguage =
        | Arabic
        | Armenian
        | Basque
        | Bengali
        | Brazilian
        | Bulgarian
        | Catalan
        | Cjk
        | Czech
        | Danish
        | Dutch
        | English
        | Estonian
        | Finnish
        | French
        | Galician
        | German
        | Greek
        | Hindi
        | Hungarian
        | Indonesian
        | Irish
        | Italian
        | Latvian
        | Lithuanian
        | Norwegian
        | Persian
        | Portuguese
        | Romanian
        | Russian
        | Serbian
        | Sorani
        | Spanish
        | Swedish
        | Thai
        | Turkish
        | None
        with
        override this.ToString() =
            match this with
            | Arabic -> "_arabic_"
            | Armenian -> "_armenian_"
            | Basque -> "_basque_"
            | Bengali -> "_bengali_"
            | Brazilian -> "_brazilian_"
            | Bulgarian -> "_bulgarian_"
            | Catalan -> "_catalan_"
            | Cjk -> "_cjk_"
            | Czech -> "_czech_"
            | Danish -> "_danish_"
            | Dutch -> "_dutch_"
            | English -> "_english_"
            | Estonian -> "_estonian_"
            | Finnish -> "_finnish_"
            | French -> "_french_"
            | Galician -> "_galician_"
            | German -> "_german_"
            | Greek -> "_greek_"
            | Hindi -> "_hindi_"
            | Hungarian -> "_hungarian_"
            | Indonesian -> "_indonesian_"
            | Irish -> "_irish_"
            | Italian -> "_italian_"
            | Latvian -> "_latvian_"
            | Lithuanian -> "_lithuanian_"
            | Norwegian -> "_norwegian_"
            | Persian -> "_persian_"
            | Portuguese -> "_portuguese_"
            | Romanian -> "_romanian_"
            | Russian -> "_russian_"
            | Serbian -> "_serbian_"
            | Sorani -> "_sorani_"
            | Spanish -> "_spanish_"
            | Swedish -> "_swedish_"
            | Thai -> "_thai_"
            | Turkish -> "_turkish_"
            | None -> "_none_"

    /// <summary>
    /// Language value, such as _arabic_ or _thai_. Defaults to _english_.
    /// Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.
    /// Also accepts an array of stop words.
    /// </summary>
    and AnalysisStopWords = obj

    and QueryDslLikeDocument = {
        [<JsonPropertyName("doc")>]
        Doc: obj option
        [<JsonPropertyName("fields")>]
        Fields: Field array option
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("per_field_analyzer")>]
        PerFieldAnalyzer: Map<string, string> option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    /// <summary>
    /// Text that we want similar documents for or a lookup to a document's field for the text.
    /// </summary>
    and QueryDslLike = obj

    and QueryDslMoreLikeThisQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("boost_terms")>]
        BoostTerms: float option
        [<JsonPropertyName("fail_on_unsupported_field")>]
        FailOnUnsupportedField: bool option
        [<JsonPropertyName("fields")>]
        Fields: Field array option
        [<JsonPropertyName("include")>]
        Include: bool option
        [<JsonPropertyName("like")>]
        Like: System.Text.Json.JsonElement
        [<JsonPropertyName("max_doc_freq")>]
        MaxDocFreq: float option
        [<JsonPropertyName("max_query_terms")>]
        MaxQueryTerms: float option
        [<JsonPropertyName("max_word_length")>]
        MaxWordLength: float option
        [<JsonPropertyName("min_doc_freq")>]
        MinDocFreq: float option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("min_term_freq")>]
        MinTermFreq: float option
        [<JsonPropertyName("min_word_length")>]
        MinWordLength: float option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("stop_words")>]
        StopWords: AnalysisStopWords option
        [<JsonPropertyName("unlike")>]
        Unlike: System.Text.Json.JsonElement option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and QueryDslTextQueryTypeConverter() =
        inherit JsonConverter<QueryDslTextQueryType>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslTextQueryType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslTextQueryType.BestFields -> "best_fields"
                | QueryDslTextQueryType.MostFields -> "most_fields"
                | QueryDslTextQueryType.CrossFields -> "cross_fields"
                | QueryDslTextQueryType.Phrase -> "phrase"
                | QueryDslTextQueryType.PhrasePrefix -> "phrase_prefix"
                | QueryDslTextQueryType.BoolPrefix -> "bool_prefix"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "best_fields" -> QueryDslTextQueryType.BestFields
            | "most_fields" -> QueryDslTextQueryType.MostFields
            | "cross_fields" -> QueryDslTextQueryType.CrossFields
            | "phrase" -> QueryDslTextQueryType.Phrase
            | "phrase_prefix" -> QueryDslTextQueryType.PhrasePrefix
            | "bool_prefix" -> QueryDslTextQueryType.BoolPrefix
            | s -> failwith $"Unknown QueryDslTextQueryType: {s}"

    and [<JsonConverter(typeof<QueryDslTextQueryTypeConverter>)>]
        QueryDslTextQueryType =
        | BestFields
        | MostFields
        | CrossFields
        | Phrase
        | PhrasePrefix
        | BoolPrefix
        with
        override this.ToString() =
            match this with
            | BestFields -> "best_fields"
            | MostFields -> "most_fields"
            | CrossFields -> "cross_fields"
            | Phrase -> "phrase"
            | PhrasePrefix -> "phrase_prefix"
            | BoolPrefix -> "bool_prefix"

    and QueryDslMultiMatchQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("auto_generate_synonyms_phrase_query")>]
        AutoGenerateSynonymsPhraseQuery: bool option
        [<JsonPropertyName("cutoff_frequency")>]
        CutoffFrequency: float option
        [<JsonPropertyName("fields")>]
        Fields: Fields option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("fuzzy_rewrite")>]
        FuzzyRewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("fuzzy_transpositions")>]
        FuzzyTranspositions: bool option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("max_expansions")>]
        MaxExpansions: float option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("operator")>]
        Operator: QueryDslOperator option
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("slop")>]
        Slop: float option
        [<JsonPropertyName("tie_breaker")>]
        TieBreaker: float option
        [<JsonPropertyName("type")>]
        Type: QueryDslTextQueryType option
        [<JsonPropertyName("zero_terms_query")>]
        ZeroTermsQuery: QueryDslZeroTermsQuery option
    }

    and QueryDslNestedQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("inner_hits")>]
        InnerHits: SearchTypesInnerHits option
        [<JsonPropertyName("path")>]
        Path: Field
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
        [<JsonPropertyName("score_mode")>]
        ScoreMode: QueryDslChildScoreMode option
    }

    and QueryDslParentIdQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
        [<JsonPropertyName("type")>]
        Type: RelationName option
    }

    and QueryDslPercolateQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("document")>]
        Document: obj option
        [<JsonPropertyName("documents")>]
        Documents: obj array option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("name")>]
        Name2: string option
        [<JsonPropertyName("preference")>]
        Preference: string option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
    }

    and QueryDslPinnedDoc = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName option
    }

    and QueryDslPinnedQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("organic")>]
        Organic: QueryDslQueryContainer
        [<JsonPropertyName("ids")>]
        Ids: Id array option
        [<JsonPropertyName("docs")>]
        Docs: QueryDslPinnedDoc array option
    }

    and QueryDslPrefixQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("rewrite")>]
        Rewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("value")>]
        Value: string
        [<JsonPropertyName("case_insensitive")>]
        CaseInsensitive: bool option
    }

    and TimeZone = string

    and QueryDslQueryStringQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("allow_leading_wildcard")>]
        AllowLeadingWildcard: bool option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("analyze_wildcard")>]
        AnalyzeWildcard: bool option
        [<JsonPropertyName("auto_generate_synonyms_phrase_query")>]
        AutoGenerateSynonymsPhraseQuery: bool option
        [<JsonPropertyName("default_field")>]
        DefaultField: Field option
        [<JsonPropertyName("default_operator")>]
        DefaultOperator: QueryDslOperator option
        [<JsonPropertyName("enable_position_increments")>]
        EnablePositionIncrements: bool option
        [<JsonPropertyName("escape")>]
        Escape: bool option
        [<JsonPropertyName("fields")>]
        Fields: Field array option
        [<JsonPropertyName("fuzziness")>]
        Fuzziness: Fuzziness option
        [<JsonPropertyName("fuzzy_max_expansions")>]
        FuzzyMaxExpansions: float option
        [<JsonPropertyName("fuzzy_prefix_length")>]
        FuzzyPrefixLength: float option
        [<JsonPropertyName("fuzzy_rewrite")>]
        FuzzyRewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("fuzzy_transpositions")>]
        FuzzyTranspositions: bool option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("max_determinized_states")>]
        MaxDeterminizedStates: float option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("phrase_slop")>]
        PhraseSlop: float option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("quote_analyzer")>]
        QuoteAnalyzer: string option
        [<JsonPropertyName("quote_field_suffix")>]
        QuoteFieldSuffix: string option
        [<JsonPropertyName("rewrite")>]
        Rewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("tie_breaker")>]
        TieBreaker: float option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
        [<JsonPropertyName("type")>]
        Type: QueryDslTextQueryType option
    }

    and DateFormat = string

    and QueryDslRangeRelationConverter() =
        inherit JsonConverter<QueryDslRangeRelation>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslRangeRelation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslRangeRelation.Within -> "within"
                | QueryDslRangeRelation.Contains -> "contains"
                | QueryDslRangeRelation.Intersects -> "intersects"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "within" -> QueryDslRangeRelation.Within
            | "contains" -> QueryDslRangeRelation.Contains
            | "intersects" -> QueryDslRangeRelation.Intersects
            | s -> failwith $"Unknown QueryDslRangeRelation: {s}"

    and [<JsonConverter(typeof<QueryDslRangeRelationConverter>)>]
        QueryDslRangeRelation =
        | Within
        | Contains
        | Intersects
        with
        override this.ToString() =
            match this with
            | Within -> "within"
            | Contains -> "contains"
            | Intersects -> "intersects"

    and QueryDslRangeQueryBaseDateMath = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: DateMath option
        [<JsonPropertyName("gte")>]
        Gte: DateMath option
        [<JsonPropertyName("lt")>]
        Lt: DateMath option
        [<JsonPropertyName("lte")>]
        Lte: DateMath option
    }

    and QueryDslDateRangeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: DateMath option
        [<JsonPropertyName("gte")>]
        Gte: DateMath option
        [<JsonPropertyName("lt")>]
        Lt: DateMath option
        [<JsonPropertyName("lte")>]
        Lte: DateMath option
        [<JsonPropertyName("format")>]
        Format: DateFormat option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and QueryDslRangeQueryBasedouble = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: float option
        [<JsonPropertyName("gte")>]
        Gte: float option
        [<JsonPropertyName("lt")>]
        Lt: float option
        [<JsonPropertyName("lte")>]
        Lte: float option
    }

    and QueryDslNumberRangeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: float option
        [<JsonPropertyName("gte")>]
        Gte: float option
        [<JsonPropertyName("lt")>]
        Lt: float option
        [<JsonPropertyName("lte")>]
        Lte: float option
    }

    and QueryDslRangeQueryBasestring = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: string option
        [<JsonPropertyName("gte")>]
        Gte: string option
        [<JsonPropertyName("lt")>]
        Lt: string option
        [<JsonPropertyName("lte")>]
        Lte: string option
    }

    and QueryDslTermRangeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: string option
        [<JsonPropertyName("gte")>]
        Gte: string option
        [<JsonPropertyName("lt")>]
        Lt: string option
        [<JsonPropertyName("lte")>]
        Lte: string option
    }

    and QueryDslRangeQueryBase = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: obj option
        [<JsonPropertyName("gte")>]
        Gte: obj option
        [<JsonPropertyName("lt")>]
        Lt: obj option
        [<JsonPropertyName("lte")>]
        Lte: obj option
    }

    and QueryDslUntypedRangeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("relation")>]
        Relation: QueryDslRangeRelation option
        [<JsonPropertyName("gt")>]
        Gt: obj option
        [<JsonPropertyName("gte")>]
        Gte: obj option
        [<JsonPropertyName("lt")>]
        Lt: obj option
        [<JsonPropertyName("lte")>]
        Lte: obj option
        [<JsonPropertyName("format")>]
        Format: DateFormat option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and QueryDslRangeQuery = obj

    and QueryDslRankFeatureFunction = obj

    and QueryDslRankFeatureFunctionLinear = obj

    and QueryDslRankFeatureFunctionLogarithm = {
        [<JsonPropertyName("scaling_factor")>]
        ScalingFactor: float
    }

    and QueryDslRankFeatureFunctionSaturation = {
        [<JsonPropertyName("pivot")>]
        Pivot: float option
    }

    and QueryDslRankFeatureFunctionSigmoid = {
        [<JsonPropertyName("pivot")>]
        Pivot: float
        [<JsonPropertyName("exponent")>]
        Exponent: float
    }

    and QueryDslRankFeatureQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("saturation")>]
        Saturation: QueryDslRankFeatureFunctionSaturation option
        [<JsonPropertyName("log")>]
        Log: QueryDslRankFeatureFunctionLogarithm option
        [<JsonPropertyName("linear")>]
        Linear: QueryDslRankFeatureFunctionLinear option
        [<JsonPropertyName("sigmoid")>]
        Sigmoid: QueryDslRankFeatureFunctionSigmoid option
    }

    and QueryDslRegexpQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("case_insensitive")>]
        CaseInsensitive: bool option
        [<JsonPropertyName("flags")>]
        Flags: string option
        [<JsonPropertyName("max_determinized_states")>]
        MaxDeterminizedStates: float option
        [<JsonPropertyName("rewrite")>]
        Rewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("value")>]
        Value: string
    }

    and QueryDslRuleQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("organic")>]
        Organic: QueryDslQueryContainer
        [<JsonPropertyName("ruleset_ids")>]
        RulesetIds: System.Text.Json.JsonElement option
        [<JsonPropertyName("ruleset_id")>]
        RulesetId: string option
        [<JsonPropertyName("match_criteria")>]
        MatchCriteria: obj
    }

    and QueryDslScriptQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and QueryDslScriptScoreQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("min_score")>]
        MinScore: float option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and QueryDslSemanticQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("query")>]
        Query: string
    }

    and QueryDslShapeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("ignore_unmapped")>]
        IgnoreUnmapped: bool option
    }

    and QueryDslSimpleQueryStringFlagConverter() =
        inherit JsonConverter<QueryDslSimpleQueryStringFlag>()

        override _.Write(writer: Utf8JsonWriter, value: QueryDslSimpleQueryStringFlag, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QueryDslSimpleQueryStringFlag.NONE -> "NONE"
                | QueryDslSimpleQueryStringFlag.AND -> "AND"
                | QueryDslSimpleQueryStringFlag.NOT -> "NOT"
                | QueryDslSimpleQueryStringFlag.OR -> "OR"
                | QueryDslSimpleQueryStringFlag.PREFIX -> "PREFIX"
                | QueryDslSimpleQueryStringFlag.PHRASE -> "PHRASE"
                | QueryDslSimpleQueryStringFlag.PRECEDENCE -> "PRECEDENCE"
                | QueryDslSimpleQueryStringFlag.ESCAPE -> "ESCAPE"
                | QueryDslSimpleQueryStringFlag.WHITESPACE -> "WHITESPACE"
                | QueryDslSimpleQueryStringFlag.FUZZY -> "FUZZY"
                | QueryDslSimpleQueryStringFlag.NEAR -> "NEAR"
                | QueryDslSimpleQueryStringFlag.SLOP -> "SLOP"
                | QueryDslSimpleQueryStringFlag.ALL -> "ALL"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "NONE" -> QueryDslSimpleQueryStringFlag.NONE
            | "AND" -> QueryDslSimpleQueryStringFlag.AND
            | "NOT" -> QueryDslSimpleQueryStringFlag.NOT
            | "OR" -> QueryDslSimpleQueryStringFlag.OR
            | "PREFIX" -> QueryDslSimpleQueryStringFlag.PREFIX
            | "PHRASE" -> QueryDslSimpleQueryStringFlag.PHRASE
            | "PRECEDENCE" -> QueryDslSimpleQueryStringFlag.PRECEDENCE
            | "ESCAPE" -> QueryDslSimpleQueryStringFlag.ESCAPE
            | "WHITESPACE" -> QueryDslSimpleQueryStringFlag.WHITESPACE
            | "FUZZY" -> QueryDslSimpleQueryStringFlag.FUZZY
            | "NEAR" -> QueryDslSimpleQueryStringFlag.NEAR
            | "SLOP" -> QueryDslSimpleQueryStringFlag.SLOP
            | "ALL" -> QueryDslSimpleQueryStringFlag.ALL
            | s -> failwith $"Unknown QueryDslSimpleQueryStringFlag: {s}"

    and [<JsonConverter(typeof<QueryDslSimpleQueryStringFlagConverter>)>]
        QueryDslSimpleQueryStringFlag =
        | NONE
        | AND
        | NOT
        | OR
        | PREFIX
        | PHRASE
        | PRECEDENCE
        | ESCAPE
        | WHITESPACE
        | FUZZY
        | NEAR
        | SLOP
        | ALL
        with
        override this.ToString() =
            match this with
            | NONE -> "NONE"
            | AND -> "AND"
            | NOT -> "NOT"
            | OR -> "OR"
            | PREFIX -> "PREFIX"
            | PHRASE -> "PHRASE"
            | PRECEDENCE -> "PRECEDENCE"
            | ESCAPE -> "ESCAPE"
            | WHITESPACE -> "WHITESPACE"
            | FUZZY -> "FUZZY"
            | NEAR -> "NEAR"
            | SLOP -> "SLOP"
            | ALL -> "ALL"

    /// <summary>
    /// A set of flags that can be represented as a single enum value or a set of values that are encoded
    /// as a pipe-separated string
    /// </summary>
    and PipeSeparatedFlagsSimpleQueryStringFlag = obj

    /// <summary>
    /// Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`
    /// </summary>
    and QueryDslSimpleQueryStringFlags = obj

    and QueryDslSimpleQueryStringQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("analyze_wildcard")>]
        AnalyzeWildcard: bool option
        [<JsonPropertyName("auto_generate_synonyms_phrase_query")>]
        AutoGenerateSynonymsPhraseQuery: bool option
        [<JsonPropertyName("default_operator")>]
        DefaultOperator: QueryDslOperator option
        [<JsonPropertyName("fields")>]
        Fields: Field array option
        [<JsonPropertyName("flags")>]
        Flags: QueryDslSimpleQueryStringFlags option
        [<JsonPropertyName("fuzzy_max_expansions")>]
        FuzzyMaxExpansions: float option
        [<JsonPropertyName("fuzzy_prefix_length")>]
        FuzzyPrefixLength: float option
        [<JsonPropertyName("fuzzy_transpositions")>]
        FuzzyTranspositions: bool option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("query")>]
        Query: string
        [<JsonPropertyName("quote_field_suffix")>]
        QuoteFieldSuffix: string option
    }

    and QueryDslSpanFieldMaskingQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("query")>]
        Query: QueryDslSpanQuery
    }

    and QueryDslSpanFirstQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("end")>]
        End: float
        [<JsonPropertyName("match")>]
        Match: QueryDslSpanQuery
    }

    /// <summary>
    /// Can only be used as a clause in a span_near query.
    /// </summary>
    and QueryDslSpanGapQuery = Map<string, float>

    and QueryDslSpanMultiTermQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("match")>]
        Match: QueryDslQueryContainer
    }

    and QueryDslSpanNearQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("clauses")>]
        Clauses: QueryDslSpanQuery array
        [<JsonPropertyName("in_order")>]
        InOrder: bool option
        [<JsonPropertyName("slop")>]
        Slop: float option
    }

    and QueryDslSpanNotQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("dist")>]
        Dist: float option
        [<JsonPropertyName("exclude")>]
        Exclude: QueryDslSpanQuery
        [<JsonPropertyName("include")>]
        Include: QueryDslSpanQuery
        [<JsonPropertyName("post")>]
        Post: float option
        [<JsonPropertyName("pre")>]
        Pre: float option
    }

    and QueryDslSpanOrQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("clauses")>]
        Clauses: QueryDslSpanQuery array
    }

    and QueryDslSpanTermQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("value")>]
        Value: FieldValue
    }

    and QueryDslSpanWithinQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("big")>]
        Big: QueryDslSpanQuery
        [<JsonPropertyName("little")>]
        Little: QueryDslSpanQuery
    }

    and QueryDslSpanQuery = {
        [<JsonPropertyName("span_containing")>]
        SpanContaining: QueryDslSpanContainingQuery option
        [<JsonPropertyName("span_field_masking")>]
        SpanFieldMasking: QueryDslSpanFieldMaskingQuery option
        [<JsonPropertyName("span_first")>]
        SpanFirst: QueryDslSpanFirstQuery option
        [<JsonPropertyName("span_gap")>]
        SpanGap: QueryDslSpanGapQuery option
        [<JsonPropertyName("span_multi")>]
        SpanMulti: QueryDslSpanMultiTermQuery option
        [<JsonPropertyName("span_near")>]
        SpanNear: QueryDslSpanNearQuery option
        [<JsonPropertyName("span_not")>]
        SpanNot: QueryDslSpanNotQuery option
        [<JsonPropertyName("span_or")>]
        SpanOr: QueryDslSpanOrQuery option
        [<JsonPropertyName("span_term")>]
        SpanTerm: Map<string, QueryDslSpanTermQuery> option
        [<JsonPropertyName("span_within")>]
        SpanWithin: QueryDslSpanWithinQuery option
    }

    and QueryDslSpanContainingQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("big")>]
        Big: QueryDslSpanQuery
        [<JsonPropertyName("little")>]
        Little: QueryDslSpanQuery
    }

    and TokenPruningConfig = {
        [<JsonPropertyName("tokens_freq_ratio_threshold")>]
        TokensFreqRatioThreshold: float option
        [<JsonPropertyName("tokens_weight_threshold")>]
        TokensWeightThreshold: float option
        [<JsonPropertyName("only_score_pruned_tokens")>]
        OnlyScorePrunedTokens: bool option
    }

    and QueryDslSparseVectorQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("query")>]
        Query: string option
        [<JsonPropertyName("prune")>]
        Prune: bool option
        [<JsonPropertyName("pruning_config")>]
        PruningConfig: TokenPruningConfig option
        [<JsonPropertyName("query_vector")>]
        QueryVector: Map<string, float> option
        [<JsonPropertyName("inference_id")>]
        InferenceId: Id option
    }

    and QueryDslTermQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("value")>]
        Value: FieldValue
        [<JsonPropertyName("case_insensitive")>]
        CaseInsensitive: bool option
    }

    and QueryDslTermsQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
    }

    and QueryDslTermsSetQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("minimum_should_match")>]
        MinimumShouldMatch: MinimumShouldMatch option
        [<JsonPropertyName("minimum_should_match_field")>]
        MinimumShouldMatchField: Field option
        [<JsonPropertyName("minimum_should_match_script")>]
        MinimumShouldMatchScript: Script option
        [<JsonPropertyName("terms")>]
        Terms: FieldValue array
    }

    and QueryDslTextExpansionQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("model_text")>]
        ModelText: string
        [<JsonPropertyName("pruning_config")>]
        PruningConfig: TokenPruningConfig option
    }

    and QueryDslTypeQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("value")>]
        Value: string
    }

    and QueryDslWeightedTokensQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("tokens")>]
        Tokens: System.Text.Json.JsonElement
        [<JsonPropertyName("pruning_config")>]
        PruningConfig: TokenPruningConfig option
    }

    and QueryDslWildcardQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("case_insensitive")>]
        CaseInsensitive: bool option
        [<JsonPropertyName("rewrite")>]
        Rewrite: MultiTermQueryRewrite option
        [<JsonPropertyName("value")>]
        Value: string option
        [<JsonPropertyName("wildcard")>]
        Wildcard: string option
    }

    and QueryDslWrapperQuery = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("_name")>]
        Name: string option
        [<JsonPropertyName("query")>]
        Query: string
    }

    /// <summary>
    /// An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.
    /// </summary>
    and QueryDslQueryContainer = {
        [<JsonPropertyName("bool")>]
        Bool: QueryDslBoolQuery option
        [<JsonPropertyName("boosting")>]
        Boosting: QueryDslBoostingQuery option
        [<JsonPropertyName("common")>]
        Common: Map<string, QueryDslCommonTermsQuery> option
        [<JsonPropertyName("combined_fields")>]
        CombinedFields: QueryDslCombinedFieldsQuery option
        [<JsonPropertyName("constant_score")>]
        ConstantScore: QueryDslConstantScoreQuery option
        [<JsonPropertyName("dis_max")>]
        DisMax: QueryDslDisMaxQuery option
        [<JsonPropertyName("distance_feature")>]
        DistanceFeature: QueryDslDistanceFeatureQuery option
        [<JsonPropertyName("exists")>]
        Exists: QueryDslExistsQuery option
        [<JsonPropertyName("function_score")>]
        FunctionScore: QueryDslFunctionScoreQuery option
        [<JsonPropertyName("fuzzy")>]
        Fuzzy: Map<string, QueryDslFuzzyQuery> option
        [<JsonPropertyName("geo_bounding_box")>]
        GeoBoundingBox: QueryDslGeoBoundingBoxQuery option
        [<JsonPropertyName("geo_distance")>]
        GeoDistance: QueryDslGeoDistanceQuery option
        [<JsonPropertyName("geo_grid")>]
        GeoGrid: Map<string, QueryDslGeoGridQuery> option
        [<JsonPropertyName("geo_polygon")>]
        GeoPolygon: QueryDslGeoPolygonQuery option
        [<JsonPropertyName("geo_shape")>]
        GeoShape: QueryDslGeoShapeQuery option
        [<JsonPropertyName("has_child")>]
        HasChild: QueryDslHasChildQuery option
        [<JsonPropertyName("has_parent")>]
        HasParent: QueryDslHasParentQuery option
        [<JsonPropertyName("ids")>]
        Ids: QueryDslIdsQuery option
        [<JsonPropertyName("intervals")>]
        Intervals: Map<string, QueryDslIntervalsQuery> option
        [<JsonPropertyName("knn")>]
        Knn: KnnQuery option
        [<JsonPropertyName("match")>]
        Match: Map<string, QueryDslMatchQuery> option
        [<JsonPropertyName("match_all")>]
        MatchAll: QueryDslMatchAllQuery option
        [<JsonPropertyName("match_bool_prefix")>]
        MatchBoolPrefix: Map<string, QueryDslMatchBoolPrefixQuery> option
        [<JsonPropertyName("match_none")>]
        MatchNone: QueryDslMatchNoneQuery option
        [<JsonPropertyName("match_phrase")>]
        MatchPhrase: Map<string, QueryDslMatchPhraseQuery> option
        [<JsonPropertyName("match_phrase_prefix")>]
        MatchPhrasePrefix: Map<string, QueryDslMatchPhrasePrefixQuery> option
        [<JsonPropertyName("more_like_this")>]
        MoreLikeThis: QueryDslMoreLikeThisQuery option
        [<JsonPropertyName("multi_match")>]
        MultiMatch: QueryDslMultiMatchQuery option
        [<JsonPropertyName("nested")>]
        Nested: QueryDslNestedQuery option
        [<JsonPropertyName("parent_id")>]
        ParentId: QueryDslParentIdQuery option
        [<JsonPropertyName("percolate")>]
        Percolate: QueryDslPercolateQuery option
        [<JsonPropertyName("pinned")>]
        Pinned: QueryDslPinnedQuery option
        [<JsonPropertyName("prefix")>]
        Prefix: Map<string, QueryDslPrefixQuery> option
        [<JsonPropertyName("query_string")>]
        QueryString: QueryDslQueryStringQuery option
        [<JsonPropertyName("range")>]
        Range: Map<string, QueryDslRangeQuery> option
        [<JsonPropertyName("rank_feature")>]
        RankFeature: QueryDslRankFeatureQuery option
        [<JsonPropertyName("regexp")>]
        Regexp: Map<string, QueryDslRegexpQuery> option
        [<JsonPropertyName("rule")>]
        Rule: QueryDslRuleQuery option
        [<JsonPropertyName("script")>]
        Script: QueryDslScriptQuery option
        [<JsonPropertyName("script_score")>]
        ScriptScore: QueryDslScriptScoreQuery option
        [<JsonPropertyName("semantic")>]
        Semantic: QueryDslSemanticQuery option
        [<JsonPropertyName("shape")>]
        Shape: QueryDslShapeQuery option
        [<JsonPropertyName("simple_query_string")>]
        SimpleQueryString: QueryDslSimpleQueryStringQuery option
        [<JsonPropertyName("span_containing")>]
        SpanContaining: QueryDslSpanContainingQuery option
        [<JsonPropertyName("span_field_masking")>]
        SpanFieldMasking: QueryDslSpanFieldMaskingQuery option
        [<JsonPropertyName("span_first")>]
        SpanFirst: QueryDslSpanFirstQuery option
        [<JsonPropertyName("span_multi")>]
        SpanMulti: QueryDslSpanMultiTermQuery option
        [<JsonPropertyName("span_near")>]
        SpanNear: QueryDslSpanNearQuery option
        [<JsonPropertyName("span_not")>]
        SpanNot: QueryDslSpanNotQuery option
        [<JsonPropertyName("span_or")>]
        SpanOr: QueryDslSpanOrQuery option
        [<JsonPropertyName("span_term")>]
        SpanTerm: Map<string, QueryDslSpanTermQuery> option
        [<JsonPropertyName("span_within")>]
        SpanWithin: QueryDslSpanWithinQuery option
        [<JsonPropertyName("sparse_vector")>]
        SparseVector: QueryDslSparseVectorQuery option
        [<JsonPropertyName("term")>]
        Term: Map<string, QueryDslTermQuery> option
        [<JsonPropertyName("terms")>]
        Terms: QueryDslTermsQuery option
        [<JsonPropertyName("terms_set")>]
        TermsSet: Map<string, QueryDslTermsSetQuery> option
        [<JsonPropertyName("text_expansion")>]
        TextExpansion: Map<string, QueryDslTextExpansionQuery> option
        [<JsonPropertyName("weighted_tokens")>]
        WeightedTokens: Map<string, QueryDslWeightedTokensQuery> option
        [<JsonPropertyName("wildcard")>]
        Wildcard: Map<string, QueryDslWildcardQuery> option
        [<JsonPropertyName("wrapper")>]
        Wrapper: QueryDslWrapperQuery option
        [<JsonPropertyName("type")>]
        Type: QueryDslTypeQuery option
    }

    and AggregationsAdjacencyMatrixAggregation = {
        [<JsonPropertyName("filters")>]
        Filters: Map<string, QueryDslQueryContainer> option
        [<JsonPropertyName("separator")>]
        Separator: string option
    }

    and AggregationsMinimumIntervalConverter() =
        inherit JsonConverter<AggregationsMinimumInterval>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsMinimumInterval, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsMinimumInterval.Second -> "second"
                | AggregationsMinimumInterval.Minute -> "minute"
                | AggregationsMinimumInterval.Hour -> "hour"
                | AggregationsMinimumInterval.Day -> "day"
                | AggregationsMinimumInterval.Month -> "month"
                | AggregationsMinimumInterval.Year -> "year"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "second" -> AggregationsMinimumInterval.Second
            | "minute" -> AggregationsMinimumInterval.Minute
            | "hour" -> AggregationsMinimumInterval.Hour
            | "day" -> AggregationsMinimumInterval.Day
            | "month" -> AggregationsMinimumInterval.Month
            | "year" -> AggregationsMinimumInterval.Year
            | s -> failwith $"Unknown AggregationsMinimumInterval: {s}"

    and [<JsonConverter(typeof<AggregationsMinimumIntervalConverter>)>]
        AggregationsMinimumInterval =
        | Second
        | Minute
        | Hour
        | Day
        | Month
        | Year
        with
        override this.ToString() =
            match this with
            | Second -> "second"
            | Minute -> "minute"
            | Hour -> "hour"
            | Day -> "day"
            | Month -> "month"
            | Year -> "year"

    and AggregationsAutoDateHistogramAggregation = {
        [<JsonPropertyName("buckets")>]
        Buckets: float option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("minimum_interval")>]
        MinimumInterval: AggregationsMinimumInterval option
        [<JsonPropertyName("missing")>]
        Missing: DateTime option
        [<JsonPropertyName("offset")>]
        Offset: string option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and AggregationsMissing = obj

    and AggregationsMetricAggregationBase = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsFormatMetricAggregationBase = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsAverageAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    /// <summary>
    /// Buckets path can be expressed in different ways, and an aggregation may accept some or all of these
    /// forms depending on its type. Please refer to each aggregation's documentation to know what buckets
    /// path forms they accept.
    /// </summary>
    and AggregationsBucketsPath = obj

    and AggregationsBucketPathAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
    }

    and AggregationsGapPolicyConverter() =
        inherit JsonConverter<AggregationsGapPolicy>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsGapPolicy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsGapPolicy.Skip -> "skip"
                | AggregationsGapPolicy.InsertZeros -> "insert_zeros"
                | AggregationsGapPolicy.KeepValues -> "keep_values"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "skip" -> AggregationsGapPolicy.Skip
            | "insert_zeros" -> AggregationsGapPolicy.InsertZeros
            | "keep_values" -> AggregationsGapPolicy.KeepValues
            | s -> failwith $"Unknown AggregationsGapPolicy: {s}"

    and [<JsonConverter(typeof<AggregationsGapPolicyConverter>)>]
        AggregationsGapPolicy =
        | Skip
        | InsertZeros
        | KeepValues
        with
        override this.ToString() =
            match this with
            | Skip -> "skip"
            | InsertZeros -> "insert_zeros"
            | KeepValues -> "keep_values"

    and AggregationsPipelineAggregationBase = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsAverageBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsTDigestExecutionHintConverter() =
        inherit JsonConverter<AggregationsTDigestExecutionHint>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsTDigestExecutionHint, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsTDigestExecutionHint.Default -> "default"
                | AggregationsTDigestExecutionHint.HighAccuracy -> "high_accuracy"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "default" -> AggregationsTDigestExecutionHint.Default
            | "high_accuracy" -> AggregationsTDigestExecutionHint.HighAccuracy
            | s -> failwith $"Unknown AggregationsTDigestExecutionHint: {s}"

    and [<JsonConverter(typeof<AggregationsTDigestExecutionHintConverter>)>]
        AggregationsTDigestExecutionHint =
        | Default
        | HighAccuracy
        with
        override this.ToString() =
            match this with
            | Default -> "default"
            | HighAccuracy -> "high_accuracy"

    and AggregationsBoxplotAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("compression")>]
        Compression: float option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTDigestExecutionHint option
    }

    and AggregationsBucketCorrelationFunctionCountCorrelationIndicator = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("expectations")>]
        Expectations: float array
        [<JsonPropertyName("fractions")>]
        Fractions: float array option
    }

    and AggregationsBucketCorrelationFunctionCountCorrelation = {
        [<JsonPropertyName("indicator")>]
        Indicator: AggregationsBucketCorrelationFunctionCountCorrelationIndicator
    }

    and AggregationsBucketCorrelationFunction = {
        [<JsonPropertyName("count_correlation")>]
        CountCorrelation: AggregationsBucketCorrelationFunctionCountCorrelation
    }

    /// <summary>
    /// A sibling pipeline aggregation which executes a correlation function on the configured sibling multi-bucket aggregation.
    /// </summary>
    and AggregationsBucketCorrelationAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("function")>]
        Function: AggregationsBucketCorrelationFunction
    }

    /// <summary>
    /// A sibling pipeline aggregation which executes a two sample KolmogorovSmirnov test (referred
    /// to as a "K-S test" from now on) against a provided distribution, and the distribution implied
    /// by the documents counts in the configured sibling aggregation. Specifically, for some metric,
    /// </summary>
    and AggregationsBucketKsAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("alternative")>]
        Alternative: string array option
        [<JsonPropertyName("fractions")>]
        Fractions: float array option
        [<JsonPropertyName("sampling_method")>]
        SamplingMethod: string option
    }

    and AggregationsBucketScriptAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsBucketSelectorAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsBucketSortAggregation = {
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
    }

    and AggregationsCardinalityExecutionModeConverter() =
        inherit JsonConverter<AggregationsCardinalityExecutionMode>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsCardinalityExecutionMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsCardinalityExecutionMode.GlobalOrdinals -> "global_ordinals"
                | AggregationsCardinalityExecutionMode.SegmentOrdinals -> "segment_ordinals"
                | AggregationsCardinalityExecutionMode.Direct -> "direct"
                | AggregationsCardinalityExecutionMode.SaveMemoryHeuristic -> "save_memory_heuristic"
                | AggregationsCardinalityExecutionMode.SaveTimeHeuristic -> "save_time_heuristic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "global_ordinals" -> AggregationsCardinalityExecutionMode.GlobalOrdinals
            | "segment_ordinals" -> AggregationsCardinalityExecutionMode.SegmentOrdinals
            | "direct" -> AggregationsCardinalityExecutionMode.Direct
            | "save_memory_heuristic" -> AggregationsCardinalityExecutionMode.SaveMemoryHeuristic
            | "save_time_heuristic" -> AggregationsCardinalityExecutionMode.SaveTimeHeuristic
            | s -> failwith $"Unknown AggregationsCardinalityExecutionMode: {s}"

    and [<JsonConverter(typeof<AggregationsCardinalityExecutionModeConverter>)>]
        AggregationsCardinalityExecutionMode =
        | GlobalOrdinals
        | SegmentOrdinals
        | Direct
        | SaveMemoryHeuristic
        | SaveTimeHeuristic
        with
        override this.ToString() =
            match this with
            | GlobalOrdinals -> "global_ordinals"
            | SegmentOrdinals -> "segment_ordinals"
            | Direct -> "direct"
            | SaveMemoryHeuristic -> "save_memory_heuristic"
            | SaveTimeHeuristic -> "save_time_heuristic"

    and AggregationsCardinalityAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("precision_threshold")>]
        PrecisionThreshold: float option
        [<JsonPropertyName("rehash")>]
        Rehash: bool option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsCardinalityExecutionMode option
    }

    and AggregationsCartesianBoundsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsCartesianCentroidAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsCustomCategorizeTextAnalyzer = {
        [<JsonPropertyName("char_filter")>]
        CharFilter: string array option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: string option
        [<JsonPropertyName("filter")>]
        Filter: string array option
    }

    and AggregationsCategorizeTextAnalyzer = obj

    /// <summary>
    /// A multi-bucket aggregation that groups semi-structured text into buckets. Each text
    /// field is re-analyzed using a custom analyzer. The resulting tokens are then categorized
    /// creating buckets of similarly formatted text values. This aggregation works best with machine
    /// </summary>
    and AggregationsCategorizeTextAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("max_unique_tokens")>]
        MaxUniqueTokens: float option
        [<JsonPropertyName("max_matched_tokens")>]
        MaxMatchedTokens: float option
        [<JsonPropertyName("similarity_threshold")>]
        SimilarityThreshold: float option
        [<JsonPropertyName("categorization_filters")>]
        CategorizationFilters: string array option
        [<JsonPropertyName("categorization_analyzer")>]
        CategorizationAnalyzer: AggregationsCategorizeTextAnalyzer option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
    }

    and AggregationsChangePointAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsChildrenAggregation = {
        [<JsonPropertyName("type")>]
        Type: RelationName option
    }

    and AggregationsMissingOrderConverter() =
        inherit JsonConverter<AggregationsMissingOrder>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsMissingOrder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsMissingOrder.First -> "first"
                | AggregationsMissingOrder.Last -> "last"
                | AggregationsMissingOrder.Default -> "default"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "first" -> AggregationsMissingOrder.First
            | "last" -> AggregationsMissingOrder.Last
            | "default" -> AggregationsMissingOrder.Default
            | s -> failwith $"Unknown AggregationsMissingOrder: {s}"

    and [<JsonConverter(typeof<AggregationsMissingOrderConverter>)>]
        AggregationsMissingOrder =
        | First
        | Last
        | Default
        with
        override this.ToString() =
            match this with
            | First -> "first"
            | Last -> "last"
            | Default -> "default"

    and AggregationsValueTypeConverter() =
        inherit JsonConverter<AggregationsValueType>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsValueType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsValueType.String -> "string"
                | AggregationsValueType.Long -> "long"
                | AggregationsValueType.Double -> "double"
                | AggregationsValueType.Number -> "number"
                | AggregationsValueType.Date -> "date"
                | AggregationsValueType.DateNanos -> "date_nanos"
                | AggregationsValueType.Ip -> "ip"
                | AggregationsValueType.Numeric -> "numeric"
                | AggregationsValueType.GeoPoint -> "geo_point"
                | AggregationsValueType.Boolean -> "boolean"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "string" -> AggregationsValueType.String
            | "long" -> AggregationsValueType.Long
            | "double" -> AggregationsValueType.Double
            | "number" -> AggregationsValueType.Number
            | "date" -> AggregationsValueType.Date
            | "date_nanos" -> AggregationsValueType.DateNanos
            | "ip" -> AggregationsValueType.Ip
            | "numeric" -> AggregationsValueType.Numeric
            | "geo_point" -> AggregationsValueType.GeoPoint
            | "boolean" -> AggregationsValueType.Boolean
            | s -> failwith $"Unknown AggregationsValueType: {s}"

    and [<JsonConverter(typeof<AggregationsValueTypeConverter>)>]
        AggregationsValueType =
        | String
        | Long
        | Double
        | Number
        | Date
        | DateNanos
        | Ip
        | Numeric
        | GeoPoint
        | Boolean
        with
        override this.ToString() =
            match this with
            | String -> "string"
            | Long -> "long"
            | Double -> "double"
            | Number -> "number"
            | Date -> "date"
            | DateNanos -> "date_nanos"
            | Ip -> "ip"
            | Numeric -> "numeric"
            | GeoPoint -> "geo_point"
            | Boolean -> "boolean"

    and AggregationsCompositeAggregationBase = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
    }

    and AggregationsCompositeDateHistogramAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("calendar_interval")>]
        CalendarInterval: DurationLarge option
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: DurationLarge option
        [<JsonPropertyName("offset")>]
        Offset: Duration option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and AggregationsCompositeGeoTileGridAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("precision")>]
        Precision: float option
        [<JsonPropertyName("bounds")>]
        Bounds: GeoBounds option
    }

    and AggregationsCompositeHistogramAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("interval")>]
        Interval: float
    }

    and AggregationsCompositeTermsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("order")>]
        Order: SortOrder option
    }

    and AggregationsCompositeAggregationSource = {
        [<JsonPropertyName("terms")>]
        Terms: AggregationsCompositeTermsAggregation option
        [<JsonPropertyName("histogram")>]
        Histogram: AggregationsCompositeHistogramAggregation option
        [<JsonPropertyName("date_histogram")>]
        DateHistogram: AggregationsCompositeDateHistogramAggregation option
        [<JsonPropertyName("geotile_grid")>]
        GeotileGrid: AggregationsCompositeGeoTileGridAggregation option
    }

    and AggregationsCompositeAggregation = {
        [<JsonPropertyName("after")>]
        After: AggregationsCompositeAggregateKey option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("sources")>]
        Sources: Map<string, AggregationsCompositeAggregationSource> array option
    }

    and AggregationsCumulativeCardinalityAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsCumulativeSumAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsAggregateOrder = obj

    and AggregationsCalendarIntervalConverter() =
        inherit JsonConverter<AggregationsCalendarInterval>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsCalendarInterval, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsCalendarInterval.Second -> "second"
                | AggregationsCalendarInterval.N1s -> "1s"
                | AggregationsCalendarInterval.Minute -> "minute"
                | AggregationsCalendarInterval.N1m -> "1m"
                | AggregationsCalendarInterval.Hour -> "hour"
                | AggregationsCalendarInterval.N1h -> "1h"
                | AggregationsCalendarInterval.Day -> "day"
                | AggregationsCalendarInterval.N1d -> "1d"
                | AggregationsCalendarInterval.Week -> "week"
                | AggregationsCalendarInterval.N1w -> "1w"
                | AggregationsCalendarInterval.Month -> "month"
                | AggregationsCalendarInterval.N1M -> "1M"
                | AggregationsCalendarInterval.Quarter -> "quarter"
                | AggregationsCalendarInterval.N1q -> "1q"
                | AggregationsCalendarInterval.Year -> "year"
                | AggregationsCalendarInterval.N1y -> "1y"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "second" -> AggregationsCalendarInterval.Second
            | "1s" -> AggregationsCalendarInterval.N1s
            | "minute" -> AggregationsCalendarInterval.Minute
            | "1m" -> AggregationsCalendarInterval.N1m
            | "hour" -> AggregationsCalendarInterval.Hour
            | "1h" -> AggregationsCalendarInterval.N1h
            | "day" -> AggregationsCalendarInterval.Day
            | "1d" -> AggregationsCalendarInterval.N1d
            | "week" -> AggregationsCalendarInterval.Week
            | "1w" -> AggregationsCalendarInterval.N1w
            | "month" -> AggregationsCalendarInterval.Month
            | "1M" -> AggregationsCalendarInterval.N1M
            | "quarter" -> AggregationsCalendarInterval.Quarter
            | "1q" -> AggregationsCalendarInterval.N1q
            | "year" -> AggregationsCalendarInterval.Year
            | "1y" -> AggregationsCalendarInterval.N1y
            | s -> failwith $"Unknown AggregationsCalendarInterval: {s}"

    and [<JsonConverter(typeof<AggregationsCalendarIntervalConverter>)>]
        AggregationsCalendarInterval =
        | Second
        | N1s
        | Minute
        | N1m
        | Hour
        | N1h
        | Day
        | N1d
        | Week
        | N1w
        | Month
        | N1M
        | Quarter
        | N1q
        | Year
        | N1y
        with
        override this.ToString() =
            match this with
            | Second -> "second"
            | N1s -> "1s"
            | Minute -> "minute"
            | N1m -> "1m"
            | Hour -> "hour"
            | N1h -> "1h"
            | Day -> "day"
            | N1d -> "1d"
            | Week -> "week"
            | N1w -> "1w"
            | Month -> "month"
            | N1M -> "1M"
            | Quarter -> "quarter"
            | N1q -> "1q"
            | Year -> "year"
            | N1y -> "1y"

    /// <summary>
    /// A date range limit, represented either as a DateMath expression or a number expressed
    /// according to the target field's precision.
    /// </summary>
    and AggregationsFieldDateMath = obj

    and AggregationsExtendedBoundsFieldDateMath = {
        [<JsonPropertyName("max")>]
        Max: AggregationsFieldDateMath option
        [<JsonPropertyName("min")>]
        Min: AggregationsFieldDateMath option
    }

    and AggregationsDateHistogramAggregation = {
        [<JsonPropertyName("calendar_interval")>]
        CalendarInterval: AggregationsCalendarInterval option
        [<JsonPropertyName("extended_bounds")>]
        ExtendedBounds: AggregationsExtendedBoundsFieldDateMath option
        [<JsonPropertyName("hard_bounds")>]
        HardBounds: AggregationsExtendedBoundsFieldDateMath option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: Duration option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("interval")>]
        Interval: Duration option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("missing")>]
        Missing: DateTime option
        [<JsonPropertyName("offset")>]
        Offset: Duration option
        [<JsonPropertyName("order")>]
        Order: AggregationsAggregateOrder option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and AggregationsDateRangeExpression = {
        [<JsonPropertyName("from")>]
        From: AggregationsFieldDateMath option
        [<JsonPropertyName("key")>]
        Key: string option
        [<JsonPropertyName("to")>]
        To: AggregationsFieldDateMath option
    }

    and AggregationsDateRangeAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("ranges")>]
        Ranges: AggregationsDateRangeExpression array option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and AggregationsDerivativeAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsSamplerAggregationExecutionHintConverter() =
        inherit JsonConverter<AggregationsSamplerAggregationExecutionHint>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsSamplerAggregationExecutionHint, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsSamplerAggregationExecutionHint.Map -> "map"
                | AggregationsSamplerAggregationExecutionHint.GlobalOrdinals -> "global_ordinals"
                | AggregationsSamplerAggregationExecutionHint.BytesHash -> "bytes_hash"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "map" -> AggregationsSamplerAggregationExecutionHint.Map
            | "global_ordinals" -> AggregationsSamplerAggregationExecutionHint.GlobalOrdinals
            | "bytes_hash" -> AggregationsSamplerAggregationExecutionHint.BytesHash
            | s -> failwith $"Unknown AggregationsSamplerAggregationExecutionHint: {s}"

    and [<JsonConverter(typeof<AggregationsSamplerAggregationExecutionHintConverter>)>]
        AggregationsSamplerAggregationExecutionHint =
        | Map
        | GlobalOrdinals
        | BytesHash
        with
        override this.ToString() =
            match this with
            | Map -> "map"
            | GlobalOrdinals -> "global_ordinals"
            | BytesHash -> "bytes_hash"

    and AggregationsDiversifiedSamplerAggregation = {
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsSamplerAggregationExecutionHint option
        [<JsonPropertyName("max_docs_per_value")>]
        MaxDocsPerValue: float option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("field")>]
        Field: Field option
    }

    and AggregationsExtendedStatsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("sigma")>]
        Sigma: float option
    }

    and AggregationsExtendedStatsBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("sigma")>]
        Sigma: float option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsQueryContainer = obj

    and AggregationsFiltersAggregation = {
        [<JsonPropertyName("filters")>]
        Filters: AggregationsBucketsQueryContainer option
        [<JsonPropertyName("other_bucket")>]
        OtherBucket: bool option
        [<JsonPropertyName("other_bucket_key")>]
        OtherBucketKey: string option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and AggregationsTermsExclude = obj

    and AggregationsTermsPartition = {
        [<JsonPropertyName("num_partitions")>]
        NumPartitions: float
        [<JsonPropertyName("partition")>]
        Partition: float
    }

    and AggregationsTermsInclude = obj

    and AggregationsFrequentItemSetsField = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("exclude")>]
        Exclude: AggregationsTermsExclude option
        [<JsonPropertyName("include")>]
        Include: AggregationsTermsInclude option
    }

    and AggregationsFrequentItemSetsAggregation = {
        [<JsonPropertyName("fields")>]
        Fields: AggregationsFrequentItemSetsField array
        [<JsonPropertyName("minimum_set_size")>]
        MinimumSetSize: float option
        [<JsonPropertyName("minimum_support")>]
        MinimumSupport: float option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
    }

    and AggregationsGeoBoundsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("wrap_longitude")>]
        WrapLongitude: bool option
    }

    and AggregationsGeoCentroidAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("location")>]
        Location: GeoLocation option
    }

    and AggregationsAggregationRange = {
        [<JsonPropertyName("from")>]
        From: System.Text.Json.JsonElement option
        [<JsonPropertyName("key")>]
        Key: string option
        [<JsonPropertyName("to")>]
        To: System.Text.Json.JsonElement option
    }

    and AggregationsGeoDistanceAggregation = {
        [<JsonPropertyName("distance_type")>]
        DistanceType: GeoDistanceType option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("origin")>]
        Origin: GeoLocation option
        [<JsonPropertyName("ranges")>]
        Ranges: AggregationsAggregationRange array option
        [<JsonPropertyName("unit")>]
        Unit: DistanceUnit option
    }

    /// <summary>
    /// A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like "1km", "10m".
    /// </summary>
    and GeoHashPrecision = obj

    and AggregationsGeoHashGridAggregation = {
        [<JsonPropertyName("bounds")>]
        Bounds: GeoBounds option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("precision")>]
        Precision: GeoHashPrecision option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and AggregationsGeoLinePoint = {
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and AggregationsGeoLineSort = {
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and AggregationsGeoLineAggregation = {
        [<JsonPropertyName("point")>]
        Point: AggregationsGeoLinePoint
        [<JsonPropertyName("sort")>]
        Sort: AggregationsGeoLineSort option
        [<JsonPropertyName("include_sort")>]
        IncludeSort: bool option
        [<JsonPropertyName("sort_order")>]
        SortOrder: SortOrder option
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and GeoTilePrecision = float

    and AggregationsGeoTileGridAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("precision")>]
        Precision: GeoTilePrecision option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("bounds")>]
        Bounds: GeoBounds option
    }

    and AggregationsGeohexGridAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("precision")>]
        Precision: float option
        [<JsonPropertyName("bounds")>]
        Bounds: GeoBounds option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
    }

    and AggregationsGlobalAggregation = obj

    and AggregationsExtendedBoundsdouble = {
        [<JsonPropertyName("max")>]
        Max: float option
        [<JsonPropertyName("min")>]
        Min: float option
    }

    and AggregationsHistogramAggregation = {
        [<JsonPropertyName("extended_bounds")>]
        ExtendedBounds: AggregationsExtendedBoundsdouble option
        [<JsonPropertyName("hard_bounds")>]
        HardBounds: AggregationsExtendedBoundsdouble option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("interval")>]
        Interval: float option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("missing")>]
        Missing: float option
        [<JsonPropertyName("offset")>]
        Offset: float option
        [<JsonPropertyName("order")>]
        Order: AggregationsAggregateOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and TypesClassificationInferenceOptions = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
        [<JsonPropertyName("prediction_field_type")>]
        PredictionFieldType: string option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("top_classes_results_field")>]
        TopClassesResultsField: string option
    }

    and TypesRegressionInferenceOptions = {
        [<JsonPropertyName("results_field")>]
        ResultsField: Field option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
    }

    and AggregationsInferenceConfigContainer = {
        [<JsonPropertyName("regression")>]
        Regression: TypesRegressionInferenceOptions option
        [<JsonPropertyName("classification")>]
        Classification: TypesClassificationInferenceOptions option
    }

    and AggregationsInferenceAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("model_id")>]
        ModelId: Name
        [<JsonPropertyName("inference_config")>]
        InferenceConfig: AggregationsInferenceConfigContainer option
    }

    and AggregationsIpPrefixAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("prefix_length")>]
        PrefixLength: float
        [<JsonPropertyName("is_ipv6")>]
        IsIpv6: bool option
        [<JsonPropertyName("append_prefix_length")>]
        AppendPrefixLength: bool option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
    }

    and AggregationsIpRangeAggregationRange = {
        [<JsonPropertyName("from")>]
        From: System.Text.Json.JsonElement option
        [<JsonPropertyName("mask")>]
        Mask: string option
        [<JsonPropertyName("to")>]
        To: System.Text.Json.JsonElement option
    }

    and AggregationsIpRangeAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("ranges")>]
        Ranges: AggregationsIpRangeAggregationRange array option
    }

    and AggregationsMatrixAggregation = {
        [<JsonPropertyName("fields")>]
        Fields: Fields option
        [<JsonPropertyName("missing")>]
        Missing: Map<string, float> option
    }

    and AggregationsMatrixStatsAggregation = {
        [<JsonPropertyName("fields")>]
        Fields: Fields option
        [<JsonPropertyName("missing")>]
        Missing: Map<string, float> option
        [<JsonPropertyName("mode")>]
        Mode: SortMode option
    }

    and AggregationsMaxAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsMaxBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsMedianAbsoluteDeviationAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("compression")>]
        Compression: float option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTDigestExecutionHint option
    }

    and AggregationsMinAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsMinBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsMissingAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
    }

    and AggregationsEwmaModelSettings = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
    }

    and AggregationsMovingAverageAggregationBase = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
    }

    and AggregationsEwmaMovingAverageAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("settings")>]
        Settings: AggregationsEwmaModelSettings
    }

    and AggregationsHoltLinearModelSettings = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("beta")>]
        Beta: float option
    }

    and AggregationsHoltMovingAverageAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("settings")>]
        Settings: AggregationsHoltLinearModelSettings
    }

    and AggregationsHoltWintersTypeConverter() =
        inherit JsonConverter<AggregationsHoltWintersType>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsHoltWintersType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsHoltWintersType.Add -> "add"
                | AggregationsHoltWintersType.Mult -> "mult"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "add" -> AggregationsHoltWintersType.Add
            | "mult" -> AggregationsHoltWintersType.Mult
            | s -> failwith $"Unknown AggregationsHoltWintersType: {s}"

    and [<JsonConverter(typeof<AggregationsHoltWintersTypeConverter>)>]
        AggregationsHoltWintersType =
        | Add
        | Mult
        with
        override this.ToString() =
            match this with
            | Add -> "add"
            | Mult -> "mult"

    and AggregationsHoltWintersModelSettings = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("beta")>]
        Beta: float option
        [<JsonPropertyName("gamma")>]
        Gamma: float option
        [<JsonPropertyName("pad")>]
        Pad: bool option
        [<JsonPropertyName("period")>]
        Period: float option
        [<JsonPropertyName("type")>]
        Type: AggregationsHoltWintersType option
    }

    and AggregationsHoltWintersMovingAverageAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("settings")>]
        Settings: AggregationsHoltWintersModelSettings
    }

    /// <summary>
    /// For empty Class assignments
    /// </summary>
    and EmptyObject = obj

    and AggregationsLinearMovingAverageAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("settings")>]
        Settings: EmptyObject
    }

    and AggregationsSimpleMovingAverageAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("minimize")>]
        Minimize: bool option
        [<JsonPropertyName("predict")>]
        Predict: float option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("settings")>]
        Settings: EmptyObject
    }

    and AggregationsMovingAverageAggregationConverter() =
        inherit JsonConverter<AggregationsMovingAverageAggregation>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsMovingAverageAggregation, options: JsonSerializerOptions) =
            match value with
            | AggregationsMovingAverageAggregation.Ewma v -> JsonSerializer.Serialize(writer, v, options)
            | AggregationsMovingAverageAggregation.Holt v -> JsonSerializer.Serialize(writer, v, options)
            | AggregationsMovingAverageAggregation.HoltWinters v -> JsonSerializer.Serialize(writer, v, options)
            | AggregationsMovingAverageAggregation.Linear v -> JsonSerializer.Serialize(writer, v, options)
            | AggregationsMovingAverageAggregation.Simple v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("model") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "ewma" -> AggregationsMovingAverageAggregation.Ewma (JsonSerializer.Deserialize<AggregationsEwmaMovingAverageAggregation>(json, options))
            | "holt" -> AggregationsMovingAverageAggregation.Holt (JsonSerializer.Deserialize<AggregationsHoltMovingAverageAggregation>(json, options))
            | "holt_winters" -> AggregationsMovingAverageAggregation.HoltWinters (JsonSerializer.Deserialize<AggregationsHoltWintersMovingAverageAggregation>(json, options))
            | "linear" -> AggregationsMovingAverageAggregation.Linear (JsonSerializer.Deserialize<AggregationsLinearMovingAverageAggregation>(json, options))
            | "simple" -> AggregationsMovingAverageAggregation.Simple (JsonSerializer.Deserialize<AggregationsSimpleMovingAverageAggregation>(json, options))
            | s -> failwith $"Unknown AggregationsMovingAverageAggregation type: {s}"

    and [<JsonConverter(typeof<AggregationsMovingAverageAggregationConverter>)>]
        AggregationsMovingAverageAggregation =
        | Ewma of AggregationsEwmaMovingAverageAggregation
        | Holt of AggregationsHoltMovingAverageAggregation
        | HoltWinters of AggregationsHoltWintersMovingAverageAggregation
        | Linear of AggregationsLinearMovingAverageAggregation
        | Simple of AggregationsSimpleMovingAverageAggregation

    and AggregationsMovingAverageAggregationTypeConverter() =
        inherit JsonConverter<AggregationsMovingAverageAggregationType>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsMovingAverageAggregationType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsMovingAverageAggregationType.Ewma -> "ewma"
                | AggregationsMovingAverageAggregationType.Holt -> "holt"
                | AggregationsMovingAverageAggregationType.HoltWinters -> "holt_winters"
                | AggregationsMovingAverageAggregationType.Linear -> "linear"
                | AggregationsMovingAverageAggregationType.Simple -> "simple"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ewma" -> AggregationsMovingAverageAggregationType.Ewma
            | "holt" -> AggregationsMovingAverageAggregationType.Holt
            | "holt_winters" -> AggregationsMovingAverageAggregationType.HoltWinters
            | "linear" -> AggregationsMovingAverageAggregationType.Linear
            | "simple" -> AggregationsMovingAverageAggregationType.Simple
            | s -> failwith $"Unknown AggregationsMovingAverageAggregationType: {s}"

    and [<JsonConverter(typeof<AggregationsMovingAverageAggregationTypeConverter>)>]
        AggregationsMovingAverageAggregationType =
        | Ewma
        | Holt
        | HoltWinters
        | Linear
        | Simple
        with
        override this.ToString() =
            match this with
            | Ewma -> "ewma"
            | Holt -> "holt"
            | HoltWinters -> "holt_winters"
            | Linear -> "linear"
            | Simple -> "simple"

    and AggregationsMovingFunctionAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("script")>]
        Script: string option
        [<JsonPropertyName("shift")>]
        Shift: float option
        [<JsonPropertyName("window")>]
        Window: float option
    }

    and AggregationsMovingPercentilesAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("window")>]
        Window: float option
        [<JsonPropertyName("shift")>]
        Shift: float option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and AggregationsMultiTermLookup = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
    }

    and AggregationsTermsAggregationCollectModeConverter() =
        inherit JsonConverter<AggregationsTermsAggregationCollectMode>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsTermsAggregationCollectMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsTermsAggregationCollectMode.DepthFirst -> "depth_first"
                | AggregationsTermsAggregationCollectMode.BreadthFirst -> "breadth_first"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "depth_first" -> AggregationsTermsAggregationCollectMode.DepthFirst
            | "breadth_first" -> AggregationsTermsAggregationCollectMode.BreadthFirst
            | s -> failwith $"Unknown AggregationsTermsAggregationCollectMode: {s}"

    and [<JsonConverter(typeof<AggregationsTermsAggregationCollectModeConverter>)>]
        AggregationsTermsAggregationCollectMode =
        | DepthFirst
        | BreadthFirst
        with
        override this.ToString() =
            match this with
            | DepthFirst -> "depth_first"
            | BreadthFirst -> "breadth_first"

    and AggregationsMultiTermsAggregation = {
        [<JsonPropertyName("collect_mode")>]
        CollectMode: AggregationsTermsAggregationCollectMode option
        [<JsonPropertyName("order")>]
        Order: AggregationsAggregateOrder option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("show_term_doc_count_error")>]
        ShowTermDocCountError: bool option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("terms")>]
        Terms: AggregationsMultiTermLookup array
    }

    and AggregationsNestedAggregation = {
        [<JsonPropertyName("path")>]
        Path: Field option
    }

    and AggregationsNormalizeMethodConverter() =
        inherit JsonConverter<AggregationsNormalizeMethod>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsNormalizeMethod, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsNormalizeMethod.Rescale01 -> "rescale_0_1"
                | AggregationsNormalizeMethod.Rescale0100 -> "rescale_0_100"
                | AggregationsNormalizeMethod.PercentOfSum -> "percent_of_sum"
                | AggregationsNormalizeMethod.Mean -> "mean"
                | AggregationsNormalizeMethod.ZScore -> "z_score"
                | AggregationsNormalizeMethod.Softmax -> "softmax"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rescale_0_1" -> AggregationsNormalizeMethod.Rescale01
            | "rescale_0_100" -> AggregationsNormalizeMethod.Rescale0100
            | "percent_of_sum" -> AggregationsNormalizeMethod.PercentOfSum
            | "mean" -> AggregationsNormalizeMethod.Mean
            | "z_score" -> AggregationsNormalizeMethod.ZScore
            | "softmax" -> AggregationsNormalizeMethod.Softmax
            | s -> failwith $"Unknown AggregationsNormalizeMethod: {s}"

    and [<JsonConverter(typeof<AggregationsNormalizeMethodConverter>)>]
        AggregationsNormalizeMethod =
        | Rescale01
        | Rescale0100
        | PercentOfSum
        | Mean
        | ZScore
        | Softmax
        with
        override this.ToString() =
            match this with
            | Rescale01 -> "rescale_0_1"
            | Rescale0100 -> "rescale_0_100"
            | PercentOfSum -> "percent_of_sum"
            | Mean -> "mean"
            | ZScore -> "z_score"
            | Softmax -> "softmax"

    and AggregationsNormalizeAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("method")>]
        Method: AggregationsNormalizeMethod option
    }

    and AggregationsParentAggregation = {
        [<JsonPropertyName("type")>]
        Type: RelationName option
    }

    and AggregationsHdrMethod = {
        [<JsonPropertyName("number_of_significant_value_digits")>]
        NumberOfSignificantValueDigits: float option
    }

    and AggregationsTDigest = {
        [<JsonPropertyName("compression")>]
        Compression: float option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTDigestExecutionHint option
    }

    and AggregationsPercentileRanksAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
        [<JsonPropertyName("values")>]
        Values: System.Text.Json.JsonElement option
        [<JsonPropertyName("hdr")>]
        Hdr: AggregationsHdrMethod option
        [<JsonPropertyName("tdigest")>]
        Tdigest: AggregationsTDigest option
    }

    and AggregationsPercentilesAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
        [<JsonPropertyName("percents")>]
        Percents: System.Text.Json.JsonElement option
        [<JsonPropertyName("hdr")>]
        Hdr: AggregationsHdrMethod option
        [<JsonPropertyName("tdigest")>]
        Tdigest: AggregationsTDigest option
    }

    and AggregationsPercentilesBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("percents")>]
        Percents: float array option
    }

    and AggregationsRandomSamplerAggregation = {
        [<JsonPropertyName("probability")>]
        Probability: float
        [<JsonPropertyName("seed")>]
        Seed: float option
        [<JsonPropertyName("shard_seed")>]
        ShardSeed: float option
    }

    and AggregationsRangeAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: float option
        [<JsonPropertyName("ranges")>]
        Ranges: AggregationsAggregationRange array option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsRareTermsAggregation = {
        [<JsonPropertyName("exclude")>]
        Exclude: AggregationsTermsExclude option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("include")>]
        Include: AggregationsTermsInclude option
        [<JsonPropertyName("max_doc_count")>]
        MaxDocCount: float option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("precision")>]
        Precision: float option
        [<JsonPropertyName("value_type")>]
        ValueType: string option
    }

    and AggregationsRateModeConverter() =
        inherit JsonConverter<AggregationsRateMode>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsRateMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsRateMode.Sum -> "sum"
                | AggregationsRateMode.ValueCount -> "value_count"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sum" -> AggregationsRateMode.Sum
            | "value_count" -> AggregationsRateMode.ValueCount
            | s -> failwith $"Unknown AggregationsRateMode: {s}"

    and [<JsonConverter(typeof<AggregationsRateModeConverter>)>]
        AggregationsRateMode =
        | Sum
        | ValueCount
        with
        override this.ToString() =
            match this with
            | Sum -> "sum"
            | ValueCount -> "value_count"

    and AggregationsRateAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("unit")>]
        Unit: AggregationsCalendarInterval option
        [<JsonPropertyName("mode")>]
        Mode: AggregationsRateMode option
    }

    and AggregationsReverseNestedAggregation = {
        [<JsonPropertyName("path")>]
        Path: Field option
    }

    and AggregationsSamplerAggregation = {
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
    }

    and AggregationsScriptedMetricAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("combine_script")>]
        CombineScript: Script option
        [<JsonPropertyName("init_script")>]
        InitScript: Script option
        [<JsonPropertyName("map_script")>]
        MapScript: Script option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("reduce_script")>]
        ReduceScript: Script option
    }

    and AggregationsSerialDifferencingAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
        [<JsonPropertyName("lag")>]
        Lag: float option
    }

    and AggregationsChiSquareHeuristic = {
        [<JsonPropertyName("background_is_superset")>]
        BackgroundIsSuperset: bool
        [<JsonPropertyName("include_negatives")>]
        IncludeNegatives: bool
    }

    and AggregationsGoogleNormalizedDistanceHeuristic = {
        [<JsonPropertyName("background_is_superset")>]
        BackgroundIsSuperset: bool option
    }

    and AggregationsMutualInformationHeuristic = {
        [<JsonPropertyName("background_is_superset")>]
        BackgroundIsSuperset: bool option
        [<JsonPropertyName("include_negatives")>]
        IncludeNegatives: bool option
    }

    and AggregationsPValueHeuristic = {
        [<JsonPropertyName("background_is_superset")>]
        BackgroundIsSuperset: bool option
        [<JsonPropertyName("normalize_above")>]
        NormalizeAbove: float option
    }

    and AggregationsPercentageScoreHeuristic = obj

    and AggregationsScriptedHeuristic = {
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and AggregationsTermsAggregationExecutionHintConverter() =
        inherit JsonConverter<AggregationsTermsAggregationExecutionHint>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsTermsAggregationExecutionHint, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsTermsAggregationExecutionHint.Map -> "map"
                | AggregationsTermsAggregationExecutionHint.GlobalOrdinals -> "global_ordinals"
                | AggregationsTermsAggregationExecutionHint.GlobalOrdinalsHash -> "global_ordinals_hash"
                | AggregationsTermsAggregationExecutionHint.GlobalOrdinalsLowCardinality -> "global_ordinals_low_cardinality"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "map" -> AggregationsTermsAggregationExecutionHint.Map
            | "global_ordinals" -> AggregationsTermsAggregationExecutionHint.GlobalOrdinals
            | "global_ordinals_hash" -> AggregationsTermsAggregationExecutionHint.GlobalOrdinalsHash
            | "global_ordinals_low_cardinality" -> AggregationsTermsAggregationExecutionHint.GlobalOrdinalsLowCardinality
            | s -> failwith $"Unknown AggregationsTermsAggregationExecutionHint: {s}"

    and [<JsonConverter(typeof<AggregationsTermsAggregationExecutionHintConverter>)>]
        AggregationsTermsAggregationExecutionHint =
        | Map
        | GlobalOrdinals
        | GlobalOrdinalsHash
        | GlobalOrdinalsLowCardinality
        with
        override this.ToString() =
            match this with
            | Map -> "map"
            | GlobalOrdinals -> "global_ordinals"
            | GlobalOrdinalsHash -> "global_ordinals_hash"
            | GlobalOrdinalsLowCardinality -> "global_ordinals_low_cardinality"

    and AggregationsSignificantTermsAggregation = {
        [<JsonPropertyName("background_filter")>]
        BackgroundFilter: QueryDslQueryContainer option
        [<JsonPropertyName("chi_square")>]
        ChiSquare: AggregationsChiSquareHeuristic option
        [<JsonPropertyName("exclude")>]
        Exclude: AggregationsTermsExclude option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTermsAggregationExecutionHint option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("gnd")>]
        Gnd: AggregationsGoogleNormalizedDistanceHeuristic option
        [<JsonPropertyName("include")>]
        Include: AggregationsTermsInclude option
        [<JsonPropertyName("jlh")>]
        Jlh: EmptyObject option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("mutual_information")>]
        MutualInformation: AggregationsMutualInformationHeuristic option
        [<JsonPropertyName("percentage")>]
        Percentage: AggregationsPercentageScoreHeuristic option
        [<JsonPropertyName("script_heuristic")>]
        ScriptHeuristic: AggregationsScriptedHeuristic option
        [<JsonPropertyName("p_value")>]
        PValue: AggregationsPValueHeuristic option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and AggregationsSignificantTextAggregation = {
        [<JsonPropertyName("background_filter")>]
        BackgroundFilter: QueryDslQueryContainer option
        [<JsonPropertyName("chi_square")>]
        ChiSquare: AggregationsChiSquareHeuristic option
        [<JsonPropertyName("exclude")>]
        Exclude: AggregationsTermsExclude option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTermsAggregationExecutionHint option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("filter_duplicate_text")>]
        FilterDuplicateText: bool option
        [<JsonPropertyName("gnd")>]
        Gnd: AggregationsGoogleNormalizedDistanceHeuristic option
        [<JsonPropertyName("include")>]
        Include: AggregationsTermsInclude option
        [<JsonPropertyName("jlh")>]
        Jlh: EmptyObject option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("mutual_information")>]
        MutualInformation: AggregationsMutualInformationHeuristic option
        [<JsonPropertyName("percentage")>]
        Percentage: AggregationsPercentageScoreHeuristic option
        [<JsonPropertyName("script_heuristic")>]
        ScriptHeuristic: AggregationsScriptedHeuristic option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("source_fields")>]
        SourceFields: Fields option
    }

    and AggregationsStatsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsStatsBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsStringStatsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("show_distribution")>]
        ShowDistribution: bool option
    }

    and AggregationsSumAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsSumBucketAggregation = {
        [<JsonPropertyName("buckets_path")>]
        BucketsPath: AggregationsBucketsPath option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("gap_policy")>]
        GapPolicy: AggregationsGapPolicy option
    }

    and AggregationsTTestTypeConverter() =
        inherit JsonConverter<AggregationsTTestType>()

        override _.Write(writer: Utf8JsonWriter, value: AggregationsTTestType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AggregationsTTestType.Paired -> "paired"
                | AggregationsTTestType.Homoscedastic -> "homoscedastic"
                | AggregationsTTestType.Heteroscedastic -> "heteroscedastic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "paired" -> AggregationsTTestType.Paired
            | "homoscedastic" -> AggregationsTTestType.Homoscedastic
            | "heteroscedastic" -> AggregationsTTestType.Heteroscedastic
            | s -> failwith $"Unknown AggregationsTTestType: {s}"

    and [<JsonConverter(typeof<AggregationsTTestTypeConverter>)>]
        AggregationsTTestType =
        | Paired
        | Homoscedastic
        | Heteroscedastic
        with
        override this.ToString() =
            match this with
            | Paired -> "paired"
            | Homoscedastic -> "homoscedastic"
            | Heteroscedastic -> "heteroscedastic"

    and AggregationsTestPopulation = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
    }

    and AggregationsTTestAggregation = {
        [<JsonPropertyName("a")>]
        A: AggregationsTestPopulation option
        [<JsonPropertyName("b")>]
        B: AggregationsTestPopulation option
        [<JsonPropertyName("type")>]
        Type: AggregationsTTestType option
    }

    and AggregationsTermsAggregation = {
        [<JsonPropertyName("collect_mode")>]
        CollectMode: AggregationsTermsAggregationCollectMode option
        [<JsonPropertyName("exclude")>]
        Exclude: AggregationsTermsExclude option
        [<JsonPropertyName("execution_hint")>]
        ExecutionHint: AggregationsTermsAggregationExecutionHint option
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("include")>]
        Include: AggregationsTermsInclude option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("missing_order")>]
        MissingOrder: AggregationsMissingOrder option
        [<JsonPropertyName("missing_bucket")>]
        MissingBucket: bool option
        [<JsonPropertyName("value_type")>]
        ValueType: string option
        [<JsonPropertyName("order")>]
        Order: AggregationsAggregateOrder option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("show_term_doc_count_error")>]
        ShowTermDocCountError: bool option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsTimeSeriesAggregation = {
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and AggregationsTopHitsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("docvalue_fields")>]
        DocvalueFields: QueryDslFieldAndFormat array option
        [<JsonPropertyName("explain")>]
        Explain: bool option
        [<JsonPropertyName("fields")>]
        Fields: QueryDslFieldAndFormat array option
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("highlight")>]
        Highlight: SearchTypesHighlight option
        [<JsonPropertyName("script_fields")>]
        ScriptFields: Map<string, ScriptField> option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("stored_fields")>]
        StoredFields: Fields option
        [<JsonPropertyName("track_scores")>]
        TrackScores: bool option
        [<JsonPropertyName("version")>]
        Version: bool option
        [<JsonPropertyName("seq_no_primary_term")>]
        SeqNoPrimaryTerm: bool option
    }

    and AggregationsTopMetricsValue = {
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and AggregationsTopMetricsAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("metrics")>]
        Metrics: System.Text.Json.JsonElement option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
    }

    and AggregationsFormattableMetricAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsValueCountAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissing option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("format")>]
        Format: string option
    }

    and AggregationsVariableWidthHistogramAggregation = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("buckets")>]
        Buckets: float option
        [<JsonPropertyName("shard_size")>]
        ShardSize: float option
        [<JsonPropertyName("initial_buffer")>]
        InitialBuffer: float option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsWeightedAverageValue = {
        [<JsonPropertyName("field")>]
        Field: Field option
        [<JsonPropertyName("missing")>]
        Missing: float option
        [<JsonPropertyName("script")>]
        Script: Script option
    }

    and AggregationsWeightedAverageAggregation = {
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("value")>]
        Value: AggregationsWeightedAverageValue option
        [<JsonPropertyName("value_type")>]
        ValueType: AggregationsValueType option
        [<JsonPropertyName("weight")>]
        Weight: AggregationsWeightedAverageValue option
    }

    and AggregationsAggregationContainer = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregationContainer> option
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("adjacency_matrix")>]
        AdjacencyMatrix: AggregationsAdjacencyMatrixAggregation option
        [<JsonPropertyName("auto_date_histogram")>]
        AutoDateHistogram: AggregationsAutoDateHistogramAggregation option
        [<JsonPropertyName("avg")>]
        Avg: AggregationsAverageAggregation option
        [<JsonPropertyName("avg_bucket")>]
        AvgBucket: AggregationsAverageBucketAggregation option
        [<JsonPropertyName("boxplot")>]
        Boxplot: AggregationsBoxplotAggregation option
        [<JsonPropertyName("bucket_script")>]
        BucketScript: AggregationsBucketScriptAggregation option
        [<JsonPropertyName("bucket_selector")>]
        BucketSelector: AggregationsBucketSelectorAggregation option
        [<JsonPropertyName("bucket_sort")>]
        BucketSort: AggregationsBucketSortAggregation option
        [<JsonPropertyName("bucket_count_ks_test")>]
        BucketCountKsTest: AggregationsBucketKsAggregation option
        [<JsonPropertyName("bucket_correlation")>]
        BucketCorrelation: AggregationsBucketCorrelationAggregation option
        [<JsonPropertyName("cardinality")>]
        Cardinality: AggregationsCardinalityAggregation option
        [<JsonPropertyName("cartesian_bounds")>]
        CartesianBounds: AggregationsCartesianBoundsAggregation option
        [<JsonPropertyName("cartesian_centroid")>]
        CartesianCentroid: AggregationsCartesianCentroidAggregation option
        [<JsonPropertyName("categorize_text")>]
        CategorizeText: AggregationsCategorizeTextAggregation option
        [<JsonPropertyName("change_point")>]
        ChangePoint: AggregationsChangePointAggregation option
        [<JsonPropertyName("children")>]
        Children: AggregationsChildrenAggregation option
        [<JsonPropertyName("composite")>]
        Composite: AggregationsCompositeAggregation option
        [<JsonPropertyName("cumulative_cardinality")>]
        CumulativeCardinality: AggregationsCumulativeCardinalityAggregation option
        [<JsonPropertyName("cumulative_sum")>]
        CumulativeSum: AggregationsCumulativeSumAggregation option
        [<JsonPropertyName("date_histogram")>]
        DateHistogram: AggregationsDateHistogramAggregation option
        [<JsonPropertyName("date_range")>]
        DateRange: AggregationsDateRangeAggregation option
        [<JsonPropertyName("derivative")>]
        Derivative: AggregationsDerivativeAggregation option
        [<JsonPropertyName("diversified_sampler")>]
        DiversifiedSampler: AggregationsDiversifiedSamplerAggregation option
        [<JsonPropertyName("extended_stats")>]
        ExtendedStats: AggregationsExtendedStatsAggregation option
        [<JsonPropertyName("extended_stats_bucket")>]
        ExtendedStatsBucket: AggregationsExtendedStatsBucketAggregation option
        [<JsonPropertyName("frequent_item_sets")>]
        FrequentItemSets: AggregationsFrequentItemSetsAggregation option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("filters")>]
        Filters: AggregationsFiltersAggregation option
        [<JsonPropertyName("geo_bounds")>]
        GeoBounds: AggregationsGeoBoundsAggregation option
        [<JsonPropertyName("geo_centroid")>]
        GeoCentroid: AggregationsGeoCentroidAggregation option
        [<JsonPropertyName("geo_distance")>]
        GeoDistance: AggregationsGeoDistanceAggregation option
        [<JsonPropertyName("geohash_grid")>]
        GeohashGrid: AggregationsGeoHashGridAggregation option
        [<JsonPropertyName("geo_line")>]
        GeoLine: AggregationsGeoLineAggregation option
        [<JsonPropertyName("geotile_grid")>]
        GeotileGrid: AggregationsGeoTileGridAggregation option
        [<JsonPropertyName("geohex_grid")>]
        GeohexGrid: AggregationsGeohexGridAggregation option
        [<JsonPropertyName("global")>]
        Global: AggregationsGlobalAggregation option
        [<JsonPropertyName("histogram")>]
        Histogram: AggregationsHistogramAggregation option
        [<JsonPropertyName("ip_range")>]
        IpRange: AggregationsIpRangeAggregation option
        [<JsonPropertyName("ip_prefix")>]
        IpPrefix: AggregationsIpPrefixAggregation option
        [<JsonPropertyName("inference")>]
        Inference: AggregationsInferenceAggregation option
        [<JsonPropertyName("line")>]
        Line: AggregationsGeoLineAggregation option
        [<JsonPropertyName("matrix_stats")>]
        MatrixStats: AggregationsMatrixStatsAggregation option
        [<JsonPropertyName("max")>]
        Max: AggregationsMaxAggregation option
        [<JsonPropertyName("max_bucket")>]
        MaxBucket: AggregationsMaxBucketAggregation option
        [<JsonPropertyName("median_absolute_deviation")>]
        MedianAbsoluteDeviation: AggregationsMedianAbsoluteDeviationAggregation option
        [<JsonPropertyName("min")>]
        Min: AggregationsMinAggregation option
        [<JsonPropertyName("min_bucket")>]
        MinBucket: AggregationsMinBucketAggregation option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissingAggregation option
        [<JsonPropertyName("moving_avg")>]
        MovingAvg: AggregationsMovingAverageAggregation option
        [<JsonPropertyName("moving_percentiles")>]
        MovingPercentiles: AggregationsMovingPercentilesAggregation option
        [<JsonPropertyName("moving_fn")>]
        MovingFn: AggregationsMovingFunctionAggregation option
        [<JsonPropertyName("multi_terms")>]
        MultiTerms: AggregationsMultiTermsAggregation option
        [<JsonPropertyName("nested")>]
        Nested: AggregationsNestedAggregation option
        [<JsonPropertyName("normalize")>]
        Normalize: AggregationsNormalizeAggregation option
        [<JsonPropertyName("parent")>]
        Parent: AggregationsParentAggregation option
        [<JsonPropertyName("percentile_ranks")>]
        PercentileRanks: AggregationsPercentileRanksAggregation option
        [<JsonPropertyName("percentiles")>]
        Percentiles: AggregationsPercentilesAggregation option
        [<JsonPropertyName("percentiles_bucket")>]
        PercentilesBucket: AggregationsPercentilesBucketAggregation option
        [<JsonPropertyName("range")>]
        Range: AggregationsRangeAggregation option
        [<JsonPropertyName("rare_terms")>]
        RareTerms: AggregationsRareTermsAggregation option
        [<JsonPropertyName("rate")>]
        Rate: AggregationsRateAggregation option
        [<JsonPropertyName("reverse_nested")>]
        ReverseNested: AggregationsReverseNestedAggregation option
        [<JsonPropertyName("random_sampler")>]
        RandomSampler: AggregationsRandomSamplerAggregation option
        [<JsonPropertyName("sampler")>]
        Sampler: AggregationsSamplerAggregation option
        [<JsonPropertyName("scripted_metric")>]
        ScriptedMetric: AggregationsScriptedMetricAggregation option
        [<JsonPropertyName("serial_diff")>]
        SerialDiff: AggregationsSerialDifferencingAggregation option
        [<JsonPropertyName("significant_terms")>]
        SignificantTerms: AggregationsSignificantTermsAggregation option
        [<JsonPropertyName("significant_text")>]
        SignificantText: AggregationsSignificantTextAggregation option
        [<JsonPropertyName("stats")>]
        Stats: AggregationsStatsAggregation option
        [<JsonPropertyName("stats_bucket")>]
        StatsBucket: AggregationsStatsBucketAggregation option
        [<JsonPropertyName("string_stats")>]
        StringStats: AggregationsStringStatsAggregation option
        [<JsonPropertyName("sum")>]
        Sum: AggregationsSumAggregation option
        [<JsonPropertyName("sum_bucket")>]
        SumBucket: AggregationsSumBucketAggregation option
        [<JsonPropertyName("terms")>]
        Terms: AggregationsTermsAggregation option
        [<JsonPropertyName("time_series")>]
        TimeSeries: AggregationsTimeSeriesAggregation option
        [<JsonPropertyName("top_hits")>]
        TopHits: AggregationsTopHitsAggregation option
        [<JsonPropertyName("t_test")>]
        TTest: AggregationsTTestAggregation option
        [<JsonPropertyName("top_metrics")>]
        TopMetrics: AggregationsTopMetricsAggregation option
        [<JsonPropertyName("value_count")>]
        ValueCount: AggregationsValueCountAggregation option
        [<JsonPropertyName("weighted_avg")>]
        WeightedAvg: AggregationsWeightedAverageAggregation option
        [<JsonPropertyName("variable_width_histogram")>]
        VariableWidthHistogram: AggregationsVariableWidthHistogramAggregation option
    }

    and RefreshConverter() =
        inherit JsonConverter<Refresh>()

        override _.Write(writer: Utf8JsonWriter, value: Refresh, _options: JsonSerializerOptions) =
            let str =
                match value with
                | Refresh.True -> "true"
                | Refresh.False -> "false"
                | Refresh.WaitFor -> "wait_for"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "true" -> Refresh.True
            | "false" -> Refresh.False
            | "wait_for" -> Refresh.WaitFor
            | s -> failwith $"Unknown Refresh: {s}"

    and [<JsonConverter(typeof<RefreshConverter>)>]
        Refresh =
        | True
        | False
        | WaitFor
        with
        override this.ToString() =
            match this with
            | True -> "true"
            | False -> "false"
            | WaitFor -> "wait_for"

    and WaitForActiveShardOptionsConverter() =
        inherit JsonConverter<WaitForActiveShardOptions>()

        override _.Write(writer: Utf8JsonWriter, value: WaitForActiveShardOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | WaitForActiveShardOptions.All -> "all"
                | WaitForActiveShardOptions.IndexSetting -> "index_setting"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> WaitForActiveShardOptions.All
            | "index_setting" -> WaitForActiveShardOptions.IndexSetting
            | s -> failwith $"Unknown WaitForActiveShardOptions: {s}"

    and [<JsonConverter(typeof<WaitForActiveShardOptionsConverter>)>]
        WaitForActiveShardOptions =
        | All
        | IndexSetting
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | IndexSetting -> "index_setting"

    and WaitForActiveShards = obj

    and BulkOperationBase = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and BulkWriteOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
        [<JsonPropertyName("dynamic_templates")>]
        DynamicTemplates: Map<string, string> option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
        [<JsonPropertyName("require_alias")>]
        RequireAlias: bool option
    }

    and BulkCreateOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
        [<JsonPropertyName("dynamic_templates")>]
        DynamicTemplates: Map<string, string> option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
        [<JsonPropertyName("require_alias")>]
        RequireAlias: bool option
    }

    and BulkDeleteOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and BulkIndexOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
        [<JsonPropertyName("dynamic_templates")>]
        DynamicTemplates: Map<string, string> option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
        [<JsonPropertyName("require_alias")>]
        RequireAlias: bool option
    }

    and BulkUpdateOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("if_primary_term")>]
        IfPrimaryTerm: float option
        [<JsonPropertyName("if_seq_no")>]
        IfSeqNo: SequenceNumber option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
        [<JsonPropertyName("require_alias")>]
        RequireAlias: bool option
        [<JsonPropertyName("retry_on_conflict")>]
        RetryOnConflict: float option
    }

    and BulkOperationContainer = {
        [<JsonPropertyName("index")>]
        Index: BulkIndexOperation option
        [<JsonPropertyName("create")>]
        Create: BulkCreateOperation option
        [<JsonPropertyName("update")>]
        Update: BulkUpdateOperation option
        [<JsonPropertyName("delete")>]
        Delete: BulkDeleteOperation option
    }

    and BulkUpdateAction = {
        [<JsonPropertyName("detect_noop")>]
        DetectNoop: bool option
        [<JsonPropertyName("doc")>]
        Doc: obj option
        [<JsonPropertyName("doc_as_upsert")>]
        DocAsUpsert: bool option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("scripted_upsert")>]
        ScriptedUpsert: bool option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("upsert")>]
        Upsert: obj option
    }

    and BulkFailureStoreStatusConverter() =
        inherit JsonConverter<BulkFailureStoreStatus>()

        override _.Write(writer: Utf8JsonWriter, value: BulkFailureStoreStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | BulkFailureStoreStatus.NotApplicableOrUnknown -> "not_applicable_or_unknown"
                | BulkFailureStoreStatus.Used -> "used"
                | BulkFailureStoreStatus.NotEnabled -> "not_enabled"
                | BulkFailureStoreStatus.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "not_applicable_or_unknown" -> BulkFailureStoreStatus.NotApplicableOrUnknown
            | "used" -> BulkFailureStoreStatus.Used
            | "not_enabled" -> BulkFailureStoreStatus.NotEnabled
            | "failed" -> BulkFailureStoreStatus.Failed
            | s -> failwith $"Unknown BulkFailureStoreStatus: {s}"

    and [<JsonConverter(typeof<BulkFailureStoreStatusConverter>)>]
        BulkFailureStoreStatus =
        | NotApplicableOrUnknown
        | Used
        | NotEnabled
        | Failed
        with
        override this.ToString() =
            match this with
            | NotApplicableOrUnknown -> "not_applicable_or_unknown"
            | Used -> "used"
            | NotEnabled -> "not_enabled"
            | Failed -> "failed"

    and InlineGetDictUserDefined = {
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("found")>]
        Found: bool
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("_routing")>]
        Routing: Routing option
        [<JsonPropertyName("_source")>]
        Source: Map<string, obj> option
    }

    and BulkResponseItem = {
        [<JsonPropertyName("_id")>]
        Id: System.Text.Json.JsonElement option
        [<JsonPropertyName("_index")>]
        Index: string
        [<JsonPropertyName("status")>]
        Status: float
        [<JsonPropertyName("failure_store")>]
        FailureStore: BulkFailureStoreStatus option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("result")>]
        Result: string option
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics option
        [<JsonPropertyName("_version")>]
        Version: VersionNumber option
        [<JsonPropertyName("forced_refresh")>]
        ForcedRefresh: bool option
        [<JsonPropertyName("get")>]
        Get: InlineGetDictUserDefined option
    }

    and Names = obj

    and TypesCatAliasesColumn = obj

    and TypesCatAliasesColumns = obj

    and AliasesAliasesRecord = {
        [<JsonPropertyName("alias")>]
        Alias: string option
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("filter")>]
        Filter: string option
        [<JsonPropertyName("routing.index")>]
        RoutingIndex: string option
        [<JsonPropertyName("routing.search")>]
        RoutingSearch: string option
        [<JsonPropertyName("is_write_index")>]
        IsWriteIndex: string option
    }

    and NodeIds = obj

    and TypesCatAllocationColumn = obj

    and TypesCatAllocationColumns = obj

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and Stringifieddouble = obj

    and ByteSize = obj

    and Host = string

    and Ip = string

    and Percentage = obj

    and AllocationAllocationRecord = {
        [<JsonPropertyName("shards")>]
        Shards: string option
        [<JsonPropertyName("shards.undesired")>]
        ShardsUndesired: System.Text.Json.JsonElement option
        [<JsonPropertyName("write_load.forecast")>]
        WriteLoadForecast: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.indices.forecast")>]
        DiskIndicesForecast: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.indices")>]
        DiskIndices: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.used")>]
        DiskUsed: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.avail")>]
        DiskAvail: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.total")>]
        DiskTotal: System.Text.Json.JsonElement option
        [<JsonPropertyName("disk.percent")>]
        DiskPercent: System.Text.Json.JsonElement option
        [<JsonPropertyName("host")>]
        Host: System.Text.Json.JsonElement option
        [<JsonPropertyName("ip")>]
        Ip: System.Text.Json.JsonElement option
        [<JsonPropertyName("node")>]
        Node: string option
        [<JsonPropertyName("node.role")>]
        NodeRole: System.Text.Json.JsonElement option
    }

    and TypesCatCircuitBreakerColumn = obj

    and TypesCatCircuitBreakerColumns = obj

    and CircuitBreakerCircuitBreakerRecord = {
        [<JsonPropertyName("node_id")>]
        NodeId: NodeId option
        [<JsonPropertyName("node_name")>]
        NodeName: string option
        [<JsonPropertyName("breaker")>]
        Breaker: string option
        [<JsonPropertyName("limit")>]
        Limit: string option
        [<JsonPropertyName("limit_bytes")>]
        LimitBytes: ByteSize option
        [<JsonPropertyName("estimated")>]
        Estimated: string option
        [<JsonPropertyName("estimated_bytes")>]
        EstimatedBytes: ByteSize option
        [<JsonPropertyName("tripped")>]
        Tripped: string option
        [<JsonPropertyName("overhead")>]
        Overhead: string option
    }

    and TypesCatComponentColumn = obj

    and TypesCatComponentColumns = obj

    and ComponentTemplatesComponentTemplate = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("version")>]
        Version: System.Text.Json.JsonElement
        [<JsonPropertyName("alias_count")>]
        AliasCount: string
        [<JsonPropertyName("mapping_count")>]
        MappingCount: string
        [<JsonPropertyName("settings_count")>]
        SettingsCount: string
        [<JsonPropertyName("metadata_count")>]
        MetadataCount: string
        [<JsonPropertyName("included_in")>]
        IncludedIn: string
    }

    and TypesCatCountColumn = obj

    and TypesCatCountColumns = obj

    /// <summary>
    /// Time unit for seconds
    /// </summary>
    and UnitSeconds = float

    and EpochTimeUnitSeconds = obj

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and StringifiedEpochTimeUnitSeconds = obj

    /// <summary>
    /// Time of day, expressed as HH:MM:SS
    /// </summary>
    and TimeOfDay = string

    and CountCountRecord = {
        [<JsonPropertyName("epoch")>]
        Epoch: StringifiedEpochTimeUnitSeconds option
        [<JsonPropertyName("timestamp")>]
        Timestamp: TimeOfDay option
        [<JsonPropertyName("count")>]
        Count: string option
    }

    and TypesCatFieldDataColumn = obj

    and TypesCatFieldDataColumns = obj

    and FielddataFielddataRecord = {
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("host")>]
        Host: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("node")>]
        Node: string option
        [<JsonPropertyName("field")>]
        Field: string option
        [<JsonPropertyName("size")>]
        Size: string option
    }

    and TypesCatHealthColumn = obj

    and TypesCatHealthColumns = obj

    and HealthHealthRecord = {
        [<JsonPropertyName("epoch")>]
        Epoch: StringifiedEpochTimeUnitSeconds option
        [<JsonPropertyName("timestamp")>]
        Timestamp: TimeOfDay option
        [<JsonPropertyName("cluster")>]
        Cluster: string option
        [<JsonPropertyName("status")>]
        Status: string option
        [<JsonPropertyName("node.total")>]
        NodeTotal: string option
        [<JsonPropertyName("node.data")>]
        NodeData: string option
        [<JsonPropertyName("shards")>]
        Shards: string option
        [<JsonPropertyName("pri")>]
        Pri: string option
        [<JsonPropertyName("relo")>]
        Relo: string option
        [<JsonPropertyName("init")>]
        Init: string option
        [<JsonPropertyName("unassign.pri")>]
        UnassignPri: string option
        [<JsonPropertyName("unassign")>]
        Unassign: string option
        [<JsonPropertyName("pending_tasks")>]
        PendingTasks: string option
        [<JsonPropertyName("max_task_wait_time")>]
        MaxTaskWaitTime: string option
        [<JsonPropertyName("active_shards_percent")>]
        ActiveShardsPercent: string option
    }

    and HealthStatusConverter() =
        inherit JsonConverter<HealthStatus>()

        override _.Write(writer: Utf8JsonWriter, value: HealthStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | HealthStatus.Green -> "green"
                | HealthStatus.GREEN -> "GREEN"
                | HealthStatus.Yellow -> "yellow"
                | HealthStatus.YELLOW -> "YELLOW"
                | HealthStatus.Red -> "red"
                | HealthStatus.RED -> "RED"
                | HealthStatus.Unknown -> "unknown"
                | HealthStatus.Unavailable -> "unavailable"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "green" -> HealthStatus.Green
            | "GREEN" -> HealthStatus.GREEN
            | "yellow" -> HealthStatus.Yellow
            | "YELLOW" -> HealthStatus.YELLOW
            | "red" -> HealthStatus.Red
            | "RED" -> HealthStatus.RED
            | "unknown" -> HealthStatus.Unknown
            | "unavailable" -> HealthStatus.Unavailable
            | s -> failwith $"Unknown HealthStatus: {s}"

    and [<JsonConverter(typeof<HealthStatusConverter>)>]
        HealthStatus =
        | Green
        | GREEN
        | Yellow
        | YELLOW
        | Red
        | RED
        | Unknown
        | Unavailable
        with
        override this.ToString() =
            match this with
            | Green -> "green"
            | GREEN -> "GREEN"
            | Yellow -> "yellow"
            | YELLOW -> "YELLOW"
            | Red -> "red"
            | RED -> "RED"
            | Unknown -> "unknown"
            | Unavailable -> "unavailable"

    and TypesCatIndicesColumn = obj

    and TypesCatIndicesColumns = obj

    and IndicesIndicesRecord = {
        [<JsonPropertyName("health")>]
        Health: string option
        [<JsonPropertyName("status")>]
        Status: string option
        [<JsonPropertyName("index")>]
        Index: string option
        [<JsonPropertyName("uuid")>]
        Uuid: string option
        [<JsonPropertyName("pri")>]
        Pri: string option
        [<JsonPropertyName("rep")>]
        Rep: string option
        [<JsonPropertyName("docs.count")>]
        DocsCount: System.Text.Json.JsonElement option
        [<JsonPropertyName("docs.deleted")>]
        DocsDeleted: System.Text.Json.JsonElement option
        [<JsonPropertyName("creation.date")>]
        CreationDate: string option
        [<JsonPropertyName("creation.date.string")>]
        CreationDateString: string option
        [<JsonPropertyName("store.size")>]
        StoreSize: System.Text.Json.JsonElement option
        [<JsonPropertyName("pri.store.size")>]
        PriStoreSize: System.Text.Json.JsonElement option
        [<JsonPropertyName("dataset.size")>]
        DatasetSize: System.Text.Json.JsonElement option
        [<JsonPropertyName("completion.size")>]
        CompletionSize: string option
        [<JsonPropertyName("pri.completion.size")>]
        PriCompletionSize: string option
        [<JsonPropertyName("fielddata.memory_size")>]
        FielddataMemorySize: string option
        [<JsonPropertyName("pri.fielddata.memory_size")>]
        PriFielddataMemorySize: string option
        [<JsonPropertyName("fielddata.evictions")>]
        FielddataEvictions: string option
        [<JsonPropertyName("pri.fielddata.evictions")>]
        PriFielddataEvictions: string option
        [<JsonPropertyName("query_cache.memory_size")>]
        QueryCacheMemorySize: string option
        [<JsonPropertyName("pri.query_cache.memory_size")>]
        PriQueryCacheMemorySize: string option
        [<JsonPropertyName("query_cache.evictions")>]
        QueryCacheEvictions: string option
        [<JsonPropertyName("pri.query_cache.evictions")>]
        PriQueryCacheEvictions: string option
        [<JsonPropertyName("request_cache.memory_size")>]
        RequestCacheMemorySize: string option
        [<JsonPropertyName("pri.request_cache.memory_size")>]
        PriRequestCacheMemorySize: string option
        [<JsonPropertyName("request_cache.evictions")>]
        RequestCacheEvictions: string option
        [<JsonPropertyName("pri.request_cache.evictions")>]
        PriRequestCacheEvictions: string option
        [<JsonPropertyName("request_cache.hit_count")>]
        RequestCacheHitCount: string option
        [<JsonPropertyName("pri.request_cache.hit_count")>]
        PriRequestCacheHitCount: string option
        [<JsonPropertyName("request_cache.miss_count")>]
        RequestCacheMissCount: string option
        [<JsonPropertyName("pri.request_cache.miss_count")>]
        PriRequestCacheMissCount: string option
        [<JsonPropertyName("flush.total")>]
        FlushTotal: string option
        [<JsonPropertyName("pri.flush.total")>]
        PriFlushTotal: string option
        [<JsonPropertyName("flush.total_time")>]
        FlushTotalTime: string option
        [<JsonPropertyName("pri.flush.total_time")>]
        PriFlushTotalTime: string option
        [<JsonPropertyName("get.current")>]
        GetCurrent: string option
        [<JsonPropertyName("pri.get.current")>]
        PriGetCurrent: string option
        [<JsonPropertyName("get.time")>]
        GetTime: string option
        [<JsonPropertyName("pri.get.time")>]
        PriGetTime: string option
        [<JsonPropertyName("get.total")>]
        GetTotal: string option
        [<JsonPropertyName("pri.get.total")>]
        PriGetTotal: string option
        [<JsonPropertyName("get.exists_time")>]
        GetExistsTime: string option
        [<JsonPropertyName("pri.get.exists_time")>]
        PriGetExistsTime: string option
        [<JsonPropertyName("get.exists_total")>]
        GetExistsTotal: string option
        [<JsonPropertyName("pri.get.exists_total")>]
        PriGetExistsTotal: string option
        [<JsonPropertyName("get.missing_time")>]
        GetMissingTime: string option
        [<JsonPropertyName("pri.get.missing_time")>]
        PriGetMissingTime: string option
        [<JsonPropertyName("get.missing_total")>]
        GetMissingTotal: string option
        [<JsonPropertyName("pri.get.missing_total")>]
        PriGetMissingTotal: string option
        [<JsonPropertyName("indexing.delete_current")>]
        IndexingDeleteCurrent: string option
        [<JsonPropertyName("pri.indexing.delete_current")>]
        PriIndexingDeleteCurrent: string option
        [<JsonPropertyName("indexing.delete_time")>]
        IndexingDeleteTime: string option
        [<JsonPropertyName("pri.indexing.delete_time")>]
        PriIndexingDeleteTime: string option
        [<JsonPropertyName("indexing.delete_total")>]
        IndexingDeleteTotal: string option
        [<JsonPropertyName("pri.indexing.delete_total")>]
        PriIndexingDeleteTotal: string option
        [<JsonPropertyName("indexing.index_current")>]
        IndexingIndexCurrent: string option
        [<JsonPropertyName("pri.indexing.index_current")>]
        PriIndexingIndexCurrent: string option
        [<JsonPropertyName("indexing.index_time")>]
        IndexingIndexTime: string option
        [<JsonPropertyName("pri.indexing.index_time")>]
        PriIndexingIndexTime: string option
        [<JsonPropertyName("indexing.index_total")>]
        IndexingIndexTotal: string option
        [<JsonPropertyName("pri.indexing.index_total")>]
        PriIndexingIndexTotal: string option
        [<JsonPropertyName("indexing.index_failed")>]
        IndexingIndexFailed: string option
        [<JsonPropertyName("pri.indexing.index_failed")>]
        PriIndexingIndexFailed: string option
        [<JsonPropertyName("merges.current")>]
        MergesCurrent: string option
        [<JsonPropertyName("pri.merges.current")>]
        PriMergesCurrent: string option
        [<JsonPropertyName("merges.current_docs")>]
        MergesCurrentDocs: string option
        [<JsonPropertyName("pri.merges.current_docs")>]
        PriMergesCurrentDocs: string option
        [<JsonPropertyName("merges.current_size")>]
        MergesCurrentSize: string option
        [<JsonPropertyName("pri.merges.current_size")>]
        PriMergesCurrentSize: string option
        [<JsonPropertyName("merges.total")>]
        MergesTotal: string option
        [<JsonPropertyName("pri.merges.total")>]
        PriMergesTotal: string option
        [<JsonPropertyName("merges.total_docs")>]
        MergesTotalDocs: string option
        [<JsonPropertyName("pri.merges.total_docs")>]
        PriMergesTotalDocs: string option
        [<JsonPropertyName("merges.total_size")>]
        MergesTotalSize: string option
        [<JsonPropertyName("pri.merges.total_size")>]
        PriMergesTotalSize: string option
        [<JsonPropertyName("merges.total_time")>]
        MergesTotalTime: string option
        [<JsonPropertyName("pri.merges.total_time")>]
        PriMergesTotalTime: string option
        [<JsonPropertyName("refresh.total")>]
        RefreshTotal: string option
        [<JsonPropertyName("pri.refresh.total")>]
        PriRefreshTotal: string option
        [<JsonPropertyName("refresh.time")>]
        RefreshTime: string option
        [<JsonPropertyName("pri.refresh.time")>]
        PriRefreshTime: string option
        [<JsonPropertyName("refresh.external_total")>]
        RefreshExternalTotal: string option
        [<JsonPropertyName("pri.refresh.external_total")>]
        PriRefreshExternalTotal: string option
        [<JsonPropertyName("refresh.external_time")>]
        RefreshExternalTime: string option
        [<JsonPropertyName("pri.refresh.external_time")>]
        PriRefreshExternalTime: string option
        [<JsonPropertyName("refresh.listeners")>]
        RefreshListeners: string option
        [<JsonPropertyName("pri.refresh.listeners")>]
        PriRefreshListeners: string option
        [<JsonPropertyName("search.fetch_current")>]
        SearchFetchCurrent: string option
        [<JsonPropertyName("pri.search.fetch_current")>]
        PriSearchFetchCurrent: string option
        [<JsonPropertyName("search.fetch_time")>]
        SearchFetchTime: string option
        [<JsonPropertyName("pri.search.fetch_time")>]
        PriSearchFetchTime: string option
        [<JsonPropertyName("search.fetch_total")>]
        SearchFetchTotal: string option
        [<JsonPropertyName("pri.search.fetch_total")>]
        PriSearchFetchTotal: string option
        [<JsonPropertyName("search.open_contexts")>]
        SearchOpenContexts: string option
        [<JsonPropertyName("pri.search.open_contexts")>]
        PriSearchOpenContexts: string option
        [<JsonPropertyName("search.query_current")>]
        SearchQueryCurrent: string option
        [<JsonPropertyName("pri.search.query_current")>]
        PriSearchQueryCurrent: string option
        [<JsonPropertyName("search.query_time")>]
        SearchQueryTime: string option
        [<JsonPropertyName("pri.search.query_time")>]
        PriSearchQueryTime: string option
        [<JsonPropertyName("search.query_total")>]
        SearchQueryTotal: string option
        [<JsonPropertyName("pri.search.query_total")>]
        PriSearchQueryTotal: string option
        [<JsonPropertyName("search.scroll_current")>]
        SearchScrollCurrent: string option
        [<JsonPropertyName("pri.search.scroll_current")>]
        PriSearchScrollCurrent: string option
        [<JsonPropertyName("search.scroll_time")>]
        SearchScrollTime: string option
        [<JsonPropertyName("pri.search.scroll_time")>]
        PriSearchScrollTime: string option
        [<JsonPropertyName("search.scroll_total")>]
        SearchScrollTotal: string option
        [<JsonPropertyName("pri.search.scroll_total")>]
        PriSearchScrollTotal: string option
        [<JsonPropertyName("segments.count")>]
        SegmentsCount: string option
        [<JsonPropertyName("pri.segments.count")>]
        PriSegmentsCount: string option
        [<JsonPropertyName("segments.memory")>]
        SegmentsMemory: string option
        [<JsonPropertyName("pri.segments.memory")>]
        PriSegmentsMemory: string option
        [<JsonPropertyName("segments.index_writer_memory")>]
        SegmentsIndexWriterMemory: string option
        [<JsonPropertyName("pri.segments.index_writer_memory")>]
        PriSegmentsIndexWriterMemory: string option
        [<JsonPropertyName("segments.version_map_memory")>]
        SegmentsVersionMapMemory: string option
        [<JsonPropertyName("pri.segments.version_map_memory")>]
        PriSegmentsVersionMapMemory: string option
        [<JsonPropertyName("segments.fixed_bitset_memory")>]
        SegmentsFixedBitsetMemory: string option
        [<JsonPropertyName("pri.segments.fixed_bitset_memory")>]
        PriSegmentsFixedBitsetMemory: string option
        [<JsonPropertyName("warmer.current")>]
        WarmerCurrent: string option
        [<JsonPropertyName("pri.warmer.current")>]
        PriWarmerCurrent: string option
        [<JsonPropertyName("warmer.total")>]
        WarmerTotal: string option
        [<JsonPropertyName("pri.warmer.total")>]
        PriWarmerTotal: string option
        [<JsonPropertyName("warmer.total_time")>]
        WarmerTotalTime: string option
        [<JsonPropertyName("pri.warmer.total_time")>]
        PriWarmerTotalTime: string option
        [<JsonPropertyName("suggest.current")>]
        SuggestCurrent: string option
        [<JsonPropertyName("pri.suggest.current")>]
        PriSuggestCurrent: string option
        [<JsonPropertyName("suggest.time")>]
        SuggestTime: string option
        [<JsonPropertyName("pri.suggest.time")>]
        PriSuggestTime: string option
        [<JsonPropertyName("suggest.total")>]
        SuggestTotal: string option
        [<JsonPropertyName("pri.suggest.total")>]
        PriSuggestTotal: string option
        [<JsonPropertyName("memory.total")>]
        MemoryTotal: string option
        [<JsonPropertyName("pri.memory.total")>]
        PriMemoryTotal: string option
        [<JsonPropertyName("search.throttled")>]
        SearchThrottled: string option
        [<JsonPropertyName("bulk.total_operations")>]
        BulkTotalOperations: string option
        [<JsonPropertyName("pri.bulk.total_operations")>]
        PriBulkTotalOperations: string option
        [<JsonPropertyName("bulk.total_time")>]
        BulkTotalTime: string option
        [<JsonPropertyName("pri.bulk.total_time")>]
        PriBulkTotalTime: string option
        [<JsonPropertyName("bulk.total_size_in_bytes")>]
        BulkTotalSizeInBytes: string option
        [<JsonPropertyName("pri.bulk.total_size_in_bytes")>]
        PriBulkTotalSizeInBytes: string option
        [<JsonPropertyName("bulk.avg_time")>]
        BulkAvgTime: string option
        [<JsonPropertyName("pri.bulk.avg_time")>]
        PriBulkAvgTime: string option
        [<JsonPropertyName("bulk.avg_size_in_bytes")>]
        BulkAvgSizeInBytes: string option
        [<JsonPropertyName("pri.bulk.avg_size_in_bytes")>]
        PriBulkAvgSizeInBytes: string option
    }

    and TypesCatMasterColumn = obj

    and TypesCatMasterColumns = obj

    and MasterMasterRecord = {
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("host")>]
        Host: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("node")>]
        Node: string option
    }

    and TypesCatDfaColumn = string

    and TypesCatDfaColumns = obj

    and VersionString = string

    and MlDataFrameAnalyticsDataFrameAnalyticsRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("create_time")>]
        CreateTime: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("source_index")>]
        SourceIndex: IndexName option
        [<JsonPropertyName("dest_index")>]
        DestIndex: IndexName option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: string option
        [<JsonPropertyName("state")>]
        State: string option
        [<JsonPropertyName("failure_reason")>]
        FailureReason: string option
        [<JsonPropertyName("progress")>]
        Progress: string option
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("node.id")>]
        NodeId: Id option
        [<JsonPropertyName("node.name")>]
        NodeName: Name option
        [<JsonPropertyName("node.ephemeral_id")>]
        NodeEphemeralId: Id option
        [<JsonPropertyName("node.address")>]
        NodeAddress: string option
    }

    and TypesCatDatafeedColumn = string

    and TypesCatDatafeedColumns = obj

    and TypesDatafeedStateConverter() =
        inherit JsonConverter<TypesDatafeedState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDatafeedState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDatafeedState.Started -> "started"
                | TypesDatafeedState.Stopped -> "stopped"
                | TypesDatafeedState.Starting -> "starting"
                | TypesDatafeedState.Stopping -> "stopping"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "started" -> TypesDatafeedState.Started
            | "stopped" -> TypesDatafeedState.Stopped
            | "starting" -> TypesDatafeedState.Starting
            | "stopping" -> TypesDatafeedState.Stopping
            | s -> failwith $"Unknown TypesDatafeedState: {s}"

    and [<JsonConverter(typeof<TypesDatafeedStateConverter>)>]
        TypesDatafeedState =
        | Started
        | Stopped
        | Starting
        | Stopping
        with
        override this.ToString() =
            match this with
            | Started -> "started"
            | Stopped -> "stopped"
            | Starting -> "starting"
            | Stopping -> "stopping"

    and MlDatafeedsDatafeedsRecord = {
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("state")>]
        State: TypesDatafeedState option
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("buckets.count")>]
        BucketsCount: string option
        [<JsonPropertyName("search.count")>]
        SearchCount: string option
        [<JsonPropertyName("search.time")>]
        SearchTime: string option
        [<JsonPropertyName("search.bucket_avg")>]
        SearchBucketAvg: string option
        [<JsonPropertyName("search.exp_avg_hour")>]
        SearchExpAvgHour: string option
        [<JsonPropertyName("node.id")>]
        NodeId: string option
        [<JsonPropertyName("node.name")>]
        NodeName: string option
        [<JsonPropertyName("node.ephemeral_id")>]
        NodeEphemeralId: string option
        [<JsonPropertyName("node.address")>]
        NodeAddress: string option
    }

    and TypesCatAnomalyDetectorColumn = string

    and TypesCatAnomalyDetectorColumns = obj

    and TypesCategorizationStatusConverter() =
        inherit JsonConverter<TypesCategorizationStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCategorizationStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCategorizationStatus.Ok -> "ok"
                | TypesCategorizationStatus.Warn -> "warn"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ok" -> TypesCategorizationStatus.Ok
            | "warn" -> TypesCategorizationStatus.Warn
            | s -> failwith $"Unknown TypesCategorizationStatus: {s}"

    and [<JsonConverter(typeof<TypesCategorizationStatusConverter>)>]
        TypesCategorizationStatus =
        | Ok
        | Warn
        with
        override this.ToString() =
            match this with
            | Ok -> "ok"
            | Warn -> "warn"

    and TypesJobStateConverter() =
        inherit JsonConverter<TypesJobState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJobState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJobState.Closing -> "closing"
                | TypesJobState.Closed -> "closed"
                | TypesJobState.Opened -> "opened"
                | TypesJobState.Failed -> "failed"
                | TypesJobState.Opening -> "opening"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "closing" -> TypesJobState.Closing
            | "closed" -> TypesJobState.Closed
            | "opened" -> TypesJobState.Opened
            | "failed" -> TypesJobState.Failed
            | "opening" -> TypesJobState.Opening
            | s -> failwith $"Unknown TypesJobState: {s}"

    and [<JsonConverter(typeof<TypesJobStateConverter>)>]
        TypesJobState =
        | Closing
        | Closed
        | Opened
        | Failed
        | Opening
        with
        override this.ToString() =
            match this with
            | Closing -> "closing"
            | Closed -> "closed"
            | Opened -> "opened"
            | Failed -> "failed"
            | Opening -> "opening"

    and TypesMemoryStatusConverter() =
        inherit JsonConverter<TypesMemoryStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesMemoryStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesMemoryStatus.Ok -> "ok"
                | TypesMemoryStatus.SoftLimit -> "soft_limit"
                | TypesMemoryStatus.HardLimit -> "hard_limit"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ok" -> TypesMemoryStatus.Ok
            | "soft_limit" -> TypesMemoryStatus.SoftLimit
            | "hard_limit" -> TypesMemoryStatus.HardLimit
            | s -> failwith $"Unknown TypesMemoryStatus: {s}"

    and [<JsonConverter(typeof<TypesMemoryStatusConverter>)>]
        TypesMemoryStatus =
        | Ok
        | SoftLimit
        | HardLimit
        with
        override this.ToString() =
            match this with
            | Ok -> "ok"
            | SoftLimit -> "soft_limit"
            | HardLimit -> "hard_limit"

    and MlJobsJobsRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("state")>]
        State: TypesJobState option
        [<JsonPropertyName("opened_time")>]
        OpenedTime: string option
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("data.processed_records")>]
        DataProcessedRecords: string option
        [<JsonPropertyName("data.processed_fields")>]
        DataProcessedFields: string option
        [<JsonPropertyName("data.input_bytes")>]
        DataInputBytes: ByteSize option
        [<JsonPropertyName("data.input_records")>]
        DataInputRecords: string option
        [<JsonPropertyName("data.input_fields")>]
        DataInputFields: string option
        [<JsonPropertyName("data.invalid_dates")>]
        DataInvalidDates: string option
        [<JsonPropertyName("data.missing_fields")>]
        DataMissingFields: string option
        [<JsonPropertyName("data.out_of_order_timestamps")>]
        DataOutOfOrderTimestamps: string option
        [<JsonPropertyName("data.empty_buckets")>]
        DataEmptyBuckets: string option
        [<JsonPropertyName("data.sparse_buckets")>]
        DataSparseBuckets: string option
        [<JsonPropertyName("data.buckets")>]
        DataBuckets: string option
        [<JsonPropertyName("data.earliest_record")>]
        DataEarliestRecord: string option
        [<JsonPropertyName("data.latest_record")>]
        DataLatestRecord: string option
        [<JsonPropertyName("data.last")>]
        DataLast: string option
        [<JsonPropertyName("data.last_empty_bucket")>]
        DataLastEmptyBucket: string option
        [<JsonPropertyName("data.last_sparse_bucket")>]
        DataLastSparseBucket: string option
        [<JsonPropertyName("model.bytes")>]
        ModelBytes: ByteSize option
        [<JsonPropertyName("model.memory_status")>]
        ModelMemoryStatus: TypesMemoryStatus option
        [<JsonPropertyName("model.bytes_exceeded")>]
        ModelBytesExceeded: ByteSize option
        [<JsonPropertyName("model.memory_limit")>]
        ModelMemoryLimit: string option
        [<JsonPropertyName("model.by_fields")>]
        ModelByFields: string option
        [<JsonPropertyName("model.over_fields")>]
        ModelOverFields: string option
        [<JsonPropertyName("model.partition_fields")>]
        ModelPartitionFields: string option
        [<JsonPropertyName("model.bucket_allocation_failures")>]
        ModelBucketAllocationFailures: string option
        [<JsonPropertyName("model.categorization_status")>]
        ModelCategorizationStatus: TypesCategorizationStatus option
        [<JsonPropertyName("model.categorized_doc_count")>]
        ModelCategorizedDocCount: string option
        [<JsonPropertyName("model.total_category_count")>]
        ModelTotalCategoryCount: string option
        [<JsonPropertyName("model.frequent_category_count")>]
        ModelFrequentCategoryCount: string option
        [<JsonPropertyName("model.rare_category_count")>]
        ModelRareCategoryCount: string option
        [<JsonPropertyName("model.dead_category_count")>]
        ModelDeadCategoryCount: string option
        [<JsonPropertyName("model.failed_category_count")>]
        ModelFailedCategoryCount: string option
        [<JsonPropertyName("model.log_time")>]
        ModelLogTime: string option
        [<JsonPropertyName("model.timestamp")>]
        ModelTimestamp: string option
        [<JsonPropertyName("forecasts.total")>]
        ForecastsTotal: string option
        [<JsonPropertyName("forecasts.memory.min")>]
        ForecastsMemoryMin: string option
        [<JsonPropertyName("forecasts.memory.max")>]
        ForecastsMemoryMax: string option
        [<JsonPropertyName("forecasts.memory.avg")>]
        ForecastsMemoryAvg: string option
        [<JsonPropertyName("forecasts.memory.total")>]
        ForecastsMemoryTotal: string option
        [<JsonPropertyName("forecasts.records.min")>]
        ForecastsRecordsMin: string option
        [<JsonPropertyName("forecasts.records.max")>]
        ForecastsRecordsMax: string option
        [<JsonPropertyName("forecasts.records.avg")>]
        ForecastsRecordsAvg: string option
        [<JsonPropertyName("forecasts.records.total")>]
        ForecastsRecordsTotal: string option
        [<JsonPropertyName("forecasts.time.min")>]
        ForecastsTimeMin: string option
        [<JsonPropertyName("forecasts.time.max")>]
        ForecastsTimeMax: string option
        [<JsonPropertyName("forecasts.time.avg")>]
        ForecastsTimeAvg: string option
        [<JsonPropertyName("forecasts.time.total")>]
        ForecastsTimeTotal: string option
        [<JsonPropertyName("node.id")>]
        NodeId: NodeId option
        [<JsonPropertyName("node.name")>]
        NodeName: string option
        [<JsonPropertyName("node.ephemeral_id")>]
        NodeEphemeralId: NodeId option
        [<JsonPropertyName("node.address")>]
        NodeAddress: string option
        [<JsonPropertyName("buckets.count")>]
        BucketsCount: string option
        [<JsonPropertyName("buckets.time.total")>]
        BucketsTimeTotal: string option
        [<JsonPropertyName("buckets.time.min")>]
        BucketsTimeMin: string option
        [<JsonPropertyName("buckets.time.max")>]
        BucketsTimeMax: string option
        [<JsonPropertyName("buckets.time.exp_avg")>]
        BucketsTimeExpAvg: string option
        [<JsonPropertyName("buckets.time.exp_avg_hour")>]
        BucketsTimeExpAvgHour: string option
    }

    and TypesCatTrainedModelsColumn = string

    and TypesCatTrainedModelsColumns = obj

    and MlTrainedModelsTrainedModelsRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("created_by")>]
        CreatedBy: string option
        [<JsonPropertyName("heap_size")>]
        HeapSize: ByteSize option
        [<JsonPropertyName("operations")>]
        Operations: string option
        [<JsonPropertyName("license")>]
        License: string option
        [<JsonPropertyName("create_time")>]
        CreateTime: DateTime option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("ingest.pipelines")>]
        IngestPipelines: string option
        [<JsonPropertyName("ingest.count")>]
        IngestCount: string option
        [<JsonPropertyName("ingest.time")>]
        IngestTime: string option
        [<JsonPropertyName("ingest.current")>]
        IngestCurrent: string option
        [<JsonPropertyName("ingest.failed")>]
        IngestFailed: string option
        [<JsonPropertyName("data_frame.id")>]
        DataFrameId: string option
        [<JsonPropertyName("data_frame.create_time")>]
        DataFrameCreateTime: string option
        [<JsonPropertyName("data_frame.source_index")>]
        DataFrameSourceIndex: string option
        [<JsonPropertyName("data_frame.analysis")>]
        DataFrameAnalysis: string option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesCatNodeattrsColumn = obj

    and TypesCatNodeattrsColumns = obj

    and NodeattrsNodeAttributesRecord = {
        [<JsonPropertyName("node")>]
        Node: string option
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("pid")>]
        Pid: string option
        [<JsonPropertyName("host")>]
        Host: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("port")>]
        Port: string option
        [<JsonPropertyName("attr")>]
        Attr: string option
        [<JsonPropertyName("value")>]
        Value: string option
    }

    and TypesCatNodeColumn = string

    and TypesCatNodeColumns = obj

    and NodesNodesRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("pid")>]
        Pid: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("port")>]
        Port: string option
        [<JsonPropertyName("http_address")>]
        HttpAddress: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("flavor")>]
        Flavor: string option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("build")>]
        Build: string option
        [<JsonPropertyName("jdk")>]
        Jdk: string option
        [<JsonPropertyName("disk.total")>]
        DiskTotal: ByteSize option
        [<JsonPropertyName("disk.used")>]
        DiskUsed: ByteSize option
        [<JsonPropertyName("disk.avail")>]
        DiskAvail: ByteSize option
        [<JsonPropertyName("disk.used_percent")>]
        DiskUsedPercent: Percentage option
        [<JsonPropertyName("heap.current")>]
        HeapCurrent: string option
        [<JsonPropertyName("heap.percent")>]
        HeapPercent: Percentage option
        [<JsonPropertyName("heap.max")>]
        HeapMax: string option
        [<JsonPropertyName("ram.current")>]
        RamCurrent: string option
        [<JsonPropertyName("ram.percent")>]
        RamPercent: Percentage option
        [<JsonPropertyName("ram.max")>]
        RamMax: string option
        [<JsonPropertyName("file_desc.current")>]
        FileDescCurrent: string option
        [<JsonPropertyName("file_desc.percent")>]
        FileDescPercent: Percentage option
        [<JsonPropertyName("file_desc.max")>]
        FileDescMax: string option
        [<JsonPropertyName("cpu")>]
        Cpu: string option
        [<JsonPropertyName("load_1m")>]
        Load1m: string option
        [<JsonPropertyName("load_5m")>]
        Load5m: string option
        [<JsonPropertyName("load_15m")>]
        Load15m: string option
        [<JsonPropertyName("available_processors")>]
        AvailableProcessors: string option
        [<JsonPropertyName("uptime")>]
        Uptime: string option
        [<JsonPropertyName("node.role")>]
        NodeRole: string option
        [<JsonPropertyName("master")>]
        Master: string option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("completion.size")>]
        CompletionSize: string option
        [<JsonPropertyName("fielddata.memory_size")>]
        FielddataMemorySize: string option
        [<JsonPropertyName("fielddata.evictions")>]
        FielddataEvictions: string option
        [<JsonPropertyName("query_cache.memory_size")>]
        QueryCacheMemorySize: string option
        [<JsonPropertyName("query_cache.evictions")>]
        QueryCacheEvictions: string option
        [<JsonPropertyName("query_cache.hit_count")>]
        QueryCacheHitCount: string option
        [<JsonPropertyName("query_cache.miss_count")>]
        QueryCacheMissCount: string option
        [<JsonPropertyName("request_cache.memory_size")>]
        RequestCacheMemorySize: string option
        [<JsonPropertyName("request_cache.evictions")>]
        RequestCacheEvictions: string option
        [<JsonPropertyName("request_cache.hit_count")>]
        RequestCacheHitCount: string option
        [<JsonPropertyName("request_cache.miss_count")>]
        RequestCacheMissCount: string option
        [<JsonPropertyName("flush.total")>]
        FlushTotal: string option
        [<JsonPropertyName("flush.total_time")>]
        FlushTotalTime: string option
        [<JsonPropertyName("get.current")>]
        GetCurrent: string option
        [<JsonPropertyName("get.time")>]
        GetTime: string option
        [<JsonPropertyName("get.total")>]
        GetTotal: string option
        [<JsonPropertyName("get.exists_time")>]
        GetExistsTime: string option
        [<JsonPropertyName("get.exists_total")>]
        GetExistsTotal: string option
        [<JsonPropertyName("get.missing_time")>]
        GetMissingTime: string option
        [<JsonPropertyName("get.missing_total")>]
        GetMissingTotal: string option
        [<JsonPropertyName("indexing.delete_current")>]
        IndexingDeleteCurrent: string option
        [<JsonPropertyName("indexing.delete_time")>]
        IndexingDeleteTime: string option
        [<JsonPropertyName("indexing.delete_total")>]
        IndexingDeleteTotal: string option
        [<JsonPropertyName("indexing.index_current")>]
        IndexingIndexCurrent: string option
        [<JsonPropertyName("indexing.index_time")>]
        IndexingIndexTime: string option
        [<JsonPropertyName("indexing.index_total")>]
        IndexingIndexTotal: string option
        [<JsonPropertyName("indexing.index_failed")>]
        IndexingIndexFailed: string option
        [<JsonPropertyName("merges.current")>]
        MergesCurrent: string option
        [<JsonPropertyName("merges.current_docs")>]
        MergesCurrentDocs: string option
        [<JsonPropertyName("merges.current_size")>]
        MergesCurrentSize: string option
        [<JsonPropertyName("merges.total")>]
        MergesTotal: string option
        [<JsonPropertyName("merges.total_docs")>]
        MergesTotalDocs: string option
        [<JsonPropertyName("merges.total_size")>]
        MergesTotalSize: string option
        [<JsonPropertyName("merges.total_time")>]
        MergesTotalTime: string option
        [<JsonPropertyName("refresh.total")>]
        RefreshTotal: string option
        [<JsonPropertyName("refresh.time")>]
        RefreshTime: string option
        [<JsonPropertyName("refresh.external_total")>]
        RefreshExternalTotal: string option
        [<JsonPropertyName("refresh.external_time")>]
        RefreshExternalTime: string option
        [<JsonPropertyName("refresh.listeners")>]
        RefreshListeners: string option
        [<JsonPropertyName("script.compilations")>]
        ScriptCompilations: string option
        [<JsonPropertyName("script.cache_evictions")>]
        ScriptCacheEvictions: string option
        [<JsonPropertyName("script.compilation_limit_triggered")>]
        ScriptCompilationLimitTriggered: string option
        [<JsonPropertyName("search.fetch_current")>]
        SearchFetchCurrent: string option
        [<JsonPropertyName("search.fetch_time")>]
        SearchFetchTime: string option
        [<JsonPropertyName("search.fetch_total")>]
        SearchFetchTotal: string option
        [<JsonPropertyName("search.open_contexts")>]
        SearchOpenContexts: string option
        [<JsonPropertyName("search.query_current")>]
        SearchQueryCurrent: string option
        [<JsonPropertyName("search.query_time")>]
        SearchQueryTime: string option
        [<JsonPropertyName("search.query_total")>]
        SearchQueryTotal: string option
        [<JsonPropertyName("search.scroll_current")>]
        SearchScrollCurrent: string option
        [<JsonPropertyName("search.scroll_time")>]
        SearchScrollTime: string option
        [<JsonPropertyName("search.scroll_total")>]
        SearchScrollTotal: string option
        [<JsonPropertyName("segments.count")>]
        SegmentsCount: string option
        [<JsonPropertyName("segments.memory")>]
        SegmentsMemory: string option
        [<JsonPropertyName("segments.index_writer_memory")>]
        SegmentsIndexWriterMemory: string option
        [<JsonPropertyName("segments.version_map_memory")>]
        SegmentsVersionMapMemory: string option
        [<JsonPropertyName("segments.fixed_bitset_memory")>]
        SegmentsFixedBitsetMemory: string option
        [<JsonPropertyName("suggest.current")>]
        SuggestCurrent: string option
        [<JsonPropertyName("suggest.time")>]
        SuggestTime: string option
        [<JsonPropertyName("suggest.total")>]
        SuggestTotal: string option
        [<JsonPropertyName("bulk.total_operations")>]
        BulkTotalOperations: string option
        [<JsonPropertyName("bulk.total_time")>]
        BulkTotalTime: string option
        [<JsonPropertyName("bulk.total_size_in_bytes")>]
        BulkTotalSizeInBytes: string option
        [<JsonPropertyName("bulk.avg_time")>]
        BulkAvgTime: string option
        [<JsonPropertyName("bulk.avg_size_in_bytes")>]
        BulkAvgSizeInBytes: string option
    }

    and TypesCatPendingTasksColumn = obj

    and TypesCatPendingTasksColumns = obj

    and PendingTasksPendingTasksRecord = {
        [<JsonPropertyName("insertOrder")>]
        InsertOrder: string option
        [<JsonPropertyName("timeInQueue")>]
        TimeInQueue: string option
        [<JsonPropertyName("priority")>]
        Priority: string option
        [<JsonPropertyName("source")>]
        Source: string option
    }

    and TypesCatPluginsColumn = obj

    and TypesCatPluginsColumns = obj

    and PluginsPluginsRecord = {
        [<JsonPropertyName("id")>]
        Id: NodeId option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("component")>]
        Component: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesCatRecoveryColumn = obj

    and TypesCatRecoveryColumns = obj

    and RecoveryRecoveryRecord = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("shard")>]
        Shard: string option
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_millis")>]
        StartTimeMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("stop_time")>]
        StopTime: DateTime option
        [<JsonPropertyName("stop_time_millis")>]
        StopTimeMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("stage")>]
        Stage: string option
        [<JsonPropertyName("source_host")>]
        SourceHost: string option
        [<JsonPropertyName("source_node")>]
        SourceNode: string option
        [<JsonPropertyName("target_host")>]
        TargetHost: string option
        [<JsonPropertyName("target_node")>]
        TargetNode: string option
        [<JsonPropertyName("repository")>]
        Repository: string option
        [<JsonPropertyName("snapshot")>]
        Snapshot: string option
        [<JsonPropertyName("files")>]
        Files: string option
        [<JsonPropertyName("files_recovered")>]
        FilesRecovered: string option
        [<JsonPropertyName("files_percent")>]
        FilesPercent: Percentage option
        [<JsonPropertyName("files_total")>]
        FilesTotal: string option
        [<JsonPropertyName("bytes")>]
        Bytes: string option
        [<JsonPropertyName("bytes_recovered")>]
        BytesRecovered: string option
        [<JsonPropertyName("bytes_percent")>]
        BytesPercent: Percentage option
        [<JsonPropertyName("bytes_total")>]
        BytesTotal: string option
        [<JsonPropertyName("translog_ops")>]
        TranslogOps: string option
        [<JsonPropertyName("translog_ops_recovered")>]
        TranslogOpsRecovered: string option
        [<JsonPropertyName("translog_ops_percent")>]
        TranslogOpsPercent: Percentage option
    }

    and RepositoriesRepositoriesRecord = {
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesCatSegmentsColumn = obj

    and TypesCatSegmentsColumns = obj

    and SegmentsSegmentsRecord = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("shard")>]
        Shard: string option
        [<JsonPropertyName("prirep")>]
        Prirep: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("id")>]
        Id: NodeId option
        [<JsonPropertyName("segment")>]
        Segment: string option
        [<JsonPropertyName("generation")>]
        Generation: string option
        [<JsonPropertyName("docs.count")>]
        DocsCount: string option
        [<JsonPropertyName("docs.deleted")>]
        DocsDeleted: string option
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("size.memory")>]
        SizeMemory: ByteSize option
        [<JsonPropertyName("committed")>]
        Committed: string option
        [<JsonPropertyName("searchable")>]
        Searchable: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("compound")>]
        Compound: string option
    }

    and TypesCatShardColumn = obj

    and TypesCatShardColumns = obj

    and ShardsShardsRecord = {
        [<JsonPropertyName("index")>]
        Index: string option
        [<JsonPropertyName("shard")>]
        Shard: string option
        [<JsonPropertyName("prirep")>]
        Prirep: string option
        [<JsonPropertyName("state")>]
        State: string option
        [<JsonPropertyName("docs")>]
        Docs: System.Text.Json.JsonElement option
        [<JsonPropertyName("store")>]
        Store: System.Text.Json.JsonElement option
        [<JsonPropertyName("dataset")>]
        Dataset: System.Text.Json.JsonElement option
        [<JsonPropertyName("ip")>]
        Ip: System.Text.Json.JsonElement option
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("node")>]
        Node: System.Text.Json.JsonElement option
        [<JsonPropertyName("sync_id")>]
        SyncId: string option
        [<JsonPropertyName("unassigned.reason")>]
        UnassignedReason: string option
        [<JsonPropertyName("unassigned.at")>]
        UnassignedAt: string option
        [<JsonPropertyName("unassigned.for")>]
        UnassignedFor: string option
        [<JsonPropertyName("unassigned.details")>]
        UnassignedDetails: string option
        [<JsonPropertyName("recoverysource.type")>]
        RecoverysourceType: string option
        [<JsonPropertyName("completion.size")>]
        CompletionSize: string option
        [<JsonPropertyName("fielddata.memory_size")>]
        FielddataMemorySize: string option
        [<JsonPropertyName("fielddata.evictions")>]
        FielddataEvictions: string option
        [<JsonPropertyName("query_cache.memory_size")>]
        QueryCacheMemorySize: string option
        [<JsonPropertyName("query_cache.evictions")>]
        QueryCacheEvictions: string option
        [<JsonPropertyName("flush.total")>]
        FlushTotal: string option
        [<JsonPropertyName("flush.total_time")>]
        FlushTotalTime: string option
        [<JsonPropertyName("get.current")>]
        GetCurrent: string option
        [<JsonPropertyName("get.time")>]
        GetTime: string option
        [<JsonPropertyName("get.total")>]
        GetTotal: string option
        [<JsonPropertyName("get.exists_time")>]
        GetExistsTime: string option
        [<JsonPropertyName("get.exists_total")>]
        GetExistsTotal: string option
        [<JsonPropertyName("get.missing_time")>]
        GetMissingTime: string option
        [<JsonPropertyName("get.missing_total")>]
        GetMissingTotal: string option
        [<JsonPropertyName("indexing.delete_current")>]
        IndexingDeleteCurrent: string option
        [<JsonPropertyName("indexing.delete_time")>]
        IndexingDeleteTime: string option
        [<JsonPropertyName("indexing.delete_total")>]
        IndexingDeleteTotal: string option
        [<JsonPropertyName("indexing.index_current")>]
        IndexingIndexCurrent: string option
        [<JsonPropertyName("indexing.index_time")>]
        IndexingIndexTime: string option
        [<JsonPropertyName("indexing.index_total")>]
        IndexingIndexTotal: string option
        [<JsonPropertyName("indexing.index_failed")>]
        IndexingIndexFailed: string option
        [<JsonPropertyName("merges.current")>]
        MergesCurrent: string option
        [<JsonPropertyName("merges.current_docs")>]
        MergesCurrentDocs: string option
        [<JsonPropertyName("merges.current_size")>]
        MergesCurrentSize: string option
        [<JsonPropertyName("merges.total")>]
        MergesTotal: string option
        [<JsonPropertyName("merges.total_docs")>]
        MergesTotalDocs: string option
        [<JsonPropertyName("merges.total_size")>]
        MergesTotalSize: string option
        [<JsonPropertyName("merges.total_time")>]
        MergesTotalTime: string option
        [<JsonPropertyName("refresh.total")>]
        RefreshTotal: string option
        [<JsonPropertyName("refresh.time")>]
        RefreshTime: string option
        [<JsonPropertyName("refresh.external_total")>]
        RefreshExternalTotal: string option
        [<JsonPropertyName("refresh.external_time")>]
        RefreshExternalTime: string option
        [<JsonPropertyName("refresh.listeners")>]
        RefreshListeners: string option
        [<JsonPropertyName("search.fetch_current")>]
        SearchFetchCurrent: string option
        [<JsonPropertyName("search.fetch_time")>]
        SearchFetchTime: string option
        [<JsonPropertyName("search.fetch_total")>]
        SearchFetchTotal: string option
        [<JsonPropertyName("search.open_contexts")>]
        SearchOpenContexts: string option
        [<JsonPropertyName("search.query_current")>]
        SearchQueryCurrent: string option
        [<JsonPropertyName("search.query_time")>]
        SearchQueryTime: string option
        [<JsonPropertyName("search.query_total")>]
        SearchQueryTotal: string option
        [<JsonPropertyName("search.scroll_current")>]
        SearchScrollCurrent: string option
        [<JsonPropertyName("search.scroll_time")>]
        SearchScrollTime: string option
        [<JsonPropertyName("search.scroll_total")>]
        SearchScrollTotal: string option
        [<JsonPropertyName("segments.count")>]
        SegmentsCount: string option
        [<JsonPropertyName("segments.memory")>]
        SegmentsMemory: string option
        [<JsonPropertyName("segments.index_writer_memory")>]
        SegmentsIndexWriterMemory: string option
        [<JsonPropertyName("segments.version_map_memory")>]
        SegmentsVersionMapMemory: string option
        [<JsonPropertyName("segments.fixed_bitset_memory")>]
        SegmentsFixedBitsetMemory: string option
        [<JsonPropertyName("seq_no.max")>]
        SeqNoMax: string option
        [<JsonPropertyName("seq_no.local_checkpoint")>]
        SeqNoLocalCheckpoint: string option
        [<JsonPropertyName("seq_no.global_checkpoint")>]
        SeqNoGlobalCheckpoint: string option
        [<JsonPropertyName("warmer.current")>]
        WarmerCurrent: string option
        [<JsonPropertyName("warmer.total")>]
        WarmerTotal: string option
        [<JsonPropertyName("warmer.total_time")>]
        WarmerTotalTime: string option
        [<JsonPropertyName("path.data")>]
        PathData: string option
        [<JsonPropertyName("path.state")>]
        PathState: string option
        [<JsonPropertyName("bulk.total_operations")>]
        BulkTotalOperations: string option
        [<JsonPropertyName("bulk.total_time")>]
        BulkTotalTime: string option
        [<JsonPropertyName("bulk.total_size_in_bytes")>]
        BulkTotalSizeInBytes: string option
        [<JsonPropertyName("bulk.avg_time")>]
        BulkAvgTime: string option
        [<JsonPropertyName("bulk.avg_size_in_bytes")>]
        BulkAvgSizeInBytes: string option
    }

    and TypesCatSnapshotsColumn = obj

    and TypesCatSnapshotsColumns = obj

    and TypesHourAndMinute = {
        [<JsonPropertyName("hour")>]
        Hour: float array
        [<JsonPropertyName("minute")>]
        Minute: float array
    }

    /// <summary>
    /// A time of day, expressed either as `hh:mm`, `noon`, `midnight`, or an hour/minutes structure.
    /// </summary>
    and TypesScheduleTimeOfDay = obj

    and SnapshotsSnapshotsRecord = {
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("repository")>]
        Repository: string option
        [<JsonPropertyName("status")>]
        Status: string option
        [<JsonPropertyName("start_epoch")>]
        StartEpoch: StringifiedEpochTimeUnitSeconds option
        [<JsonPropertyName("start_time")>]
        StartTime: TypesScheduleTimeOfDay option
        [<JsonPropertyName("end_epoch")>]
        EndEpoch: StringifiedEpochTimeUnitSeconds option
        [<JsonPropertyName("end_time")>]
        EndTime: TimeOfDay option
        [<JsonPropertyName("duration")>]
        Duration: Duration option
        [<JsonPropertyName("indices")>]
        Indices: string option
        [<JsonPropertyName("successful_shards")>]
        SuccessfulShards: string option
        [<JsonPropertyName("failed_shards")>]
        FailedShards: string option
        [<JsonPropertyName("total_shards")>]
        TotalShards: string option
        [<JsonPropertyName("reason")>]
        Reason: string option
    }

    and TypesCatTasksColumn = obj

    and TypesCatTasksColumns = obj

    and TasksTasksRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("action")>]
        Action: string option
        [<JsonPropertyName("task_id")>]
        TaskId: Id option
        [<JsonPropertyName("parent_task_id")>]
        ParentTaskId: string option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("start_time")>]
        StartTime: string option
        [<JsonPropertyName("timestamp")>]
        Timestamp: string option
        [<JsonPropertyName("running_time_ns")>]
        RunningTimeNs: string option
        [<JsonPropertyName("running_time")>]
        RunningTime: string option
        [<JsonPropertyName("node_id")>]
        NodeId: NodeId option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("port")>]
        Port: string option
        [<JsonPropertyName("node")>]
        Node: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("x_opaque_id")>]
        XOpaqueId: string option
        [<JsonPropertyName("description")>]
        Description: string option
    }

    and TypesCatTemplatesColumn = obj

    and TypesCatTemplatesColumns = obj

    and TemplatesTemplatesRecord = {
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("index_patterns")>]
        IndexPatterns: string option
        [<JsonPropertyName("order")>]
        Order: string option
        [<JsonPropertyName("version")>]
        Version: System.Text.Json.JsonElement option
        [<JsonPropertyName("composed_of")>]
        ComposedOf: string option
    }

    and TypesCatThreadPoolColumn = obj

    and TypesCatThreadPoolColumns = obj

    and ThreadPoolThreadPoolRecord = {
        [<JsonPropertyName("node_name")>]
        NodeName: string option
        [<JsonPropertyName("node_id")>]
        NodeId: NodeId option
        [<JsonPropertyName("ephemeral_node_id")>]
        EphemeralNodeId: string option
        [<JsonPropertyName("pid")>]
        Pid: string option
        [<JsonPropertyName("host")>]
        Host: string option
        [<JsonPropertyName("ip")>]
        Ip: string option
        [<JsonPropertyName("port")>]
        Port: string option
        [<JsonPropertyName("name")>]
        Name: string option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("active")>]
        Active: string option
        [<JsonPropertyName("pool_size")>]
        PoolSize: string option
        [<JsonPropertyName("queue")>]
        Queue: string option
        [<JsonPropertyName("queue_size")>]
        QueueSize: string option
        [<JsonPropertyName("rejected")>]
        Rejected: string option
        [<JsonPropertyName("largest")>]
        Largest: string option
        [<JsonPropertyName("completed")>]
        Completed: string option
        [<JsonPropertyName("core")>]
        Core: System.Text.Json.JsonElement option
        [<JsonPropertyName("max")>]
        Max: System.Text.Json.JsonElement option
        [<JsonPropertyName("size")>]
        Size: System.Text.Json.JsonElement option
        [<JsonPropertyName("keep_alive")>]
        KeepAlive: System.Text.Json.JsonElement option
    }

    and TypesCatTransformColumn = string

    and TypesCatTransformColumns = obj

    and TransformsTransformsRecord = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("state")>]
        State: string option
        [<JsonPropertyName("checkpoint")>]
        Checkpoint: string option
        [<JsonPropertyName("documents_processed")>]
        DocumentsProcessed: string option
        [<JsonPropertyName("checkpoint_progress")>]
        CheckpointProgress: System.Text.Json.JsonElement option
        [<JsonPropertyName("last_search_time")>]
        LastSearchTime: System.Text.Json.JsonElement option
        [<JsonPropertyName("changes_last_detection_time")>]
        ChangesLastDetectionTime: System.Text.Json.JsonElement option
        [<JsonPropertyName("create_time")>]
        CreateTime: string option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("source_index")>]
        SourceIndex: string option
        [<JsonPropertyName("dest_index")>]
        DestIndex: string option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("transform_type")>]
        TransformType: string option
        [<JsonPropertyName("frequency")>]
        Frequency: string option
        [<JsonPropertyName("max_page_search_size")>]
        MaxPageSearchSize: string option
        [<JsonPropertyName("docs_per_second")>]
        DocsPerSecond: string option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("search_total")>]
        SearchTotal: string option
        [<JsonPropertyName("search_failure")>]
        SearchFailure: string option
        [<JsonPropertyName("search_time")>]
        SearchTime: string option
        [<JsonPropertyName("index_total")>]
        IndexTotal: string option
        [<JsonPropertyName("index_failure")>]
        IndexFailure: string option
        [<JsonPropertyName("index_time")>]
        IndexTime: string option
        [<JsonPropertyName("documents_indexed")>]
        DocumentsIndexed: string option
        [<JsonPropertyName("delete_time")>]
        DeleteTime: string option
        [<JsonPropertyName("documents_deleted")>]
        DocumentsDeleted: string option
        [<JsonPropertyName("trigger_count")>]
        TriggerCount: string option
        [<JsonPropertyName("pages_processed")>]
        PagesProcessed: string option
        [<JsonPropertyName("processing_time")>]
        ProcessingTime: string option
        [<JsonPropertyName("checkpoint_duration_time_exp_avg")>]
        CheckpointDurationTimeExpAvg: string option
        [<JsonPropertyName("indexed_documents_exp_avg")>]
        IndexedDocumentsExpAvg: string option
        [<JsonPropertyName("processed_documents_exp_avg")>]
        ProcessedDocumentsExpAvg: string option
    }

    and TypesIndexSettings = obj

    and TypesRetentionLease = {
        [<JsonPropertyName("period")>]
        Period: Duration
    }

    and TypesSoftDeletes = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("retention_lease")>]
        RetentionLease: TypesRetentionLease option
    }

    and TypesSegmentSortMissingConverter() =
        inherit JsonConverter<TypesSegmentSortMissing>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSegmentSortMissing, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSegmentSortMissing.Last -> "_last"
                | TypesSegmentSortMissing.First -> "_first"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_last" -> TypesSegmentSortMissing.Last
            | "_first" -> TypesSegmentSortMissing.First
            | s -> failwith $"Unknown TypesSegmentSortMissing: {s}"

    and [<JsonConverter(typeof<TypesSegmentSortMissingConverter>)>]
        TypesSegmentSortMissing =
        | Last
        | First
        with
        override this.ToString() =
            match this with
            | Last -> "_last"
            | First -> "_first"

    and TypesSegmentSortModeConverter() =
        inherit JsonConverter<TypesSegmentSortMode>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSegmentSortMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSegmentSortMode.Min -> "min"
                | TypesSegmentSortMode.MIN -> "MIN"
                | TypesSegmentSortMode.Max -> "max"
                | TypesSegmentSortMode.MAX -> "MAX"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "min" -> TypesSegmentSortMode.Min
            | "MIN" -> TypesSegmentSortMode.MIN
            | "max" -> TypesSegmentSortMode.Max
            | "MAX" -> TypesSegmentSortMode.MAX
            | s -> failwith $"Unknown TypesSegmentSortMode: {s}"

    and [<JsonConverter(typeof<TypesSegmentSortModeConverter>)>]
        TypesSegmentSortMode =
        | Min
        | MIN
        | Max
        | MAX
        with
        override this.ToString() =
            match this with
            | Min -> "min"
            | MIN -> "MIN"
            | Max -> "max"
            | MAX -> "MAX"

    and TypesSegmentSortOrderConverter() =
        inherit JsonConverter<TypesSegmentSortOrder>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSegmentSortOrder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSegmentSortOrder.Asc -> "asc"
                | TypesSegmentSortOrder.ASC -> "ASC"
                | TypesSegmentSortOrder.Desc -> "desc"
                | TypesSegmentSortOrder.DESC -> "DESC"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "asc" -> TypesSegmentSortOrder.Asc
            | "ASC" -> TypesSegmentSortOrder.ASC
            | "desc" -> TypesSegmentSortOrder.Desc
            | "DESC" -> TypesSegmentSortOrder.DESC
            | s -> failwith $"Unknown TypesSegmentSortOrder: {s}"

    and [<JsonConverter(typeof<TypesSegmentSortOrderConverter>)>]
        TypesSegmentSortOrder =
        | Asc
        | ASC
        | Desc
        | DESC
        with
        override this.ToString() =
            match this with
            | Asc -> "asc"
            | ASC -> "ASC"
            | Desc -> "desc"
            | DESC -> "DESC"

    and TypesIndexSegmentSort = {
        [<JsonPropertyName("field")>]
        Field: Fields option
        [<JsonPropertyName("order")>]
        Order: System.Text.Json.JsonElement option
        [<JsonPropertyName("mode")>]
        Mode: System.Text.Json.JsonElement option
        [<JsonPropertyName("missing")>]
        Missing: System.Text.Json.JsonElement option
    }

    and TypesIndexCheckOnStartupConverter() =
        inherit JsonConverter<TypesIndexCheckOnStartup>()

        override _.Write(writer: Utf8JsonWriter, value: TypesIndexCheckOnStartup, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesIndexCheckOnStartup.True -> "true"
                | TypesIndexCheckOnStartup.False -> "false"
                | TypesIndexCheckOnStartup.Checksum -> "checksum"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "true" -> TypesIndexCheckOnStartup.True
            | "false" -> TypesIndexCheckOnStartup.False
            | "checksum" -> TypesIndexCheckOnStartup.Checksum
            | s -> failwith $"Unknown TypesIndexCheckOnStartup: {s}"

    and [<JsonConverter(typeof<TypesIndexCheckOnStartupConverter>)>]
        TypesIndexCheckOnStartup =
        | True
        | False
        | Checksum
        with
        override this.ToString() =
            match this with
            | True -> "true"
            | False -> "false"
            | Checksum -> "checksum"

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and Stringifiedinteger = obj

    /// <summary>
    /// A `null` value that is to be interpreted as an actual value, unless other uses of `null` that are equivalent
    /// to a missing value. It is used for exemple in settings, where using the `NullValue` for a setting will reset
    /// it to its default value.
    /// </summary>
    and NullValue = string

    and TypesMergeScheduler = {
        [<JsonPropertyName("max_thread_count")>]
        MaxThreadCount: Stringifiedinteger option
        [<JsonPropertyName("max_merge_count")>]
        MaxMergeCount: Stringifiedinteger option
    }

    and TypesMerge = {
        [<JsonPropertyName("scheduler")>]
        Scheduler: TypesMergeScheduler option
    }

    and TypesSearchIdle = {
        [<JsonPropertyName("after")>]
        After: Duration option
    }

    and TypesSlowlogTresholdLevels = {
        [<JsonPropertyName("warn")>]
        Warn: Duration option
        [<JsonPropertyName("info")>]
        Info: Duration option
        [<JsonPropertyName("debug")>]
        Debug: Duration option
        [<JsonPropertyName("trace")>]
        Trace: Duration option
    }

    and TypesSlowlogTresholds = {
        [<JsonPropertyName("query")>]
        Query: TypesSlowlogTresholdLevels option
        [<JsonPropertyName("fetch")>]
        Fetch: TypesSlowlogTresholdLevels option
    }

    and TypesSlowlogSettings = {
        [<JsonPropertyName("level")>]
        Level: string option
        [<JsonPropertyName("source")>]
        Source: float option
        [<JsonPropertyName("reformat")>]
        Reformat: bool option
        [<JsonPropertyName("threshold")>]
        Threshold: TypesSlowlogTresholds option
    }

    and TypesSettingsSearch = {
        [<JsonPropertyName("idle")>]
        Idle: TypesSearchIdle option
        [<JsonPropertyName("slowlog")>]
        Slowlog: TypesSlowlogSettings option
    }

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and Stringifiedboolean = obj

    and TypesIndexSettingBlocks = {
        [<JsonPropertyName("read_only")>]
        ReadOnly: Stringifiedboolean option
        [<JsonPropertyName("read_only_allow_delete")>]
        ReadOnlyAllowDelete: Stringifiedboolean option
        [<JsonPropertyName("read")>]
        Read: Stringifiedboolean option
        [<JsonPropertyName("write")>]
        Write: Stringifiedboolean option
        [<JsonPropertyName("metadata")>]
        Metadata: Stringifiedboolean option
    }

    and TypesSettingsAnalyze = {
        [<JsonPropertyName("max_token_count")>]
        MaxTokenCount: Stringifiedinteger option
    }

    and TypesSettingsHighlight = {
        [<JsonPropertyName("max_analyzed_offset")>]
        MaxAnalyzedOffset: float option
    }

    and TypesIndexRoutingAllocationDisk = {
        [<JsonPropertyName("threshold_enabled")>]
        ThresholdEnabled: System.Text.Json.JsonElement option
    }

    and TypesIndexRoutingAllocationInclude = {
        [<JsonPropertyName("_tier_preference")>]
        TierPreference: string option
        [<JsonPropertyName("_id")>]
        Id: Id option
    }

    and TypesIndexRoutingAllocationInitialRecovery = {
        [<JsonPropertyName("_id")>]
        Id: Id option
    }

    and TypesIndexRoutingAllocationOptionsConverter() =
        inherit JsonConverter<TypesIndexRoutingAllocationOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesIndexRoutingAllocationOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesIndexRoutingAllocationOptions.All -> "all"
                | TypesIndexRoutingAllocationOptions.Primaries -> "primaries"
                | TypesIndexRoutingAllocationOptions.NewPrimaries -> "new_primaries"
                | TypesIndexRoutingAllocationOptions.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> TypesIndexRoutingAllocationOptions.All
            | "primaries" -> TypesIndexRoutingAllocationOptions.Primaries
            | "new_primaries" -> TypesIndexRoutingAllocationOptions.NewPrimaries
            | "none" -> TypesIndexRoutingAllocationOptions.None
            | s -> failwith $"Unknown TypesIndexRoutingAllocationOptions: {s}"

    and [<JsonConverter(typeof<TypesIndexRoutingAllocationOptionsConverter>)>]
        TypesIndexRoutingAllocationOptions =
        | All
        | Primaries
        | NewPrimaries
        | None
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | Primaries -> "primaries"
            | NewPrimaries -> "new_primaries"
            | None -> "none"

    and TypesIndexRoutingAllocation = {
        [<JsonPropertyName("enable")>]
        Enable: TypesIndexRoutingAllocationOptions option
        [<JsonPropertyName("include")>]
        Include: TypesIndexRoutingAllocationInclude option
        [<JsonPropertyName("initial_recovery")>]
        InitialRecovery: TypesIndexRoutingAllocationInitialRecovery option
        [<JsonPropertyName("disk")>]
        Disk: TypesIndexRoutingAllocationDisk option
    }

    and TypesIndexRoutingRebalanceOptionsConverter() =
        inherit JsonConverter<TypesIndexRoutingRebalanceOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesIndexRoutingRebalanceOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesIndexRoutingRebalanceOptions.All -> "all"
                | TypesIndexRoutingRebalanceOptions.Primaries -> "primaries"
                | TypesIndexRoutingRebalanceOptions.Replicas -> "replicas"
                | TypesIndexRoutingRebalanceOptions.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> TypesIndexRoutingRebalanceOptions.All
            | "primaries" -> TypesIndexRoutingRebalanceOptions.Primaries
            | "replicas" -> TypesIndexRoutingRebalanceOptions.Replicas
            | "none" -> TypesIndexRoutingRebalanceOptions.None
            | s -> failwith $"Unknown TypesIndexRoutingRebalanceOptions: {s}"

    and [<JsonConverter(typeof<TypesIndexRoutingRebalanceOptionsConverter>)>]
        TypesIndexRoutingRebalanceOptions =
        | All
        | Primaries
        | Replicas
        | None
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | Primaries -> "primaries"
            | Replicas -> "replicas"
            | None -> "none"

    and TypesIndexRoutingRebalance = {
        [<JsonPropertyName("enable")>]
        Enable: TypesIndexRoutingRebalanceOptions
    }

    and TypesIndexRouting = {
        [<JsonPropertyName("allocation")>]
        Allocation: TypesIndexRoutingAllocation option
        [<JsonPropertyName("rebalance")>]
        Rebalance: TypesIndexRoutingRebalance option
    }

    and PipelineName = string

    and TypesIndexSettingsLifecycleStep = {
        [<JsonPropertyName("wait_time_threshold")>]
        WaitTimeThreshold: Duration option
    }

    and TypesIndexSettingsLifecycle = {
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("indexing_complete")>]
        IndexingComplete: Stringifiedboolean option
        [<JsonPropertyName("origination_date")>]
        OriginationDate: float option
        [<JsonPropertyName("parse_origination_date")>]
        ParseOriginationDate: bool option
        [<JsonPropertyName("step")>]
        Step: TypesIndexSettingsLifecycleStep option
        [<JsonPropertyName("rollover_alias")>]
        RolloverAlias: string option
        [<JsonPropertyName("prefer_ilm")>]
        PreferIlm: System.Text.Json.JsonElement option
    }

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and StringifiedEpochTimeUnitMillis = obj

    and Uuid = string

    and TypesIndexVersioning = {
        [<JsonPropertyName("created")>]
        Created: VersionString option
        [<JsonPropertyName("created_string")>]
        CreatedString: string option
    }

    and TypesTranslogDurabilityConverter() =
        inherit JsonConverter<TypesTranslogDurability>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTranslogDurability, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTranslogDurability.Request -> "request"
                | TypesTranslogDurability.REQUEST -> "REQUEST"
                | TypesTranslogDurability.Async -> "async"
                | TypesTranslogDurability.ASYNC -> "ASYNC"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "request" -> TypesTranslogDurability.Request
            | "REQUEST" -> TypesTranslogDurability.REQUEST
            | "async" -> TypesTranslogDurability.Async
            | "ASYNC" -> TypesTranslogDurability.ASYNC
            | s -> failwith $"Unknown TypesTranslogDurability: {s}"

    and [<JsonConverter(typeof<TypesTranslogDurabilityConverter>)>]
        TypesTranslogDurability =
        | Request
        | REQUEST
        | Async
        | ASYNC
        with
        override this.ToString() =
            match this with
            | Request -> "request"
            | REQUEST -> "REQUEST"
            | Async -> "async"
            | ASYNC -> "ASYNC"

    and TypesTranslogRetention = {
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("age")>]
        Age: Duration option
    }

    and TypesTranslog = {
        [<JsonPropertyName("sync_interval")>]
        SyncInterval: Duration option
        [<JsonPropertyName("durability")>]
        Durability: TypesTranslogDurability option
        [<JsonPropertyName("flush_threshold_size")>]
        FlushThresholdSize: ByteSize option
        [<JsonPropertyName("retention")>]
        Retention: TypesTranslogRetention option
    }

    and TypesSettingsQueryString = {
        [<JsonPropertyName("lenient")>]
        Lenient: Stringifiedboolean
    }

    and AnalysisArabicAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisArmenianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisBasqueAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisBengaliAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisBrazilianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisBulgarianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisCatalanAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisChineseAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisCjkAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisCustomAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("char_filter")>]
        CharFilter: System.Text.Json.JsonElement option
        [<JsonPropertyName("filter")>]
        Filter: System.Text.Json.JsonElement option
        [<JsonPropertyName("position_increment_gap")>]
        PositionIncrementGap: float option
        [<JsonPropertyName("position_offset_gap")>]
        PositionOffsetGap: float option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: string
    }

    and AnalysisCzechAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisDanishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisDutchAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisEnglishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisEstonianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisFingerprintAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("max_output_size")>]
        MaxOutputSize: float option
        [<JsonPropertyName("separator")>]
        Separator: string option
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisFinnishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisFrenchAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisGalicianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisGermanAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisGreekAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisHindiAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisHungarianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisIcuNormalizationModeConverter() =
        inherit JsonConverter<AnalysisIcuNormalizationMode>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuNormalizationMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuNormalizationMode.Decompose -> "decompose"
                | AnalysisIcuNormalizationMode.Compose -> "compose"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "decompose" -> AnalysisIcuNormalizationMode.Decompose
            | "compose" -> AnalysisIcuNormalizationMode.Compose
            | s -> failwith $"Unknown AnalysisIcuNormalizationMode: {s}"

    and [<JsonConverter(typeof<AnalysisIcuNormalizationModeConverter>)>]
        AnalysisIcuNormalizationMode =
        | Decompose
        | Compose
        with
        override this.ToString() =
            match this with
            | Decompose -> "decompose"
            | Compose -> "compose"

    and AnalysisIcuNormalizationTypeConverter() =
        inherit JsonConverter<AnalysisIcuNormalizationType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuNormalizationType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuNormalizationType.Nfc -> "nfc"
                | AnalysisIcuNormalizationType.Nfkc -> "nfkc"
                | AnalysisIcuNormalizationType.NfkcCf -> "nfkc_cf"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "nfc" -> AnalysisIcuNormalizationType.Nfc
            | "nfkc" -> AnalysisIcuNormalizationType.Nfkc
            | "nfkc_cf" -> AnalysisIcuNormalizationType.NfkcCf
            | s -> failwith $"Unknown AnalysisIcuNormalizationType: {s}"

    and [<JsonConverter(typeof<AnalysisIcuNormalizationTypeConverter>)>]
        AnalysisIcuNormalizationType =
        | Nfc
        | Nfkc
        | NfkcCf
        with
        override this.ToString() =
            match this with
            | Nfc -> "nfc"
            | Nfkc -> "nfkc"
            | NfkcCf -> "nfkc_cf"

    and AnalysisIcuAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("method")>]
        Method: AnalysisIcuNormalizationType
        [<JsonPropertyName("mode")>]
        Mode: AnalysisIcuNormalizationMode
    }

    and AnalysisIndonesianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisIrishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisItalianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisKeywordAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisKuromojiTokenizationModeConverter() =
        inherit JsonConverter<AnalysisKuromojiTokenizationMode>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisKuromojiTokenizationMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisKuromojiTokenizationMode.Normal -> "normal"
                | AnalysisKuromojiTokenizationMode.Search -> "search"
                | AnalysisKuromojiTokenizationMode.Extended -> "extended"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "normal" -> AnalysisKuromojiTokenizationMode.Normal
            | "search" -> AnalysisKuromojiTokenizationMode.Search
            | "extended" -> AnalysisKuromojiTokenizationMode.Extended
            | s -> failwith $"Unknown AnalysisKuromojiTokenizationMode: {s}"

    and [<JsonConverter(typeof<AnalysisKuromojiTokenizationModeConverter>)>]
        AnalysisKuromojiTokenizationMode =
        | Normal
        | Search
        | Extended
        with
        override this.ToString() =
            match this with
            | Normal -> "normal"
            | Search -> "search"
            | Extended -> "extended"

    and AnalysisKuromojiAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("mode")>]
        Mode: AnalysisKuromojiTokenizationMode option
        [<JsonPropertyName("user_dictionary")>]
        UserDictionary: string option
    }

    and AnalysisLatvianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisLithuanianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisNoriDecompoundModeConverter() =
        inherit JsonConverter<AnalysisNoriDecompoundMode>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisNoriDecompoundMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisNoriDecompoundMode.Discard -> "discard"
                | AnalysisNoriDecompoundMode.None -> "none"
                | AnalysisNoriDecompoundMode.Mixed -> "mixed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "discard" -> AnalysisNoriDecompoundMode.Discard
            | "none" -> AnalysisNoriDecompoundMode.None
            | "mixed" -> AnalysisNoriDecompoundMode.Mixed
            | s -> failwith $"Unknown AnalysisNoriDecompoundMode: {s}"

    and [<JsonConverter(typeof<AnalysisNoriDecompoundModeConverter>)>]
        AnalysisNoriDecompoundMode =
        | Discard
        | None
        | Mixed
        with
        override this.ToString() =
            match this with
            | Discard -> "discard"
            | None -> "none"
            | Mixed -> "mixed"

    and AnalysisNoriAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("decompound_mode")>]
        DecompoundMode: AnalysisNoriDecompoundMode option
        [<JsonPropertyName("stoptags")>]
        Stoptags: string array option
        [<JsonPropertyName("user_dictionary")>]
        UserDictionary: string option
    }

    and AnalysisNorwegianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisPatternAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("flags")>]
        Flags: string option
        [<JsonPropertyName("lowercase")>]
        Lowercase: bool option
        [<JsonPropertyName("pattern")>]
        Pattern: string option
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisPersianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisPortugueseAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisRomanianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisRussianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisSerbianAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisSimpleAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisSnowballLanguageConverter() =
        inherit JsonConverter<AnalysisSnowballLanguage>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisSnowballLanguage, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisSnowballLanguage.Arabic -> "Arabic"
                | AnalysisSnowballLanguage.Armenian -> "Armenian"
                | AnalysisSnowballLanguage.Basque -> "Basque"
                | AnalysisSnowballLanguage.Catalan -> "Catalan"
                | AnalysisSnowballLanguage.Danish -> "Danish"
                | AnalysisSnowballLanguage.Dutch -> "Dutch"
                | AnalysisSnowballLanguage.English -> "English"
                | AnalysisSnowballLanguage.Estonian -> "Estonian"
                | AnalysisSnowballLanguage.Finnish -> "Finnish"
                | AnalysisSnowballLanguage.French -> "French"
                | AnalysisSnowballLanguage.German -> "German"
                | AnalysisSnowballLanguage.German2 -> "German2"
                | AnalysisSnowballLanguage.Hungarian -> "Hungarian"
                | AnalysisSnowballLanguage.Italian -> "Italian"
                | AnalysisSnowballLanguage.Irish -> "Irish"
                | AnalysisSnowballLanguage.Kp -> "Kp"
                | AnalysisSnowballLanguage.Lithuanian -> "Lithuanian"
                | AnalysisSnowballLanguage.Lovins -> "Lovins"
                | AnalysisSnowballLanguage.Norwegian -> "Norwegian"
                | AnalysisSnowballLanguage.Porter -> "Porter"
                | AnalysisSnowballLanguage.Portuguese -> "Portuguese"
                | AnalysisSnowballLanguage.Romanian -> "Romanian"
                | AnalysisSnowballLanguage.Russian -> "Russian"
                | AnalysisSnowballLanguage.Serbian -> "Serbian"
                | AnalysisSnowballLanguage.Spanish -> "Spanish"
                | AnalysisSnowballLanguage.Swedish -> "Swedish"
                | AnalysisSnowballLanguage.Turkish -> "Turkish"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "Arabic" -> AnalysisSnowballLanguage.Arabic
            | "Armenian" -> AnalysisSnowballLanguage.Armenian
            | "Basque" -> AnalysisSnowballLanguage.Basque
            | "Catalan" -> AnalysisSnowballLanguage.Catalan
            | "Danish" -> AnalysisSnowballLanguage.Danish
            | "Dutch" -> AnalysisSnowballLanguage.Dutch
            | "English" -> AnalysisSnowballLanguage.English
            | "Estonian" -> AnalysisSnowballLanguage.Estonian
            | "Finnish" -> AnalysisSnowballLanguage.Finnish
            | "French" -> AnalysisSnowballLanguage.French
            | "German" -> AnalysisSnowballLanguage.German
            | "German2" -> AnalysisSnowballLanguage.German2
            | "Hungarian" -> AnalysisSnowballLanguage.Hungarian
            | "Italian" -> AnalysisSnowballLanguage.Italian
            | "Irish" -> AnalysisSnowballLanguage.Irish
            | "Kp" -> AnalysisSnowballLanguage.Kp
            | "Lithuanian" -> AnalysisSnowballLanguage.Lithuanian
            | "Lovins" -> AnalysisSnowballLanguage.Lovins
            | "Norwegian" -> AnalysisSnowballLanguage.Norwegian
            | "Porter" -> AnalysisSnowballLanguage.Porter
            | "Portuguese" -> AnalysisSnowballLanguage.Portuguese
            | "Romanian" -> AnalysisSnowballLanguage.Romanian
            | "Russian" -> AnalysisSnowballLanguage.Russian
            | "Serbian" -> AnalysisSnowballLanguage.Serbian
            | "Spanish" -> AnalysisSnowballLanguage.Spanish
            | "Swedish" -> AnalysisSnowballLanguage.Swedish
            | "Turkish" -> AnalysisSnowballLanguage.Turkish
            | s -> failwith $"Unknown AnalysisSnowballLanguage: {s}"

    and [<JsonConverter(typeof<AnalysisSnowballLanguageConverter>)>]
        AnalysisSnowballLanguage =
        | Arabic
        | Armenian
        | Basque
        | Catalan
        | Danish
        | Dutch
        | English
        | Estonian
        | Finnish
        | French
        | German
        | German2
        | Hungarian
        | Italian
        | Irish
        | Kp
        | Lithuanian
        | Lovins
        | Norwegian
        | Porter
        | Portuguese
        | Romanian
        | Russian
        | Serbian
        | Spanish
        | Swedish
        | Turkish
        with
        override this.ToString() =
            match this with
            | Arabic -> "Arabic"
            | Armenian -> "Armenian"
            | Basque -> "Basque"
            | Catalan -> "Catalan"
            | Danish -> "Danish"
            | Dutch -> "Dutch"
            | English -> "English"
            | Estonian -> "Estonian"
            | Finnish -> "Finnish"
            | French -> "French"
            | German -> "German"
            | German2 -> "German2"
            | Hungarian -> "Hungarian"
            | Italian -> "Italian"
            | Irish -> "Irish"
            | Kp -> "Kp"
            | Lithuanian -> "Lithuanian"
            | Lovins -> "Lovins"
            | Norwegian -> "Norwegian"
            | Porter -> "Porter"
            | Portuguese -> "Portuguese"
            | Romanian -> "Romanian"
            | Russian -> "Russian"
            | Serbian -> "Serbian"
            | Spanish -> "Spanish"
            | Swedish -> "Swedish"
            | Turkish -> "Turkish"

    and AnalysisSnowballAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("language")>]
        Language: AnalysisSnowballLanguage
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
    }

    and AnalysisSoraniAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisSpanishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisStandardAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisStopAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisSwedishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisThaiAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisTurkishAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
        [<JsonPropertyName("stem_exclusion")>]
        StemExclusion: string array option
    }

    and AnalysisWhitespaceAnalyzer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisAnalyzerConverter() =
        inherit JsonConverter<AnalysisAnalyzer>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisAnalyzer, options: JsonSerializerOptions) =
            match value with
            | AnalysisAnalyzer.Arabic v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Armenian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Basque v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Bengali v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Brazilian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Bulgarian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Catalan v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Chinese v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Cjk v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Custom v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Czech v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Danish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Dutch v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.English v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Estonian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Fingerprint v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Finnish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.French v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Galician v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.German v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Greek v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Hindi v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Hungarian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.IcuAnalyzer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Indonesian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Irish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Italian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Keyword v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Kuromoji v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Latvian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Lithuanian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Nori v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Norwegian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Pattern v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Persian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Portuguese v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Romanian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Russian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Serbian v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Simple v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Snowball v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Sorani v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Spanish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Standard v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Stop v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Swedish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Thai v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Turkish v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisAnalyzer.Whitespace v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "arabic" -> AnalysisAnalyzer.Arabic (JsonSerializer.Deserialize<AnalysisArabicAnalyzer>(json, options))
            | "armenian" -> AnalysisAnalyzer.Armenian (JsonSerializer.Deserialize<AnalysisArmenianAnalyzer>(json, options))
            | "basque" -> AnalysisAnalyzer.Basque (JsonSerializer.Deserialize<AnalysisBasqueAnalyzer>(json, options))
            | "bengali" -> AnalysisAnalyzer.Bengali (JsonSerializer.Deserialize<AnalysisBengaliAnalyzer>(json, options))
            | "brazilian" -> AnalysisAnalyzer.Brazilian (JsonSerializer.Deserialize<AnalysisBrazilianAnalyzer>(json, options))
            | "bulgarian" -> AnalysisAnalyzer.Bulgarian (JsonSerializer.Deserialize<AnalysisBulgarianAnalyzer>(json, options))
            | "catalan" -> AnalysisAnalyzer.Catalan (JsonSerializer.Deserialize<AnalysisCatalanAnalyzer>(json, options))
            | "chinese" -> AnalysisAnalyzer.Chinese (JsonSerializer.Deserialize<AnalysisChineseAnalyzer>(json, options))
            | "cjk" -> AnalysisAnalyzer.Cjk (JsonSerializer.Deserialize<AnalysisCjkAnalyzer>(json, options))
            | "custom" -> AnalysisAnalyzer.Custom (JsonSerializer.Deserialize<AnalysisCustomAnalyzer>(json, options))
            | "czech" -> AnalysisAnalyzer.Czech (JsonSerializer.Deserialize<AnalysisCzechAnalyzer>(json, options))
            | "danish" -> AnalysisAnalyzer.Danish (JsonSerializer.Deserialize<AnalysisDanishAnalyzer>(json, options))
            | "dutch" -> AnalysisAnalyzer.Dutch (JsonSerializer.Deserialize<AnalysisDutchAnalyzer>(json, options))
            | "english" -> AnalysisAnalyzer.English (JsonSerializer.Deserialize<AnalysisEnglishAnalyzer>(json, options))
            | "estonian" -> AnalysisAnalyzer.Estonian (JsonSerializer.Deserialize<AnalysisEstonianAnalyzer>(json, options))
            | "fingerprint" -> AnalysisAnalyzer.Fingerprint (JsonSerializer.Deserialize<AnalysisFingerprintAnalyzer>(json, options))
            | "finnish" -> AnalysisAnalyzer.Finnish (JsonSerializer.Deserialize<AnalysisFinnishAnalyzer>(json, options))
            | "french" -> AnalysisAnalyzer.French (JsonSerializer.Deserialize<AnalysisFrenchAnalyzer>(json, options))
            | "galician" -> AnalysisAnalyzer.Galician (JsonSerializer.Deserialize<AnalysisGalicianAnalyzer>(json, options))
            | "german" -> AnalysisAnalyzer.German (JsonSerializer.Deserialize<AnalysisGermanAnalyzer>(json, options))
            | "greek" -> AnalysisAnalyzer.Greek (JsonSerializer.Deserialize<AnalysisGreekAnalyzer>(json, options))
            | "hindi" -> AnalysisAnalyzer.Hindi (JsonSerializer.Deserialize<AnalysisHindiAnalyzer>(json, options))
            | "hungarian" -> AnalysisAnalyzer.Hungarian (JsonSerializer.Deserialize<AnalysisHungarianAnalyzer>(json, options))
            | "icu_analyzer" -> AnalysisAnalyzer.IcuAnalyzer (JsonSerializer.Deserialize<AnalysisIcuAnalyzer>(json, options))
            | "indonesian" -> AnalysisAnalyzer.Indonesian (JsonSerializer.Deserialize<AnalysisIndonesianAnalyzer>(json, options))
            | "irish" -> AnalysisAnalyzer.Irish (JsonSerializer.Deserialize<AnalysisIrishAnalyzer>(json, options))
            | "italian" -> AnalysisAnalyzer.Italian (JsonSerializer.Deserialize<AnalysisItalianAnalyzer>(json, options))
            | "keyword" -> AnalysisAnalyzer.Keyword (JsonSerializer.Deserialize<AnalysisKeywordAnalyzer>(json, options))
            | "kuromoji" -> AnalysisAnalyzer.Kuromoji (JsonSerializer.Deserialize<AnalysisKuromojiAnalyzer>(json, options))
            | "latvian" -> AnalysisAnalyzer.Latvian (JsonSerializer.Deserialize<AnalysisLatvianAnalyzer>(json, options))
            | "lithuanian" -> AnalysisAnalyzer.Lithuanian (JsonSerializer.Deserialize<AnalysisLithuanianAnalyzer>(json, options))
            | "nori" -> AnalysisAnalyzer.Nori (JsonSerializer.Deserialize<AnalysisNoriAnalyzer>(json, options))
            | "norwegian" -> AnalysisAnalyzer.Norwegian (JsonSerializer.Deserialize<AnalysisNorwegianAnalyzer>(json, options))
            | "pattern" -> AnalysisAnalyzer.Pattern (JsonSerializer.Deserialize<AnalysisPatternAnalyzer>(json, options))
            | "persian" -> AnalysisAnalyzer.Persian (JsonSerializer.Deserialize<AnalysisPersianAnalyzer>(json, options))
            | "portuguese" -> AnalysisAnalyzer.Portuguese (JsonSerializer.Deserialize<AnalysisPortugueseAnalyzer>(json, options))
            | "romanian" -> AnalysisAnalyzer.Romanian (JsonSerializer.Deserialize<AnalysisRomanianAnalyzer>(json, options))
            | "russian" -> AnalysisAnalyzer.Russian (JsonSerializer.Deserialize<AnalysisRussianAnalyzer>(json, options))
            | "serbian" -> AnalysisAnalyzer.Serbian (JsonSerializer.Deserialize<AnalysisSerbianAnalyzer>(json, options))
            | "simple" -> AnalysisAnalyzer.Simple (JsonSerializer.Deserialize<AnalysisSimpleAnalyzer>(json, options))
            | "snowball" -> AnalysisAnalyzer.Snowball (JsonSerializer.Deserialize<AnalysisSnowballAnalyzer>(json, options))
            | "sorani" -> AnalysisAnalyzer.Sorani (JsonSerializer.Deserialize<AnalysisSoraniAnalyzer>(json, options))
            | "spanish" -> AnalysisAnalyzer.Spanish (JsonSerializer.Deserialize<AnalysisSpanishAnalyzer>(json, options))
            | "standard" -> AnalysisAnalyzer.Standard (JsonSerializer.Deserialize<AnalysisStandardAnalyzer>(json, options))
            | "stop" -> AnalysisAnalyzer.Stop (JsonSerializer.Deserialize<AnalysisStopAnalyzer>(json, options))
            | "swedish" -> AnalysisAnalyzer.Swedish (JsonSerializer.Deserialize<AnalysisSwedishAnalyzer>(json, options))
            | "thai" -> AnalysisAnalyzer.Thai (JsonSerializer.Deserialize<AnalysisThaiAnalyzer>(json, options))
            | "turkish" -> AnalysisAnalyzer.Turkish (JsonSerializer.Deserialize<AnalysisTurkishAnalyzer>(json, options))
            | "whitespace" -> AnalysisAnalyzer.Whitespace (JsonSerializer.Deserialize<AnalysisWhitespaceAnalyzer>(json, options))
            | s -> failwith $"Unknown AnalysisAnalyzer type: {s}"

    and [<JsonConverter(typeof<AnalysisAnalyzerConverter>)>]
        AnalysisAnalyzer =
        | Arabic of AnalysisArabicAnalyzer
        | Armenian of AnalysisArmenianAnalyzer
        | Basque of AnalysisBasqueAnalyzer
        | Bengali of AnalysisBengaliAnalyzer
        | Brazilian of AnalysisBrazilianAnalyzer
        | Bulgarian of AnalysisBulgarianAnalyzer
        | Catalan of AnalysisCatalanAnalyzer
        | Chinese of AnalysisChineseAnalyzer
        | Cjk of AnalysisCjkAnalyzer
        | Custom of AnalysisCustomAnalyzer
        | Czech of AnalysisCzechAnalyzer
        | Danish of AnalysisDanishAnalyzer
        | Dutch of AnalysisDutchAnalyzer
        | English of AnalysisEnglishAnalyzer
        | Estonian of AnalysisEstonianAnalyzer
        | Fingerprint of AnalysisFingerprintAnalyzer
        | Finnish of AnalysisFinnishAnalyzer
        | French of AnalysisFrenchAnalyzer
        | Galician of AnalysisGalicianAnalyzer
        | German of AnalysisGermanAnalyzer
        | Greek of AnalysisGreekAnalyzer
        | Hindi of AnalysisHindiAnalyzer
        | Hungarian of AnalysisHungarianAnalyzer
        | IcuAnalyzer of AnalysisIcuAnalyzer
        | Indonesian of AnalysisIndonesianAnalyzer
        | Irish of AnalysisIrishAnalyzer
        | Italian of AnalysisItalianAnalyzer
        | Keyword of AnalysisKeywordAnalyzer
        | Kuromoji of AnalysisKuromojiAnalyzer
        | Latvian of AnalysisLatvianAnalyzer
        | Lithuanian of AnalysisLithuanianAnalyzer
        | Nori of AnalysisNoriAnalyzer
        | Norwegian of AnalysisNorwegianAnalyzer
        | Pattern of AnalysisPatternAnalyzer
        | Persian of AnalysisPersianAnalyzer
        | Portuguese of AnalysisPortugueseAnalyzer
        | Romanian of AnalysisRomanianAnalyzer
        | Russian of AnalysisRussianAnalyzer
        | Serbian of AnalysisSerbianAnalyzer
        | Simple of AnalysisSimpleAnalyzer
        | Snowball of AnalysisSnowballAnalyzer
        | Sorani of AnalysisSoraniAnalyzer
        | Spanish of AnalysisSpanishAnalyzer
        | Standard of AnalysisStandardAnalyzer
        | Stop of AnalysisStopAnalyzer
        | Swedish of AnalysisSwedishAnalyzer
        | Thai of AnalysisThaiAnalyzer
        | Turkish of AnalysisTurkishAnalyzer
        | Whitespace of AnalysisWhitespaceAnalyzer

    and AnalysisAnalyzerTypeConverter() =
        inherit JsonConverter<AnalysisAnalyzerType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisAnalyzerType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisAnalyzerType.Arabic -> "arabic"
                | AnalysisAnalyzerType.Armenian -> "armenian"
                | AnalysisAnalyzerType.Basque -> "basque"
                | AnalysisAnalyzerType.Bengali -> "bengali"
                | AnalysisAnalyzerType.Brazilian -> "brazilian"
                | AnalysisAnalyzerType.Bulgarian -> "bulgarian"
                | AnalysisAnalyzerType.Catalan -> "catalan"
                | AnalysisAnalyzerType.Chinese -> "chinese"
                | AnalysisAnalyzerType.Cjk -> "cjk"
                | AnalysisAnalyzerType.Custom -> "custom"
                | AnalysisAnalyzerType.Czech -> "czech"
                | AnalysisAnalyzerType.Danish -> "danish"
                | AnalysisAnalyzerType.Dutch -> "dutch"
                | AnalysisAnalyzerType.English -> "english"
                | AnalysisAnalyzerType.Estonian -> "estonian"
                | AnalysisAnalyzerType.Fingerprint -> "fingerprint"
                | AnalysisAnalyzerType.Finnish -> "finnish"
                | AnalysisAnalyzerType.French -> "french"
                | AnalysisAnalyzerType.Galician -> "galician"
                | AnalysisAnalyzerType.German -> "german"
                | AnalysisAnalyzerType.Greek -> "greek"
                | AnalysisAnalyzerType.Hindi -> "hindi"
                | AnalysisAnalyzerType.Hungarian -> "hungarian"
                | AnalysisAnalyzerType.IcuAnalyzer -> "icu_analyzer"
                | AnalysisAnalyzerType.Indonesian -> "indonesian"
                | AnalysisAnalyzerType.Irish -> "irish"
                | AnalysisAnalyzerType.Italian -> "italian"
                | AnalysisAnalyzerType.Keyword -> "keyword"
                | AnalysisAnalyzerType.Kuromoji -> "kuromoji"
                | AnalysisAnalyzerType.Latvian -> "latvian"
                | AnalysisAnalyzerType.Lithuanian -> "lithuanian"
                | AnalysisAnalyzerType.Nori -> "nori"
                | AnalysisAnalyzerType.Norwegian -> "norwegian"
                | AnalysisAnalyzerType.Pattern -> "pattern"
                | AnalysisAnalyzerType.Persian -> "persian"
                | AnalysisAnalyzerType.Portuguese -> "portuguese"
                | AnalysisAnalyzerType.Romanian -> "romanian"
                | AnalysisAnalyzerType.Russian -> "russian"
                | AnalysisAnalyzerType.Serbian -> "serbian"
                | AnalysisAnalyzerType.Simple -> "simple"
                | AnalysisAnalyzerType.Snowball -> "snowball"
                | AnalysisAnalyzerType.Sorani -> "sorani"
                | AnalysisAnalyzerType.Spanish -> "spanish"
                | AnalysisAnalyzerType.Standard -> "standard"
                | AnalysisAnalyzerType.Stop -> "stop"
                | AnalysisAnalyzerType.Swedish -> "swedish"
                | AnalysisAnalyzerType.Thai -> "thai"
                | AnalysisAnalyzerType.Turkish -> "turkish"
                | AnalysisAnalyzerType.Whitespace -> "whitespace"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "arabic" -> AnalysisAnalyzerType.Arabic
            | "armenian" -> AnalysisAnalyzerType.Armenian
            | "basque" -> AnalysisAnalyzerType.Basque
            | "bengali" -> AnalysisAnalyzerType.Bengali
            | "brazilian" -> AnalysisAnalyzerType.Brazilian
            | "bulgarian" -> AnalysisAnalyzerType.Bulgarian
            | "catalan" -> AnalysisAnalyzerType.Catalan
            | "chinese" -> AnalysisAnalyzerType.Chinese
            | "cjk" -> AnalysisAnalyzerType.Cjk
            | "custom" -> AnalysisAnalyzerType.Custom
            | "czech" -> AnalysisAnalyzerType.Czech
            | "danish" -> AnalysisAnalyzerType.Danish
            | "dutch" -> AnalysisAnalyzerType.Dutch
            | "english" -> AnalysisAnalyzerType.English
            | "estonian" -> AnalysisAnalyzerType.Estonian
            | "fingerprint" -> AnalysisAnalyzerType.Fingerprint
            | "finnish" -> AnalysisAnalyzerType.Finnish
            | "french" -> AnalysisAnalyzerType.French
            | "galician" -> AnalysisAnalyzerType.Galician
            | "german" -> AnalysisAnalyzerType.German
            | "greek" -> AnalysisAnalyzerType.Greek
            | "hindi" -> AnalysisAnalyzerType.Hindi
            | "hungarian" -> AnalysisAnalyzerType.Hungarian
            | "icu_analyzer" -> AnalysisAnalyzerType.IcuAnalyzer
            | "indonesian" -> AnalysisAnalyzerType.Indonesian
            | "irish" -> AnalysisAnalyzerType.Irish
            | "italian" -> AnalysisAnalyzerType.Italian
            | "keyword" -> AnalysisAnalyzerType.Keyword
            | "kuromoji" -> AnalysisAnalyzerType.Kuromoji
            | "latvian" -> AnalysisAnalyzerType.Latvian
            | "lithuanian" -> AnalysisAnalyzerType.Lithuanian
            | "nori" -> AnalysisAnalyzerType.Nori
            | "norwegian" -> AnalysisAnalyzerType.Norwegian
            | "pattern" -> AnalysisAnalyzerType.Pattern
            | "persian" -> AnalysisAnalyzerType.Persian
            | "portuguese" -> AnalysisAnalyzerType.Portuguese
            | "romanian" -> AnalysisAnalyzerType.Romanian
            | "russian" -> AnalysisAnalyzerType.Russian
            | "serbian" -> AnalysisAnalyzerType.Serbian
            | "simple" -> AnalysisAnalyzerType.Simple
            | "snowball" -> AnalysisAnalyzerType.Snowball
            | "sorani" -> AnalysisAnalyzerType.Sorani
            | "spanish" -> AnalysisAnalyzerType.Spanish
            | "standard" -> AnalysisAnalyzerType.Standard
            | "stop" -> AnalysisAnalyzerType.Stop
            | "swedish" -> AnalysisAnalyzerType.Swedish
            | "thai" -> AnalysisAnalyzerType.Thai
            | "turkish" -> AnalysisAnalyzerType.Turkish
            | "whitespace" -> AnalysisAnalyzerType.Whitespace
            | s -> failwith $"Unknown AnalysisAnalyzerType: {s}"

    and [<JsonConverter(typeof<AnalysisAnalyzerTypeConverter>)>]
        AnalysisAnalyzerType =
        | Arabic
        | Armenian
        | Basque
        | Bengali
        | Brazilian
        | Bulgarian
        | Catalan
        | Chinese
        | Cjk
        | Custom
        | Czech
        | Danish
        | Dutch
        | English
        | Estonian
        | Fingerprint
        | Finnish
        | French
        | Galician
        | German
        | Greek
        | Hindi
        | Hungarian
        | IcuAnalyzer
        | Indonesian
        | Irish
        | Italian
        | Keyword
        | Kuromoji
        | Latvian
        | Lithuanian
        | Nori
        | Norwegian
        | Pattern
        | Persian
        | Portuguese
        | Romanian
        | Russian
        | Serbian
        | Simple
        | Snowball
        | Sorani
        | Spanish
        | Standard
        | Stop
        | Swedish
        | Thai
        | Turkish
        | Whitespace
        with
        override this.ToString() =
            match this with
            | Arabic -> "arabic"
            | Armenian -> "armenian"
            | Basque -> "basque"
            | Bengali -> "bengali"
            | Brazilian -> "brazilian"
            | Bulgarian -> "bulgarian"
            | Catalan -> "catalan"
            | Chinese -> "chinese"
            | Cjk -> "cjk"
            | Custom -> "custom"
            | Czech -> "czech"
            | Danish -> "danish"
            | Dutch -> "dutch"
            | English -> "english"
            | Estonian -> "estonian"
            | Fingerprint -> "fingerprint"
            | Finnish -> "finnish"
            | French -> "french"
            | Galician -> "galician"
            | German -> "german"
            | Greek -> "greek"
            | Hindi -> "hindi"
            | Hungarian -> "hungarian"
            | IcuAnalyzer -> "icu_analyzer"
            | Indonesian -> "indonesian"
            | Irish -> "irish"
            | Italian -> "italian"
            | Keyword -> "keyword"
            | Kuromoji -> "kuromoji"
            | Latvian -> "latvian"
            | Lithuanian -> "lithuanian"
            | Nori -> "nori"
            | Norwegian -> "norwegian"
            | Pattern -> "pattern"
            | Persian -> "persian"
            | Portuguese -> "portuguese"
            | Romanian -> "romanian"
            | Russian -> "russian"
            | Serbian -> "serbian"
            | Simple -> "simple"
            | Snowball -> "snowball"
            | Sorani -> "sorani"
            | Spanish -> "spanish"
            | Standard -> "standard"
            | Stop -> "stop"
            | Swedish -> "swedish"
            | Thai -> "thai"
            | Turkish -> "turkish"
            | Whitespace -> "whitespace"

    and AnalysisCharFilter = obj

    and AnalysisCustomNormalizer = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("char_filter")>]
        CharFilter: string array option
        [<JsonPropertyName("filter")>]
        Filter: string array option
    }

    and AnalysisLowercaseNormalizer = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisNormalizerConverter() =
        inherit JsonConverter<AnalysisNormalizer>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisNormalizer, options: JsonSerializerOptions) =
            match value with
            | AnalysisNormalizer.Custom v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisNormalizer.Lowercase v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "custom" -> AnalysisNormalizer.Custom (JsonSerializer.Deserialize<AnalysisCustomNormalizer>(json, options))
            | "lowercase" -> AnalysisNormalizer.Lowercase (JsonSerializer.Deserialize<AnalysisLowercaseNormalizer>(json, options))
            | s -> failwith $"Unknown AnalysisNormalizer type: {s}"

    and [<JsonConverter(typeof<AnalysisNormalizerConverter>)>]
        AnalysisNormalizer =
        | Custom of AnalysisCustomNormalizer
        | Lowercase of AnalysisLowercaseNormalizer

    and AnalysisNormalizerTypeConverter() =
        inherit JsonConverter<AnalysisNormalizerType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisNormalizerType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisNormalizerType.Custom -> "custom"
                | AnalysisNormalizerType.Lowercase -> "lowercase"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "custom" -> AnalysisNormalizerType.Custom
            | "lowercase" -> AnalysisNormalizerType.Lowercase
            | s -> failwith $"Unknown AnalysisNormalizerType: {s}"

    and [<JsonConverter(typeof<AnalysisNormalizerTypeConverter>)>]
        AnalysisNormalizerType =
        | Custom
        | Lowercase
        with
        override this.ToString() =
            match this with
            | Custom -> "custom"
            | Lowercase -> "lowercase"

    and AnalysisTokenFilter = obj

    and AnalysisTokenizer = obj

    and TypesIndexSettingsAnalysis = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: Map<string, AnalysisAnalyzer> option
        [<JsonPropertyName("char_filter")>]
        CharFilter: Map<string, AnalysisCharFilter> option
        [<JsonPropertyName("filter")>]
        Filter: Map<string, AnalysisTokenFilter> option
        [<JsonPropertyName("normalizer")>]
        Normalizer: Map<string, AnalysisNormalizer> option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: Map<string, AnalysisTokenizer> option
    }

    and AnalysisCharFilterBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisHtmlStripCharFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("escaped_tags")>]
        EscapedTags: string array option
    }

    and AnalysisIcuNormalizationCharFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("mode")>]
        Mode: AnalysisIcuNormalizationMode option
        [<JsonPropertyName("name")>]
        Name: AnalysisIcuNormalizationType option
        [<JsonPropertyName("unicode_set_filter")>]
        UnicodeSetFilter: string option
    }

    and AnalysisKuromojiIterationMarkCharFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("normalize_kana")>]
        NormalizeKana: bool
        [<JsonPropertyName("normalize_kanji")>]
        NormalizeKanji: bool
    }

    and AnalysisMappingCharFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("mappings")>]
        Mappings: string array option
        [<JsonPropertyName("mappings_path")>]
        MappingsPath: string option
    }

    and AnalysisPatternReplaceCharFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("flags")>]
        Flags: string option
        [<JsonPropertyName("pattern")>]
        Pattern: string
        [<JsonPropertyName("replacement")>]
        Replacement: string option
    }

    and AnalysisCharFilterDefinitionConverter() =
        inherit JsonConverter<AnalysisCharFilterDefinition>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisCharFilterDefinition, options: JsonSerializerOptions) =
            match value with
            | AnalysisCharFilterDefinition.HtmlStrip v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisCharFilterDefinition.IcuNormalizer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisCharFilterDefinition.KuromojiIterationMark v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisCharFilterDefinition.Mapping v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisCharFilterDefinition.PatternReplace v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "html_strip" -> AnalysisCharFilterDefinition.HtmlStrip (JsonSerializer.Deserialize<AnalysisHtmlStripCharFilter>(json, options))
            | "icu_normalizer" -> AnalysisCharFilterDefinition.IcuNormalizer (JsonSerializer.Deserialize<AnalysisIcuNormalizationCharFilter>(json, options))
            | "kuromoji_iteration_mark" -> AnalysisCharFilterDefinition.KuromojiIterationMark (JsonSerializer.Deserialize<AnalysisKuromojiIterationMarkCharFilter>(json, options))
            | "mapping" -> AnalysisCharFilterDefinition.Mapping (JsonSerializer.Deserialize<AnalysisMappingCharFilter>(json, options))
            | "pattern_replace" -> AnalysisCharFilterDefinition.PatternReplace (JsonSerializer.Deserialize<AnalysisPatternReplaceCharFilter>(json, options))
            | s -> failwith $"Unknown AnalysisCharFilterDefinition type: {s}"

    and [<JsonConverter(typeof<AnalysisCharFilterDefinitionConverter>)>]
        AnalysisCharFilterDefinition =
        | HtmlStrip of AnalysisHtmlStripCharFilter
        | IcuNormalizer of AnalysisIcuNormalizationCharFilter
        | KuromojiIterationMark of AnalysisKuromojiIterationMarkCharFilter
        | Mapping of AnalysisMappingCharFilter
        | PatternReplace of AnalysisPatternReplaceCharFilter

    and AnalysisCharFilterDefinitionTypeConverter() =
        inherit JsonConverter<AnalysisCharFilterDefinitionType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisCharFilterDefinitionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisCharFilterDefinitionType.HtmlStrip -> "html_strip"
                | AnalysisCharFilterDefinitionType.IcuNormalizer -> "icu_normalizer"
                | AnalysisCharFilterDefinitionType.KuromojiIterationMark -> "kuromoji_iteration_mark"
                | AnalysisCharFilterDefinitionType.Mapping -> "mapping"
                | AnalysisCharFilterDefinitionType.PatternReplace -> "pattern_replace"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "html_strip" -> AnalysisCharFilterDefinitionType.HtmlStrip
            | "icu_normalizer" -> AnalysisCharFilterDefinitionType.IcuNormalizer
            | "kuromoji_iteration_mark" -> AnalysisCharFilterDefinitionType.KuromojiIterationMark
            | "mapping" -> AnalysisCharFilterDefinitionType.Mapping
            | "pattern_replace" -> AnalysisCharFilterDefinitionType.PatternReplace
            | s -> failwith $"Unknown AnalysisCharFilterDefinitionType: {s}"

    and [<JsonConverter(typeof<AnalysisCharFilterDefinitionTypeConverter>)>]
        AnalysisCharFilterDefinitionType =
        | HtmlStrip
        | IcuNormalizer
        | KuromojiIterationMark
        | Mapping
        | PatternReplace
        with
        override this.ToString() =
            match this with
            | HtmlStrip -> "html_strip"
            | IcuNormalizer -> "icu_normalizer"
            | KuromojiIterationMark -> "kuromoji_iteration_mark"
            | Mapping -> "mapping"
            | PatternReplace -> "pattern_replace"

    and AnalysisTokenFilterBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisApostropheTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisArabicNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisArabicStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisAsciiFoldingTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
    }

    and AnalysisBengaliNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisBrazilianStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisCjkBigramIgnoredScriptConverter() =
        inherit JsonConverter<AnalysisCjkBigramIgnoredScript>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisCjkBigramIgnoredScript, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisCjkBigramIgnoredScript.Han -> "han"
                | AnalysisCjkBigramIgnoredScript.Hangul -> "hangul"
                | AnalysisCjkBigramIgnoredScript.Hiragana -> "hiragana"
                | AnalysisCjkBigramIgnoredScript.Katakana -> "katakana"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "han" -> AnalysisCjkBigramIgnoredScript.Han
            | "hangul" -> AnalysisCjkBigramIgnoredScript.Hangul
            | "hiragana" -> AnalysisCjkBigramIgnoredScript.Hiragana
            | "katakana" -> AnalysisCjkBigramIgnoredScript.Katakana
            | s -> failwith $"Unknown AnalysisCjkBigramIgnoredScript: {s}"

    and [<JsonConverter(typeof<AnalysisCjkBigramIgnoredScriptConverter>)>]
        AnalysisCjkBigramIgnoredScript =
        | Han
        | Hangul
        | Hiragana
        | Katakana
        with
        override this.ToString() =
            match this with
            | Han -> "han"
            | Hangul -> "hangul"
            | Hiragana -> "hiragana"
            | Katakana -> "katakana"

    and AnalysisCjkBigramTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("ignored_scripts")>]
        IgnoredScripts: AnalysisCjkBigramIgnoredScript array option
        [<JsonPropertyName("output_unigrams")>]
        OutputUnigrams: bool option
    }

    and AnalysisCjkWidthTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisClassicTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisCommonGramsTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("common_words")>]
        CommonWords: string array option
        [<JsonPropertyName("common_words_path")>]
        CommonWordsPath: string option
        [<JsonPropertyName("ignore_case")>]
        IgnoreCase: bool option
        [<JsonPropertyName("query_mode")>]
        QueryMode: bool option
    }

    and AnalysisConditionTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("filter")>]
        Filter: string array
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and AnalysisCzechStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisDecimalDigitTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisDelimitedPayloadEncodingConverter() =
        inherit JsonConverter<AnalysisDelimitedPayloadEncoding>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisDelimitedPayloadEncoding, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisDelimitedPayloadEncoding.Int -> "int"
                | AnalysisDelimitedPayloadEncoding.Float -> "float"
                | AnalysisDelimitedPayloadEncoding.Identity -> "identity"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "int" -> AnalysisDelimitedPayloadEncoding.Int
            | "float" -> AnalysisDelimitedPayloadEncoding.Float
            | "identity" -> AnalysisDelimitedPayloadEncoding.Identity
            | s -> failwith $"Unknown AnalysisDelimitedPayloadEncoding: {s}"

    and [<JsonConverter(typeof<AnalysisDelimitedPayloadEncodingConverter>)>]
        AnalysisDelimitedPayloadEncoding =
        | Int
        | Float
        | Identity
        with
        override this.ToString() =
            match this with
            | Int -> "int"
            | Float -> "float"
            | Identity -> "identity"

    and AnalysisDelimitedPayloadTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("delimiter")>]
        Delimiter: string option
        [<JsonPropertyName("encoding")>]
        Encoding: AnalysisDelimitedPayloadEncoding option
    }

    and AnalysisCompoundWordTokenFilterBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("max_subword_size")>]
        MaxSubwordSize: float option
        [<JsonPropertyName("min_subword_size")>]
        MinSubwordSize: float option
        [<JsonPropertyName("min_word_size")>]
        MinWordSize: float option
        [<JsonPropertyName("only_longest_match")>]
        OnlyLongestMatch: bool option
        [<JsonPropertyName("word_list")>]
        WordList: string array option
        [<JsonPropertyName("word_list_path")>]
        WordListPath: string option
    }

    and AnalysisDictionaryDecompounderTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("max_subword_size")>]
        MaxSubwordSize: float option
        [<JsonPropertyName("min_subword_size")>]
        MinSubwordSize: float option
        [<JsonPropertyName("min_word_size")>]
        MinWordSize: float option
        [<JsonPropertyName("only_longest_match")>]
        OnlyLongestMatch: bool option
        [<JsonPropertyName("word_list")>]
        WordList: string array option
        [<JsonPropertyName("word_list_path")>]
        WordListPath: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisDutchStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisEdgeNGramSideConverter() =
        inherit JsonConverter<AnalysisEdgeNGramSide>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisEdgeNGramSide, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisEdgeNGramSide.Front -> "front"
                | AnalysisEdgeNGramSide.Back -> "back"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "front" -> AnalysisEdgeNGramSide.Front
            | "back" -> AnalysisEdgeNGramSide.Back
            | s -> failwith $"Unknown AnalysisEdgeNGramSide: {s}"

    and [<JsonConverter(typeof<AnalysisEdgeNGramSideConverter>)>]
        AnalysisEdgeNGramSide =
        | Front
        | Back
        with
        override this.ToString() =
            match this with
            | Front -> "front"
            | Back -> "back"

    and AnalysisEdgeNGramTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_gram")>]
        MaxGram: float option
        [<JsonPropertyName("min_gram")>]
        MinGram: float option
        [<JsonPropertyName("side")>]
        Side: AnalysisEdgeNGramSide option
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
    }

    and AnalysisElisionTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("articles")>]
        Articles: string array option
        [<JsonPropertyName("articles_path")>]
        ArticlesPath: string option
        [<JsonPropertyName("articles_case")>]
        ArticlesCase: Stringifiedboolean option
    }

    and AnalysisFingerprintTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_output_size")>]
        MaxOutputSize: float option
        [<JsonPropertyName("separator")>]
        Separator: string option
    }

    and AnalysisFlattenGraphTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisFrenchStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisGermanNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisGermanStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisHindiNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisHunspellTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("dedup")>]
        Dedup: bool option
        [<JsonPropertyName("dictionary")>]
        Dictionary: string option
        [<JsonPropertyName("locale")>]
        Locale: string
        [<JsonPropertyName("longest_only")>]
        LongestOnly: bool option
    }

    and AnalysisHyphenationDecompounderTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("max_subword_size")>]
        MaxSubwordSize: float option
        [<JsonPropertyName("min_subword_size")>]
        MinSubwordSize: float option
        [<JsonPropertyName("min_word_size")>]
        MinWordSize: float option
        [<JsonPropertyName("only_longest_match")>]
        OnlyLongestMatch: bool option
        [<JsonPropertyName("word_list")>]
        WordList: string array option
        [<JsonPropertyName("word_list_path")>]
        WordListPath: string option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("hyphenation_patterns_path")>]
        HyphenationPatternsPath: string
        [<JsonPropertyName("no_sub_matches")>]
        NoSubMatches: bool option
        [<JsonPropertyName("no_overlapping_matches")>]
        NoOverlappingMatches: bool option
    }

    and AnalysisIcuCollationAlternateConverter() =
        inherit JsonConverter<AnalysisIcuCollationAlternate>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuCollationAlternate, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuCollationAlternate.Shifted -> "shifted"
                | AnalysisIcuCollationAlternate.NonIgnorable -> "non_ignorable"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "shifted" -> AnalysisIcuCollationAlternate.Shifted
            | "non_ignorable" -> AnalysisIcuCollationAlternate.NonIgnorable
            | s -> failwith $"Unknown AnalysisIcuCollationAlternate: {s}"

    and [<JsonConverter(typeof<AnalysisIcuCollationAlternateConverter>)>]
        AnalysisIcuCollationAlternate =
        | Shifted
        | NonIgnorable
        with
        override this.ToString() =
            match this with
            | Shifted -> "shifted"
            | NonIgnorable -> "non_ignorable"

    and AnalysisIcuCollationCaseFirstConverter() =
        inherit JsonConverter<AnalysisIcuCollationCaseFirst>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuCollationCaseFirst, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuCollationCaseFirst.Lower -> "lower"
                | AnalysisIcuCollationCaseFirst.Upper -> "upper"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "lower" -> AnalysisIcuCollationCaseFirst.Lower
            | "upper" -> AnalysisIcuCollationCaseFirst.Upper
            | s -> failwith $"Unknown AnalysisIcuCollationCaseFirst: {s}"

    and [<JsonConverter(typeof<AnalysisIcuCollationCaseFirstConverter>)>]
        AnalysisIcuCollationCaseFirst =
        | Lower
        | Upper
        with
        override this.ToString() =
            match this with
            | Lower -> "lower"
            | Upper -> "upper"

    and AnalysisIcuCollationDecompositionConverter() =
        inherit JsonConverter<AnalysisIcuCollationDecomposition>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuCollationDecomposition, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuCollationDecomposition.No -> "no"
                | AnalysisIcuCollationDecomposition.Identical -> "identical"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "no" -> AnalysisIcuCollationDecomposition.No
            | "identical" -> AnalysisIcuCollationDecomposition.Identical
            | s -> failwith $"Unknown AnalysisIcuCollationDecomposition: {s}"

    and [<JsonConverter(typeof<AnalysisIcuCollationDecompositionConverter>)>]
        AnalysisIcuCollationDecomposition =
        | No
        | Identical
        with
        override this.ToString() =
            match this with
            | No -> "no"
            | Identical -> "identical"

    and AnalysisIcuCollationStrengthConverter() =
        inherit JsonConverter<AnalysisIcuCollationStrength>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuCollationStrength, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuCollationStrength.Primary -> "primary"
                | AnalysisIcuCollationStrength.Secondary -> "secondary"
                | AnalysisIcuCollationStrength.Tertiary -> "tertiary"
                | AnalysisIcuCollationStrength.Quaternary -> "quaternary"
                | AnalysisIcuCollationStrength.Identical -> "identical"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "primary" -> AnalysisIcuCollationStrength.Primary
            | "secondary" -> AnalysisIcuCollationStrength.Secondary
            | "tertiary" -> AnalysisIcuCollationStrength.Tertiary
            | "quaternary" -> AnalysisIcuCollationStrength.Quaternary
            | "identical" -> AnalysisIcuCollationStrength.Identical
            | s -> failwith $"Unknown AnalysisIcuCollationStrength: {s}"

    and [<JsonConverter(typeof<AnalysisIcuCollationStrengthConverter>)>]
        AnalysisIcuCollationStrength =
        | Primary
        | Secondary
        | Tertiary
        | Quaternary
        | Identical
        with
        override this.ToString() =
            match this with
            | Primary -> "primary"
            | Secondary -> "secondary"
            | Tertiary -> "tertiary"
            | Quaternary -> "quaternary"
            | Identical -> "identical"

    and AnalysisIcuCollationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("alternate")>]
        Alternate: AnalysisIcuCollationAlternate option
        [<JsonPropertyName("caseFirst")>]
        CaseFirst: AnalysisIcuCollationCaseFirst option
        [<JsonPropertyName("caseLevel")>]
        CaseLevel: bool option
        [<JsonPropertyName("country")>]
        Country: string option
        [<JsonPropertyName("decomposition")>]
        Decomposition: AnalysisIcuCollationDecomposition option
        [<JsonPropertyName("hiraganaQuaternaryMode")>]
        HiraganaQuaternaryMode: bool option
        [<JsonPropertyName("language")>]
        Language: string option
        [<JsonPropertyName("numeric")>]
        Numeric: bool option
        [<JsonPropertyName("rules")>]
        Rules: string option
        [<JsonPropertyName("strength")>]
        Strength: AnalysisIcuCollationStrength option
        [<JsonPropertyName("variableTop")>]
        VariableTop: string option
        [<JsonPropertyName("variant")>]
        Variant: string option
    }

    and AnalysisIcuFoldingTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("unicode_set_filter")>]
        UnicodeSetFilter: string
    }

    and AnalysisIcuNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("name")>]
        Name: AnalysisIcuNormalizationType
    }

    and AnalysisIcuTransformDirectionConverter() =
        inherit JsonConverter<AnalysisIcuTransformDirection>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisIcuTransformDirection, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisIcuTransformDirection.Forward -> "forward"
                | AnalysisIcuTransformDirection.Reverse -> "reverse"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "forward" -> AnalysisIcuTransformDirection.Forward
            | "reverse" -> AnalysisIcuTransformDirection.Reverse
            | s -> failwith $"Unknown AnalysisIcuTransformDirection: {s}"

    and [<JsonConverter(typeof<AnalysisIcuTransformDirectionConverter>)>]
        AnalysisIcuTransformDirection =
        | Forward
        | Reverse
        with
        override this.ToString() =
            match this with
            | Forward -> "forward"
            | Reverse -> "reverse"

    and AnalysisIcuTransformTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("dir")>]
        Dir: AnalysisIcuTransformDirection option
        [<JsonPropertyName("id")>]
        Id: string
    }

    and AnalysisIndicNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisJaStopTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
    }

    and AnalysisKStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisKeepTypesModeConverter() =
        inherit JsonConverter<AnalysisKeepTypesMode>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisKeepTypesMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisKeepTypesMode.Include -> "include"
                | AnalysisKeepTypesMode.Exclude -> "exclude"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "include" -> AnalysisKeepTypesMode.Include
            | "exclude" -> AnalysisKeepTypesMode.Exclude
            | s -> failwith $"Unknown AnalysisKeepTypesMode: {s}"

    and [<JsonConverter(typeof<AnalysisKeepTypesModeConverter>)>]
        AnalysisKeepTypesMode =
        | Include
        | Exclude
        with
        override this.ToString() =
            match this with
            | Include -> "include"
            | Exclude -> "exclude"

    and AnalysisKeepTypesTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("mode")>]
        Mode: AnalysisKeepTypesMode option
        [<JsonPropertyName("types")>]
        Types: string array
    }

    and AnalysisKeepWordsTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("keep_words")>]
        KeepWords: string array option
        [<JsonPropertyName("keep_words_case")>]
        KeepWordsCase: bool option
        [<JsonPropertyName("keep_words_path")>]
        KeepWordsPath: string option
    }

    and AnalysisKeywordMarkerTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("ignore_case")>]
        IgnoreCase: bool option
        [<JsonPropertyName("keywords")>]
        Keywords: System.Text.Json.JsonElement option
        [<JsonPropertyName("keywords_path")>]
        KeywordsPath: string option
        [<JsonPropertyName("keywords_pattern")>]
        KeywordsPattern: string option
    }

    and AnalysisKeywordRepeatTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisKuromojiPartOfSpeechTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stoptags")>]
        Stoptags: string array
    }

    and AnalysisKuromojiReadingFormTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("use_romaji")>]
        UseRomaji: bool
    }

    and AnalysisKuromojiStemmerTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("minimum_length")>]
        MinimumLength: float
    }

    and AnalysisLengthTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max")>]
        Max: float option
        [<JsonPropertyName("min")>]
        Min: float option
    }

    and AnalysisLimitTokenCountTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("consume_all_tokens")>]
        ConsumeAllTokens: bool option
        [<JsonPropertyName("max_token_count")>]
        MaxTokenCount: Stringifiedinteger option
    }

    and AnalysisLowercaseTokenFilterLanguagesConverter() =
        inherit JsonConverter<AnalysisLowercaseTokenFilterLanguages>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisLowercaseTokenFilterLanguages, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisLowercaseTokenFilterLanguages.Greek -> "greek"
                | AnalysisLowercaseTokenFilterLanguages.Irish -> "irish"
                | AnalysisLowercaseTokenFilterLanguages.Turkish -> "turkish"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "greek" -> AnalysisLowercaseTokenFilterLanguages.Greek
            | "irish" -> AnalysisLowercaseTokenFilterLanguages.Irish
            | "turkish" -> AnalysisLowercaseTokenFilterLanguages.Turkish
            | s -> failwith $"Unknown AnalysisLowercaseTokenFilterLanguages: {s}"

    and [<JsonConverter(typeof<AnalysisLowercaseTokenFilterLanguagesConverter>)>]
        AnalysisLowercaseTokenFilterLanguages =
        | Greek
        | Irish
        | Turkish
        with
        override this.ToString() =
            match this with
            | Greek -> "greek"
            | Irish -> "irish"
            | Turkish -> "turkish"

    and AnalysisLowercaseTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("language")>]
        Language: AnalysisLowercaseTokenFilterLanguages option
    }

    and AnalysisMinHashTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("bucket_count")>]
        BucketCount: float option
        [<JsonPropertyName("hash_count")>]
        HashCount: float option
        [<JsonPropertyName("hash_set_size")>]
        HashSetSize: float option
        [<JsonPropertyName("with_rotation")>]
        WithRotation: bool option
    }

    and AnalysisMultiplexerTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("filters")>]
        Filters: string array
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
    }

    and AnalysisNGramTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_gram")>]
        MaxGram: float option
        [<JsonPropertyName("min_gram")>]
        MinGram: float option
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
    }

    and AnalysisNoriPartOfSpeechTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("stoptags")>]
        Stoptags: string array option
    }

    and AnalysisPatternCaptureTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("patterns")>]
        Patterns: string array
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
    }

    and AnalysisPatternReplaceTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("all")>]
        All: bool option
        [<JsonPropertyName("flags")>]
        Flags: string option
        [<JsonPropertyName("pattern")>]
        Pattern: string
        [<JsonPropertyName("replacement")>]
        Replacement: string option
    }

    and AnalysisPersianNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisPersianStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisPhoneticEncoderConverter() =
        inherit JsonConverter<AnalysisPhoneticEncoder>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisPhoneticEncoder, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisPhoneticEncoder.Metaphone -> "metaphone"
                | AnalysisPhoneticEncoder.DoubleMetaphone -> "double_metaphone"
                | AnalysisPhoneticEncoder.Soundex -> "soundex"
                | AnalysisPhoneticEncoder.RefinedSoundex -> "refined_soundex"
                | AnalysisPhoneticEncoder.Caverphone1 -> "caverphone1"
                | AnalysisPhoneticEncoder.Caverphone2 -> "caverphone2"
                | AnalysisPhoneticEncoder.Cologne -> "cologne"
                | AnalysisPhoneticEncoder.Nysiis -> "nysiis"
                | AnalysisPhoneticEncoder.Koelnerphonetik -> "koelnerphonetik"
                | AnalysisPhoneticEncoder.Haasephonetik -> "haasephonetik"
                | AnalysisPhoneticEncoder.BeiderMorse -> "beider_morse"
                | AnalysisPhoneticEncoder.DaitchMokotoff -> "daitch_mokotoff"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "metaphone" -> AnalysisPhoneticEncoder.Metaphone
            | "double_metaphone" -> AnalysisPhoneticEncoder.DoubleMetaphone
            | "soundex" -> AnalysisPhoneticEncoder.Soundex
            | "refined_soundex" -> AnalysisPhoneticEncoder.RefinedSoundex
            | "caverphone1" -> AnalysisPhoneticEncoder.Caverphone1
            | "caverphone2" -> AnalysisPhoneticEncoder.Caverphone2
            | "cologne" -> AnalysisPhoneticEncoder.Cologne
            | "nysiis" -> AnalysisPhoneticEncoder.Nysiis
            | "koelnerphonetik" -> AnalysisPhoneticEncoder.Koelnerphonetik
            | "haasephonetik" -> AnalysisPhoneticEncoder.Haasephonetik
            | "beider_morse" -> AnalysisPhoneticEncoder.BeiderMorse
            | "daitch_mokotoff" -> AnalysisPhoneticEncoder.DaitchMokotoff
            | s -> failwith $"Unknown AnalysisPhoneticEncoder: {s}"

    and [<JsonConverter(typeof<AnalysisPhoneticEncoderConverter>)>]
        AnalysisPhoneticEncoder =
        | Metaphone
        | DoubleMetaphone
        | Soundex
        | RefinedSoundex
        | Caverphone1
        | Caverphone2
        | Cologne
        | Nysiis
        | Koelnerphonetik
        | Haasephonetik
        | BeiderMorse
        | DaitchMokotoff
        with
        override this.ToString() =
            match this with
            | Metaphone -> "metaphone"
            | DoubleMetaphone -> "double_metaphone"
            | Soundex -> "soundex"
            | RefinedSoundex -> "refined_soundex"
            | Caverphone1 -> "caverphone1"
            | Caverphone2 -> "caverphone2"
            | Cologne -> "cologne"
            | Nysiis -> "nysiis"
            | Koelnerphonetik -> "koelnerphonetik"
            | Haasephonetik -> "haasephonetik"
            | BeiderMorse -> "beider_morse"
            | DaitchMokotoff -> "daitch_mokotoff"

    and AnalysisPhoneticLanguageConverter() =
        inherit JsonConverter<AnalysisPhoneticLanguage>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisPhoneticLanguage, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisPhoneticLanguage.Any -> "any"
                | AnalysisPhoneticLanguage.Common -> "common"
                | AnalysisPhoneticLanguage.Cyrillic -> "cyrillic"
                | AnalysisPhoneticLanguage.English -> "english"
                | AnalysisPhoneticLanguage.French -> "french"
                | AnalysisPhoneticLanguage.German -> "german"
                | AnalysisPhoneticLanguage.Hebrew -> "hebrew"
                | AnalysisPhoneticLanguage.Hungarian -> "hungarian"
                | AnalysisPhoneticLanguage.Polish -> "polish"
                | AnalysisPhoneticLanguage.Romanian -> "romanian"
                | AnalysisPhoneticLanguage.Russian -> "russian"
                | AnalysisPhoneticLanguage.Spanish -> "spanish"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "any" -> AnalysisPhoneticLanguage.Any
            | "common" -> AnalysisPhoneticLanguage.Common
            | "cyrillic" -> AnalysisPhoneticLanguage.Cyrillic
            | "english" -> AnalysisPhoneticLanguage.English
            | "french" -> AnalysisPhoneticLanguage.French
            | "german" -> AnalysisPhoneticLanguage.German
            | "hebrew" -> AnalysisPhoneticLanguage.Hebrew
            | "hungarian" -> AnalysisPhoneticLanguage.Hungarian
            | "polish" -> AnalysisPhoneticLanguage.Polish
            | "romanian" -> AnalysisPhoneticLanguage.Romanian
            | "russian" -> AnalysisPhoneticLanguage.Russian
            | "spanish" -> AnalysisPhoneticLanguage.Spanish
            | s -> failwith $"Unknown AnalysisPhoneticLanguage: {s}"

    and [<JsonConverter(typeof<AnalysisPhoneticLanguageConverter>)>]
        AnalysisPhoneticLanguage =
        | Any
        | Common
        | Cyrillic
        | English
        | French
        | German
        | Hebrew
        | Hungarian
        | Polish
        | Romanian
        | Russian
        | Spanish
        with
        override this.ToString() =
            match this with
            | Any -> "any"
            | Common -> "common"
            | Cyrillic -> "cyrillic"
            | English -> "english"
            | French -> "french"
            | German -> "german"
            | Hebrew -> "hebrew"
            | Hungarian -> "hungarian"
            | Polish -> "polish"
            | Romanian -> "romanian"
            | Russian -> "russian"
            | Spanish -> "spanish"

    and AnalysisPhoneticNameTypeConverter() =
        inherit JsonConverter<AnalysisPhoneticNameType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisPhoneticNameType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisPhoneticNameType.Generic -> "generic"
                | AnalysisPhoneticNameType.Ashkenazi -> "ashkenazi"
                | AnalysisPhoneticNameType.Sephardic -> "sephardic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "generic" -> AnalysisPhoneticNameType.Generic
            | "ashkenazi" -> AnalysisPhoneticNameType.Ashkenazi
            | "sephardic" -> AnalysisPhoneticNameType.Sephardic
            | s -> failwith $"Unknown AnalysisPhoneticNameType: {s}"

    and [<JsonConverter(typeof<AnalysisPhoneticNameTypeConverter>)>]
        AnalysisPhoneticNameType =
        | Generic
        | Ashkenazi
        | Sephardic
        with
        override this.ToString() =
            match this with
            | Generic -> "generic"
            | Ashkenazi -> "ashkenazi"
            | Sephardic -> "sephardic"

    and AnalysisPhoneticRuleTypeConverter() =
        inherit JsonConverter<AnalysisPhoneticRuleType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisPhoneticRuleType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisPhoneticRuleType.Approx -> "approx"
                | AnalysisPhoneticRuleType.Exact -> "exact"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "approx" -> AnalysisPhoneticRuleType.Approx
            | "exact" -> AnalysisPhoneticRuleType.Exact
            | s -> failwith $"Unknown AnalysisPhoneticRuleType: {s}"

    and [<JsonConverter(typeof<AnalysisPhoneticRuleTypeConverter>)>]
        AnalysisPhoneticRuleType =
        | Approx
        | Exact
        with
        override this.ToString() =
            match this with
            | Approx -> "approx"
            | Exact -> "exact"

    and AnalysisPhoneticTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("encoder")>]
        Encoder: AnalysisPhoneticEncoder
        [<JsonPropertyName("languageset")>]
        Languageset: System.Text.Json.JsonElement option
        [<JsonPropertyName("max_code_len")>]
        MaxCodeLen: float option
        [<JsonPropertyName("name_type")>]
        NameType: AnalysisPhoneticNameType option
        [<JsonPropertyName("replace")>]
        Replace: bool option
        [<JsonPropertyName("rule_type")>]
        RuleType: AnalysisPhoneticRuleType option
    }

    and AnalysisPorterStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisPredicateTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and AnalysisRemoveDuplicatesTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisReverseTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisRussianStemTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisScandinavianFoldingTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisScandinavianNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisSerbianNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisShingleTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("filler_token")>]
        FillerToken: string option
        [<JsonPropertyName("max_shingle_size")>]
        MaxShingleSize: Stringifiedinteger option
        [<JsonPropertyName("min_shingle_size")>]
        MinShingleSize: Stringifiedinteger option
        [<JsonPropertyName("output_unigrams")>]
        OutputUnigrams: bool option
        [<JsonPropertyName("output_unigrams_if_no_shingles")>]
        OutputUnigramsIfNoShingles: bool option
        [<JsonPropertyName("token_separator")>]
        TokenSeparator: string option
    }

    and AnalysisSnowballTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("language")>]
        Language: AnalysisSnowballLanguage option
    }

    and AnalysisSoraniNormalizationTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisStemmerOverrideTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("rules")>]
        Rules: string array option
        [<JsonPropertyName("rules_path")>]
        RulesPath: string option
    }

    and AnalysisStemmerTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("language")>]
        Language: string option
    }

    and AnalysisStopTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("ignore_case")>]
        IgnoreCase: bool option
        [<JsonPropertyName("remove_trailing")>]
        RemoveTrailing: bool option
        [<JsonPropertyName("stopwords")>]
        Stopwords: AnalysisStopWords option
        [<JsonPropertyName("stopwords_path")>]
        StopwordsPath: string option
    }

    and AnalysisSynonymFormatConverter() =
        inherit JsonConverter<AnalysisSynonymFormat>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisSynonymFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisSynonymFormat.Solr -> "solr"
                | AnalysisSynonymFormat.Wordnet -> "wordnet"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "solr" -> AnalysisSynonymFormat.Solr
            | "wordnet" -> AnalysisSynonymFormat.Wordnet
            | s -> failwith $"Unknown AnalysisSynonymFormat: {s}"

    and [<JsonConverter(typeof<AnalysisSynonymFormatConverter>)>]
        AnalysisSynonymFormat =
        | Solr
        | Wordnet
        with
        override this.ToString() =
            match this with
            | Solr -> "solr"
            | Wordnet -> "wordnet"

    and AnalysisSynonymTokenFilterBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("expand")>]
        Expand: bool option
        [<JsonPropertyName("format")>]
        Format: AnalysisSynonymFormat option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("synonyms")>]
        Synonyms: string array option
        [<JsonPropertyName("synonyms_path")>]
        SynonymsPath: string option
        [<JsonPropertyName("synonyms_set")>]
        SynonymsSet: string option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: string option
        [<JsonPropertyName("updateable")>]
        Updateable: bool option
    }

    and AnalysisSynonymGraphTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("expand")>]
        Expand: bool option
        [<JsonPropertyName("format")>]
        Format: AnalysisSynonymFormat option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("synonyms")>]
        Synonyms: string array option
        [<JsonPropertyName("synonyms_path")>]
        SynonymsPath: string option
        [<JsonPropertyName("synonyms_set")>]
        SynonymsSet: string option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: string option
        [<JsonPropertyName("updateable")>]
        Updateable: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisSynonymTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("expand")>]
        Expand: bool option
        [<JsonPropertyName("format")>]
        Format: AnalysisSynonymFormat option
        [<JsonPropertyName("lenient")>]
        Lenient: bool option
        [<JsonPropertyName("synonyms")>]
        Synonyms: string array option
        [<JsonPropertyName("synonyms_path")>]
        SynonymsPath: string option
        [<JsonPropertyName("synonyms_set")>]
        SynonymsSet: string option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: string option
        [<JsonPropertyName("updateable")>]
        Updateable: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisTrimTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisTruncateTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("length")>]
        Length: float option
    }

    and AnalysisUniqueTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("only_on_same_position")>]
        OnlyOnSamePosition: bool option
    }

    and AnalysisUppercaseTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisWordDelimiterTokenFilterBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("catenate_all")>]
        CatenateAll: bool option
        [<JsonPropertyName("catenate_numbers")>]
        CatenateNumbers: bool option
        [<JsonPropertyName("catenate_words")>]
        CatenateWords: bool option
        [<JsonPropertyName("generate_number_parts")>]
        GenerateNumberParts: bool option
        [<JsonPropertyName("generate_word_parts")>]
        GenerateWordParts: bool option
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
        [<JsonPropertyName("protected_words")>]
        ProtectedWords: string array option
        [<JsonPropertyName("protected_words_path")>]
        ProtectedWordsPath: string option
        [<JsonPropertyName("split_on_case_change")>]
        SplitOnCaseChange: bool option
        [<JsonPropertyName("split_on_numerics")>]
        SplitOnNumerics: bool option
        [<JsonPropertyName("stem_english_possessive")>]
        StemEnglishPossessive: bool option
        [<JsonPropertyName("type_table")>]
        TypeTable: string array option
        [<JsonPropertyName("type_table_path")>]
        TypeTablePath: string option
    }

    and AnalysisWordDelimiterGraphTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("catenate_all")>]
        CatenateAll: bool option
        [<JsonPropertyName("catenate_numbers")>]
        CatenateNumbers: bool option
        [<JsonPropertyName("catenate_words")>]
        CatenateWords: bool option
        [<JsonPropertyName("generate_number_parts")>]
        GenerateNumberParts: bool option
        [<JsonPropertyName("generate_word_parts")>]
        GenerateWordParts: bool option
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
        [<JsonPropertyName("protected_words")>]
        ProtectedWords: string array option
        [<JsonPropertyName("protected_words_path")>]
        ProtectedWordsPath: string option
        [<JsonPropertyName("split_on_case_change")>]
        SplitOnCaseChange: bool option
        [<JsonPropertyName("split_on_numerics")>]
        SplitOnNumerics: bool option
        [<JsonPropertyName("stem_english_possessive")>]
        StemEnglishPossessive: bool option
        [<JsonPropertyName("type_table")>]
        TypeTable: string array option
        [<JsonPropertyName("type_table_path")>]
        TypeTablePath: string option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("adjust_offsets")>]
        AdjustOffsets: bool option
        [<JsonPropertyName("ignore_keywords")>]
        IgnoreKeywords: bool option
    }

    and AnalysisWordDelimiterTokenFilter = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("catenate_all")>]
        CatenateAll: bool option
        [<JsonPropertyName("catenate_numbers")>]
        CatenateNumbers: bool option
        [<JsonPropertyName("catenate_words")>]
        CatenateWords: bool option
        [<JsonPropertyName("generate_number_parts")>]
        GenerateNumberParts: bool option
        [<JsonPropertyName("generate_word_parts")>]
        GenerateWordParts: bool option
        [<JsonPropertyName("preserve_original")>]
        PreserveOriginal: Stringifiedboolean option
        [<JsonPropertyName("protected_words")>]
        ProtectedWords: string array option
        [<JsonPropertyName("protected_words_path")>]
        ProtectedWordsPath: string option
        [<JsonPropertyName("split_on_case_change")>]
        SplitOnCaseChange: bool option
        [<JsonPropertyName("split_on_numerics")>]
        SplitOnNumerics: bool option
        [<JsonPropertyName("stem_english_possessive")>]
        StemEnglishPossessive: bool option
        [<JsonPropertyName("type_table")>]
        TypeTable: string array option
        [<JsonPropertyName("type_table_path")>]
        TypeTablePath: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisTokenFilterDefinitionConverter() =
        inherit JsonConverter<AnalysisTokenFilterDefinition>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisTokenFilterDefinition, options: JsonSerializerOptions) =
            match value with
            | AnalysisTokenFilterDefinition.Apostrophe v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.ArabicNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.ArabicStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Asciifolding v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.BengaliNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.BrazilianStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.CjkBigram v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.CjkWidth v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Classic v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.CommonGrams v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Condition v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.CzechStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.DecimalDigit v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.DelimitedPayload v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.DictionaryDecompounder v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.DutchStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.EdgeNgram v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Elision v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Fingerprint v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.FlattenGraph v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.FrenchStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.GermanNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.GermanStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.HindiNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Hunspell v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.HyphenationDecompounder v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.IcuCollation v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.IcuFolding v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.IcuNormalizer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.IcuTransform v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.IndicNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.JaStop v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Keep v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KeepTypes v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KeywordMarker v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KeywordRepeat v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Kstem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KuromojiPartOfSpeech v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KuromojiReadingform v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.KuromojiStemmer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Length v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Limit v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Lowercase v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.MinHash v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Multiplexer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Ngram v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.NoriPartOfSpeech v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PatternCapture v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PatternReplace v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PersianNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PersianStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Phonetic v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PorterStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.PredicateTokenFilter v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.RemoveDuplicates v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Reverse v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.RussianStem v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.ScandinavianFolding v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.ScandinavianNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.SerbianNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Shingle v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Snowball v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.SoraniNormalization v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Stemmer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.StemmerOverride v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Stop v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Synonym v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.SynonymGraph v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Trim v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Truncate v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Unique v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.Uppercase v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.WordDelimiter v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenFilterDefinition.WordDelimiterGraph v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "apostrophe" -> AnalysisTokenFilterDefinition.Apostrophe (JsonSerializer.Deserialize<AnalysisApostropheTokenFilter>(json, options))
            | "arabic_normalization" -> AnalysisTokenFilterDefinition.ArabicNormalization (JsonSerializer.Deserialize<AnalysisArabicNormalizationTokenFilter>(json, options))
            | "arabic_stem" -> AnalysisTokenFilterDefinition.ArabicStem (JsonSerializer.Deserialize<AnalysisArabicStemTokenFilter>(json, options))
            | "asciifolding" -> AnalysisTokenFilterDefinition.Asciifolding (JsonSerializer.Deserialize<AnalysisAsciiFoldingTokenFilter>(json, options))
            | "bengali_normalization" -> AnalysisTokenFilterDefinition.BengaliNormalization (JsonSerializer.Deserialize<AnalysisBengaliNormalizationTokenFilter>(json, options))
            | "brazilian_stem" -> AnalysisTokenFilterDefinition.BrazilianStem (JsonSerializer.Deserialize<AnalysisBrazilianStemTokenFilter>(json, options))
            | "cjk_bigram" -> AnalysisTokenFilterDefinition.CjkBigram (JsonSerializer.Deserialize<AnalysisCjkBigramTokenFilter>(json, options))
            | "cjk_width" -> AnalysisTokenFilterDefinition.CjkWidth (JsonSerializer.Deserialize<AnalysisCjkWidthTokenFilter>(json, options))
            | "classic" -> AnalysisTokenFilterDefinition.Classic (JsonSerializer.Deserialize<AnalysisClassicTokenFilter>(json, options))
            | "common_grams" -> AnalysisTokenFilterDefinition.CommonGrams (JsonSerializer.Deserialize<AnalysisCommonGramsTokenFilter>(json, options))
            | "condition" -> AnalysisTokenFilterDefinition.Condition (JsonSerializer.Deserialize<AnalysisConditionTokenFilter>(json, options))
            | "czech_stem" -> AnalysisTokenFilterDefinition.CzechStem (JsonSerializer.Deserialize<AnalysisCzechStemTokenFilter>(json, options))
            | "decimal_digit" -> AnalysisTokenFilterDefinition.DecimalDigit (JsonSerializer.Deserialize<AnalysisDecimalDigitTokenFilter>(json, options))
            | "delimited_payload" -> AnalysisTokenFilterDefinition.DelimitedPayload (JsonSerializer.Deserialize<AnalysisDelimitedPayloadTokenFilter>(json, options))
            | "dictionary_decompounder" -> AnalysisTokenFilterDefinition.DictionaryDecompounder (JsonSerializer.Deserialize<AnalysisDictionaryDecompounderTokenFilter>(json, options))
            | "dutch_stem" -> AnalysisTokenFilterDefinition.DutchStem (JsonSerializer.Deserialize<AnalysisDutchStemTokenFilter>(json, options))
            | "edge_ngram" -> AnalysisTokenFilterDefinition.EdgeNgram (JsonSerializer.Deserialize<AnalysisEdgeNGramTokenFilter>(json, options))
            | "elision" -> AnalysisTokenFilterDefinition.Elision (JsonSerializer.Deserialize<AnalysisElisionTokenFilter>(json, options))
            | "fingerprint" -> AnalysisTokenFilterDefinition.Fingerprint (JsonSerializer.Deserialize<AnalysisFingerprintTokenFilter>(json, options))
            | "flatten_graph" -> AnalysisTokenFilterDefinition.FlattenGraph (JsonSerializer.Deserialize<AnalysisFlattenGraphTokenFilter>(json, options))
            | "french_stem" -> AnalysisTokenFilterDefinition.FrenchStem (JsonSerializer.Deserialize<AnalysisFrenchStemTokenFilter>(json, options))
            | "german_normalization" -> AnalysisTokenFilterDefinition.GermanNormalization (JsonSerializer.Deserialize<AnalysisGermanNormalizationTokenFilter>(json, options))
            | "german_stem" -> AnalysisTokenFilterDefinition.GermanStem (JsonSerializer.Deserialize<AnalysisGermanStemTokenFilter>(json, options))
            | "hindi_normalization" -> AnalysisTokenFilterDefinition.HindiNormalization (JsonSerializer.Deserialize<AnalysisHindiNormalizationTokenFilter>(json, options))
            | "hunspell" -> AnalysisTokenFilterDefinition.Hunspell (JsonSerializer.Deserialize<AnalysisHunspellTokenFilter>(json, options))
            | "hyphenation_decompounder" -> AnalysisTokenFilterDefinition.HyphenationDecompounder (JsonSerializer.Deserialize<AnalysisHyphenationDecompounderTokenFilter>(json, options))
            | "icu_collation" -> AnalysisTokenFilterDefinition.IcuCollation (JsonSerializer.Deserialize<AnalysisIcuCollationTokenFilter>(json, options))
            | "icu_folding" -> AnalysisTokenFilterDefinition.IcuFolding (JsonSerializer.Deserialize<AnalysisIcuFoldingTokenFilter>(json, options))
            | "icu_normalizer" -> AnalysisTokenFilterDefinition.IcuNormalizer (JsonSerializer.Deserialize<AnalysisIcuNormalizationTokenFilter>(json, options))
            | "icu_transform" -> AnalysisTokenFilterDefinition.IcuTransform (JsonSerializer.Deserialize<AnalysisIcuTransformTokenFilter>(json, options))
            | "indic_normalization" -> AnalysisTokenFilterDefinition.IndicNormalization (JsonSerializer.Deserialize<AnalysisIndicNormalizationTokenFilter>(json, options))
            | "ja_stop" -> AnalysisTokenFilterDefinition.JaStop (JsonSerializer.Deserialize<AnalysisJaStopTokenFilter>(json, options))
            | "keep" -> AnalysisTokenFilterDefinition.Keep (JsonSerializer.Deserialize<AnalysisKeepWordsTokenFilter>(json, options))
            | "keep_types" -> AnalysisTokenFilterDefinition.KeepTypes (JsonSerializer.Deserialize<AnalysisKeepTypesTokenFilter>(json, options))
            | "keyword_marker" -> AnalysisTokenFilterDefinition.KeywordMarker (JsonSerializer.Deserialize<AnalysisKeywordMarkerTokenFilter>(json, options))
            | "keyword_repeat" -> AnalysisTokenFilterDefinition.KeywordRepeat (JsonSerializer.Deserialize<AnalysisKeywordRepeatTokenFilter>(json, options))
            | "kstem" -> AnalysisTokenFilterDefinition.Kstem (JsonSerializer.Deserialize<AnalysisKStemTokenFilter>(json, options))
            | "kuromoji_part_of_speech" -> AnalysisTokenFilterDefinition.KuromojiPartOfSpeech (JsonSerializer.Deserialize<AnalysisKuromojiPartOfSpeechTokenFilter>(json, options))
            | "kuromoji_readingform" -> AnalysisTokenFilterDefinition.KuromojiReadingform (JsonSerializer.Deserialize<AnalysisKuromojiReadingFormTokenFilter>(json, options))
            | "kuromoji_stemmer" -> AnalysisTokenFilterDefinition.KuromojiStemmer (JsonSerializer.Deserialize<AnalysisKuromojiStemmerTokenFilter>(json, options))
            | "length" -> AnalysisTokenFilterDefinition.Length (JsonSerializer.Deserialize<AnalysisLengthTokenFilter>(json, options))
            | "limit" -> AnalysisTokenFilterDefinition.Limit (JsonSerializer.Deserialize<AnalysisLimitTokenCountTokenFilter>(json, options))
            | "lowercase" -> AnalysisTokenFilterDefinition.Lowercase (JsonSerializer.Deserialize<AnalysisLowercaseTokenFilter>(json, options))
            | "min_hash" -> AnalysisTokenFilterDefinition.MinHash (JsonSerializer.Deserialize<AnalysisMinHashTokenFilter>(json, options))
            | "multiplexer" -> AnalysisTokenFilterDefinition.Multiplexer (JsonSerializer.Deserialize<AnalysisMultiplexerTokenFilter>(json, options))
            | "ngram" -> AnalysisTokenFilterDefinition.Ngram (JsonSerializer.Deserialize<AnalysisNGramTokenFilter>(json, options))
            | "nori_part_of_speech" -> AnalysisTokenFilterDefinition.NoriPartOfSpeech (JsonSerializer.Deserialize<AnalysisNoriPartOfSpeechTokenFilter>(json, options))
            | "pattern_capture" -> AnalysisTokenFilterDefinition.PatternCapture (JsonSerializer.Deserialize<AnalysisPatternCaptureTokenFilter>(json, options))
            | "pattern_replace" -> AnalysisTokenFilterDefinition.PatternReplace (JsonSerializer.Deserialize<AnalysisPatternReplaceTokenFilter>(json, options))
            | "persian_normalization" -> AnalysisTokenFilterDefinition.PersianNormalization (JsonSerializer.Deserialize<AnalysisPersianNormalizationTokenFilter>(json, options))
            | "persian_stem" -> AnalysisTokenFilterDefinition.PersianStem (JsonSerializer.Deserialize<AnalysisPersianStemTokenFilter>(json, options))
            | "phonetic" -> AnalysisTokenFilterDefinition.Phonetic (JsonSerializer.Deserialize<AnalysisPhoneticTokenFilter>(json, options))
            | "porter_stem" -> AnalysisTokenFilterDefinition.PorterStem (JsonSerializer.Deserialize<AnalysisPorterStemTokenFilter>(json, options))
            | "predicate_token_filter" -> AnalysisTokenFilterDefinition.PredicateTokenFilter (JsonSerializer.Deserialize<AnalysisPredicateTokenFilter>(json, options))
            | "remove_duplicates" -> AnalysisTokenFilterDefinition.RemoveDuplicates (JsonSerializer.Deserialize<AnalysisRemoveDuplicatesTokenFilter>(json, options))
            | "reverse" -> AnalysisTokenFilterDefinition.Reverse (JsonSerializer.Deserialize<AnalysisReverseTokenFilter>(json, options))
            | "russian_stem" -> AnalysisTokenFilterDefinition.RussianStem (JsonSerializer.Deserialize<AnalysisRussianStemTokenFilter>(json, options))
            | "scandinavian_folding" -> AnalysisTokenFilterDefinition.ScandinavianFolding (JsonSerializer.Deserialize<AnalysisScandinavianFoldingTokenFilter>(json, options))
            | "scandinavian_normalization" -> AnalysisTokenFilterDefinition.ScandinavianNormalization (JsonSerializer.Deserialize<AnalysisScandinavianNormalizationTokenFilter>(json, options))
            | "serbian_normalization" -> AnalysisTokenFilterDefinition.SerbianNormalization (JsonSerializer.Deserialize<AnalysisSerbianNormalizationTokenFilter>(json, options))
            | "shingle" -> AnalysisTokenFilterDefinition.Shingle (JsonSerializer.Deserialize<AnalysisShingleTokenFilter>(json, options))
            | "snowball" -> AnalysisTokenFilterDefinition.Snowball (JsonSerializer.Deserialize<AnalysisSnowballTokenFilter>(json, options))
            | "sorani_normalization" -> AnalysisTokenFilterDefinition.SoraniNormalization (JsonSerializer.Deserialize<AnalysisSoraniNormalizationTokenFilter>(json, options))
            | "stemmer" -> AnalysisTokenFilterDefinition.Stemmer (JsonSerializer.Deserialize<AnalysisStemmerTokenFilter>(json, options))
            | "stemmer_override" -> AnalysisTokenFilterDefinition.StemmerOverride (JsonSerializer.Deserialize<AnalysisStemmerOverrideTokenFilter>(json, options))
            | "stop" -> AnalysisTokenFilterDefinition.Stop (JsonSerializer.Deserialize<AnalysisStopTokenFilter>(json, options))
            | "synonym" -> AnalysisTokenFilterDefinition.Synonym (JsonSerializer.Deserialize<AnalysisSynonymTokenFilter>(json, options))
            | "synonym_graph" -> AnalysisTokenFilterDefinition.SynonymGraph (JsonSerializer.Deserialize<AnalysisSynonymGraphTokenFilter>(json, options))
            | "trim" -> AnalysisTokenFilterDefinition.Trim (JsonSerializer.Deserialize<AnalysisTrimTokenFilter>(json, options))
            | "truncate" -> AnalysisTokenFilterDefinition.Truncate (JsonSerializer.Deserialize<AnalysisTruncateTokenFilter>(json, options))
            | "unique" -> AnalysisTokenFilterDefinition.Unique (JsonSerializer.Deserialize<AnalysisUniqueTokenFilter>(json, options))
            | "uppercase" -> AnalysisTokenFilterDefinition.Uppercase (JsonSerializer.Deserialize<AnalysisUppercaseTokenFilter>(json, options))
            | "word_delimiter" -> AnalysisTokenFilterDefinition.WordDelimiter (JsonSerializer.Deserialize<AnalysisWordDelimiterTokenFilter>(json, options))
            | "word_delimiter_graph" -> AnalysisTokenFilterDefinition.WordDelimiterGraph (JsonSerializer.Deserialize<AnalysisWordDelimiterGraphTokenFilter>(json, options))
            | s -> failwith $"Unknown AnalysisTokenFilterDefinition type: {s}"

    and [<JsonConverter(typeof<AnalysisTokenFilterDefinitionConverter>)>]
        AnalysisTokenFilterDefinition =
        | Apostrophe of AnalysisApostropheTokenFilter
        | ArabicNormalization of AnalysisArabicNormalizationTokenFilter
        | ArabicStem of AnalysisArabicStemTokenFilter
        | Asciifolding of AnalysisAsciiFoldingTokenFilter
        | BengaliNormalization of AnalysisBengaliNormalizationTokenFilter
        | BrazilianStem of AnalysisBrazilianStemTokenFilter
        | CjkBigram of AnalysisCjkBigramTokenFilter
        | CjkWidth of AnalysisCjkWidthTokenFilter
        | Classic of AnalysisClassicTokenFilter
        | CommonGrams of AnalysisCommonGramsTokenFilter
        | Condition of AnalysisConditionTokenFilter
        | CzechStem of AnalysisCzechStemTokenFilter
        | DecimalDigit of AnalysisDecimalDigitTokenFilter
        | DelimitedPayload of AnalysisDelimitedPayloadTokenFilter
        | DictionaryDecompounder of AnalysisDictionaryDecompounderTokenFilter
        | DutchStem of AnalysisDutchStemTokenFilter
        | EdgeNgram of AnalysisEdgeNGramTokenFilter
        | Elision of AnalysisElisionTokenFilter
        | Fingerprint of AnalysisFingerprintTokenFilter
        | FlattenGraph of AnalysisFlattenGraphTokenFilter
        | FrenchStem of AnalysisFrenchStemTokenFilter
        | GermanNormalization of AnalysisGermanNormalizationTokenFilter
        | GermanStem of AnalysisGermanStemTokenFilter
        | HindiNormalization of AnalysisHindiNormalizationTokenFilter
        | Hunspell of AnalysisHunspellTokenFilter
        | HyphenationDecompounder of AnalysisHyphenationDecompounderTokenFilter
        | IcuCollation of AnalysisIcuCollationTokenFilter
        | IcuFolding of AnalysisIcuFoldingTokenFilter
        | IcuNormalizer of AnalysisIcuNormalizationTokenFilter
        | IcuTransform of AnalysisIcuTransformTokenFilter
        | IndicNormalization of AnalysisIndicNormalizationTokenFilter
        | JaStop of AnalysisJaStopTokenFilter
        | Keep of AnalysisKeepWordsTokenFilter
        | KeepTypes of AnalysisKeepTypesTokenFilter
        | KeywordMarker of AnalysisKeywordMarkerTokenFilter
        | KeywordRepeat of AnalysisKeywordRepeatTokenFilter
        | Kstem of AnalysisKStemTokenFilter
        | KuromojiPartOfSpeech of AnalysisKuromojiPartOfSpeechTokenFilter
        | KuromojiReadingform of AnalysisKuromojiReadingFormTokenFilter
        | KuromojiStemmer of AnalysisKuromojiStemmerTokenFilter
        | Length of AnalysisLengthTokenFilter
        | Limit of AnalysisLimitTokenCountTokenFilter
        | Lowercase of AnalysisLowercaseTokenFilter
        | MinHash of AnalysisMinHashTokenFilter
        | Multiplexer of AnalysisMultiplexerTokenFilter
        | Ngram of AnalysisNGramTokenFilter
        | NoriPartOfSpeech of AnalysisNoriPartOfSpeechTokenFilter
        | PatternCapture of AnalysisPatternCaptureTokenFilter
        | PatternReplace of AnalysisPatternReplaceTokenFilter
        | PersianNormalization of AnalysisPersianNormalizationTokenFilter
        | PersianStem of AnalysisPersianStemTokenFilter
        | Phonetic of AnalysisPhoneticTokenFilter
        | PorterStem of AnalysisPorterStemTokenFilter
        | PredicateTokenFilter of AnalysisPredicateTokenFilter
        | RemoveDuplicates of AnalysisRemoveDuplicatesTokenFilter
        | Reverse of AnalysisReverseTokenFilter
        | RussianStem of AnalysisRussianStemTokenFilter
        | ScandinavianFolding of AnalysisScandinavianFoldingTokenFilter
        | ScandinavianNormalization of AnalysisScandinavianNormalizationTokenFilter
        | SerbianNormalization of AnalysisSerbianNormalizationTokenFilter
        | Shingle of AnalysisShingleTokenFilter
        | Snowball of AnalysisSnowballTokenFilter
        | SoraniNormalization of AnalysisSoraniNormalizationTokenFilter
        | Stemmer of AnalysisStemmerTokenFilter
        | StemmerOverride of AnalysisStemmerOverrideTokenFilter
        | Stop of AnalysisStopTokenFilter
        | Synonym of AnalysisSynonymTokenFilter
        | SynonymGraph of AnalysisSynonymGraphTokenFilter
        | Trim of AnalysisTrimTokenFilter
        | Truncate of AnalysisTruncateTokenFilter
        | Unique of AnalysisUniqueTokenFilter
        | Uppercase of AnalysisUppercaseTokenFilter
        | WordDelimiter of AnalysisWordDelimiterTokenFilter
        | WordDelimiterGraph of AnalysisWordDelimiterGraphTokenFilter

    and AnalysisTokenFilterDefinitionTypeConverter() =
        inherit JsonConverter<AnalysisTokenFilterDefinitionType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisTokenFilterDefinitionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisTokenFilterDefinitionType.Apostrophe -> "apostrophe"
                | AnalysisTokenFilterDefinitionType.ArabicNormalization -> "arabic_normalization"
                | AnalysisTokenFilterDefinitionType.ArabicStem -> "arabic_stem"
                | AnalysisTokenFilterDefinitionType.Asciifolding -> "asciifolding"
                | AnalysisTokenFilterDefinitionType.BengaliNormalization -> "bengali_normalization"
                | AnalysisTokenFilterDefinitionType.BrazilianStem -> "brazilian_stem"
                | AnalysisTokenFilterDefinitionType.CjkBigram -> "cjk_bigram"
                | AnalysisTokenFilterDefinitionType.CjkWidth -> "cjk_width"
                | AnalysisTokenFilterDefinitionType.Classic -> "classic"
                | AnalysisTokenFilterDefinitionType.CommonGrams -> "common_grams"
                | AnalysisTokenFilterDefinitionType.Condition -> "condition"
                | AnalysisTokenFilterDefinitionType.CzechStem -> "czech_stem"
                | AnalysisTokenFilterDefinitionType.DecimalDigit -> "decimal_digit"
                | AnalysisTokenFilterDefinitionType.DelimitedPayload -> "delimited_payload"
                | AnalysisTokenFilterDefinitionType.DictionaryDecompounder -> "dictionary_decompounder"
                | AnalysisTokenFilterDefinitionType.DutchStem -> "dutch_stem"
                | AnalysisTokenFilterDefinitionType.EdgeNgram -> "edge_ngram"
                | AnalysisTokenFilterDefinitionType.Elision -> "elision"
                | AnalysisTokenFilterDefinitionType.Fingerprint -> "fingerprint"
                | AnalysisTokenFilterDefinitionType.FlattenGraph -> "flatten_graph"
                | AnalysisTokenFilterDefinitionType.FrenchStem -> "french_stem"
                | AnalysisTokenFilterDefinitionType.GermanNormalization -> "german_normalization"
                | AnalysisTokenFilterDefinitionType.GermanStem -> "german_stem"
                | AnalysisTokenFilterDefinitionType.HindiNormalization -> "hindi_normalization"
                | AnalysisTokenFilterDefinitionType.Hunspell -> "hunspell"
                | AnalysisTokenFilterDefinitionType.HyphenationDecompounder -> "hyphenation_decompounder"
                | AnalysisTokenFilterDefinitionType.IcuCollation -> "icu_collation"
                | AnalysisTokenFilterDefinitionType.IcuFolding -> "icu_folding"
                | AnalysisTokenFilterDefinitionType.IcuNormalizer -> "icu_normalizer"
                | AnalysisTokenFilterDefinitionType.IcuTransform -> "icu_transform"
                | AnalysisTokenFilterDefinitionType.IndicNormalization -> "indic_normalization"
                | AnalysisTokenFilterDefinitionType.JaStop -> "ja_stop"
                | AnalysisTokenFilterDefinitionType.Keep -> "keep"
                | AnalysisTokenFilterDefinitionType.KeepTypes -> "keep_types"
                | AnalysisTokenFilterDefinitionType.KeywordMarker -> "keyword_marker"
                | AnalysisTokenFilterDefinitionType.KeywordRepeat -> "keyword_repeat"
                | AnalysisTokenFilterDefinitionType.Kstem -> "kstem"
                | AnalysisTokenFilterDefinitionType.KuromojiPartOfSpeech -> "kuromoji_part_of_speech"
                | AnalysisTokenFilterDefinitionType.KuromojiReadingform -> "kuromoji_readingform"
                | AnalysisTokenFilterDefinitionType.KuromojiStemmer -> "kuromoji_stemmer"
                | AnalysisTokenFilterDefinitionType.Length -> "length"
                | AnalysisTokenFilterDefinitionType.Limit -> "limit"
                | AnalysisTokenFilterDefinitionType.Lowercase -> "lowercase"
                | AnalysisTokenFilterDefinitionType.MinHash -> "min_hash"
                | AnalysisTokenFilterDefinitionType.Multiplexer -> "multiplexer"
                | AnalysisTokenFilterDefinitionType.Ngram -> "ngram"
                | AnalysisTokenFilterDefinitionType.NoriPartOfSpeech -> "nori_part_of_speech"
                | AnalysisTokenFilterDefinitionType.PatternCapture -> "pattern_capture"
                | AnalysisTokenFilterDefinitionType.PatternReplace -> "pattern_replace"
                | AnalysisTokenFilterDefinitionType.PersianNormalization -> "persian_normalization"
                | AnalysisTokenFilterDefinitionType.PersianStem -> "persian_stem"
                | AnalysisTokenFilterDefinitionType.Phonetic -> "phonetic"
                | AnalysisTokenFilterDefinitionType.PorterStem -> "porter_stem"
                | AnalysisTokenFilterDefinitionType.PredicateTokenFilter -> "predicate_token_filter"
                | AnalysisTokenFilterDefinitionType.RemoveDuplicates -> "remove_duplicates"
                | AnalysisTokenFilterDefinitionType.Reverse -> "reverse"
                | AnalysisTokenFilterDefinitionType.RussianStem -> "russian_stem"
                | AnalysisTokenFilterDefinitionType.ScandinavianFolding -> "scandinavian_folding"
                | AnalysisTokenFilterDefinitionType.ScandinavianNormalization -> "scandinavian_normalization"
                | AnalysisTokenFilterDefinitionType.SerbianNormalization -> "serbian_normalization"
                | AnalysisTokenFilterDefinitionType.Shingle -> "shingle"
                | AnalysisTokenFilterDefinitionType.Snowball -> "snowball"
                | AnalysisTokenFilterDefinitionType.SoraniNormalization -> "sorani_normalization"
                | AnalysisTokenFilterDefinitionType.Stemmer -> "stemmer"
                | AnalysisTokenFilterDefinitionType.StemmerOverride -> "stemmer_override"
                | AnalysisTokenFilterDefinitionType.Stop -> "stop"
                | AnalysisTokenFilterDefinitionType.Synonym -> "synonym"
                | AnalysisTokenFilterDefinitionType.SynonymGraph -> "synonym_graph"
                | AnalysisTokenFilterDefinitionType.Trim -> "trim"
                | AnalysisTokenFilterDefinitionType.Truncate -> "truncate"
                | AnalysisTokenFilterDefinitionType.Unique -> "unique"
                | AnalysisTokenFilterDefinitionType.Uppercase -> "uppercase"
                | AnalysisTokenFilterDefinitionType.WordDelimiter -> "word_delimiter"
                | AnalysisTokenFilterDefinitionType.WordDelimiterGraph -> "word_delimiter_graph"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "apostrophe" -> AnalysisTokenFilterDefinitionType.Apostrophe
            | "arabic_normalization" -> AnalysisTokenFilterDefinitionType.ArabicNormalization
            | "arabic_stem" -> AnalysisTokenFilterDefinitionType.ArabicStem
            | "asciifolding" -> AnalysisTokenFilterDefinitionType.Asciifolding
            | "bengali_normalization" -> AnalysisTokenFilterDefinitionType.BengaliNormalization
            | "brazilian_stem" -> AnalysisTokenFilterDefinitionType.BrazilianStem
            | "cjk_bigram" -> AnalysisTokenFilterDefinitionType.CjkBigram
            | "cjk_width" -> AnalysisTokenFilterDefinitionType.CjkWidth
            | "classic" -> AnalysisTokenFilterDefinitionType.Classic
            | "common_grams" -> AnalysisTokenFilterDefinitionType.CommonGrams
            | "condition" -> AnalysisTokenFilterDefinitionType.Condition
            | "czech_stem" -> AnalysisTokenFilterDefinitionType.CzechStem
            | "decimal_digit" -> AnalysisTokenFilterDefinitionType.DecimalDigit
            | "delimited_payload" -> AnalysisTokenFilterDefinitionType.DelimitedPayload
            | "dictionary_decompounder" -> AnalysisTokenFilterDefinitionType.DictionaryDecompounder
            | "dutch_stem" -> AnalysisTokenFilterDefinitionType.DutchStem
            | "edge_ngram" -> AnalysisTokenFilterDefinitionType.EdgeNgram
            | "elision" -> AnalysisTokenFilterDefinitionType.Elision
            | "fingerprint" -> AnalysisTokenFilterDefinitionType.Fingerprint
            | "flatten_graph" -> AnalysisTokenFilterDefinitionType.FlattenGraph
            | "french_stem" -> AnalysisTokenFilterDefinitionType.FrenchStem
            | "german_normalization" -> AnalysisTokenFilterDefinitionType.GermanNormalization
            | "german_stem" -> AnalysisTokenFilterDefinitionType.GermanStem
            | "hindi_normalization" -> AnalysisTokenFilterDefinitionType.HindiNormalization
            | "hunspell" -> AnalysisTokenFilterDefinitionType.Hunspell
            | "hyphenation_decompounder" -> AnalysisTokenFilterDefinitionType.HyphenationDecompounder
            | "icu_collation" -> AnalysisTokenFilterDefinitionType.IcuCollation
            | "icu_folding" -> AnalysisTokenFilterDefinitionType.IcuFolding
            | "icu_normalizer" -> AnalysisTokenFilterDefinitionType.IcuNormalizer
            | "icu_transform" -> AnalysisTokenFilterDefinitionType.IcuTransform
            | "indic_normalization" -> AnalysisTokenFilterDefinitionType.IndicNormalization
            | "ja_stop" -> AnalysisTokenFilterDefinitionType.JaStop
            | "keep" -> AnalysisTokenFilterDefinitionType.Keep
            | "keep_types" -> AnalysisTokenFilterDefinitionType.KeepTypes
            | "keyword_marker" -> AnalysisTokenFilterDefinitionType.KeywordMarker
            | "keyword_repeat" -> AnalysisTokenFilterDefinitionType.KeywordRepeat
            | "kstem" -> AnalysisTokenFilterDefinitionType.Kstem
            | "kuromoji_part_of_speech" -> AnalysisTokenFilterDefinitionType.KuromojiPartOfSpeech
            | "kuromoji_readingform" -> AnalysisTokenFilterDefinitionType.KuromojiReadingform
            | "kuromoji_stemmer" -> AnalysisTokenFilterDefinitionType.KuromojiStemmer
            | "length" -> AnalysisTokenFilterDefinitionType.Length
            | "limit" -> AnalysisTokenFilterDefinitionType.Limit
            | "lowercase" -> AnalysisTokenFilterDefinitionType.Lowercase
            | "min_hash" -> AnalysisTokenFilterDefinitionType.MinHash
            | "multiplexer" -> AnalysisTokenFilterDefinitionType.Multiplexer
            | "ngram" -> AnalysisTokenFilterDefinitionType.Ngram
            | "nori_part_of_speech" -> AnalysisTokenFilterDefinitionType.NoriPartOfSpeech
            | "pattern_capture" -> AnalysisTokenFilterDefinitionType.PatternCapture
            | "pattern_replace" -> AnalysisTokenFilterDefinitionType.PatternReplace
            | "persian_normalization" -> AnalysisTokenFilterDefinitionType.PersianNormalization
            | "persian_stem" -> AnalysisTokenFilterDefinitionType.PersianStem
            | "phonetic" -> AnalysisTokenFilterDefinitionType.Phonetic
            | "porter_stem" -> AnalysisTokenFilterDefinitionType.PorterStem
            | "predicate_token_filter" -> AnalysisTokenFilterDefinitionType.PredicateTokenFilter
            | "remove_duplicates" -> AnalysisTokenFilterDefinitionType.RemoveDuplicates
            | "reverse" -> AnalysisTokenFilterDefinitionType.Reverse
            | "russian_stem" -> AnalysisTokenFilterDefinitionType.RussianStem
            | "scandinavian_folding" -> AnalysisTokenFilterDefinitionType.ScandinavianFolding
            | "scandinavian_normalization" -> AnalysisTokenFilterDefinitionType.ScandinavianNormalization
            | "serbian_normalization" -> AnalysisTokenFilterDefinitionType.SerbianNormalization
            | "shingle" -> AnalysisTokenFilterDefinitionType.Shingle
            | "snowball" -> AnalysisTokenFilterDefinitionType.Snowball
            | "sorani_normalization" -> AnalysisTokenFilterDefinitionType.SoraniNormalization
            | "stemmer" -> AnalysisTokenFilterDefinitionType.Stemmer
            | "stemmer_override" -> AnalysisTokenFilterDefinitionType.StemmerOverride
            | "stop" -> AnalysisTokenFilterDefinitionType.Stop
            | "synonym" -> AnalysisTokenFilterDefinitionType.Synonym
            | "synonym_graph" -> AnalysisTokenFilterDefinitionType.SynonymGraph
            | "trim" -> AnalysisTokenFilterDefinitionType.Trim
            | "truncate" -> AnalysisTokenFilterDefinitionType.Truncate
            | "unique" -> AnalysisTokenFilterDefinitionType.Unique
            | "uppercase" -> AnalysisTokenFilterDefinitionType.Uppercase
            | "word_delimiter" -> AnalysisTokenFilterDefinitionType.WordDelimiter
            | "word_delimiter_graph" -> AnalysisTokenFilterDefinitionType.WordDelimiterGraph
            | s -> failwith $"Unknown AnalysisTokenFilterDefinitionType: {s}"

    and [<JsonConverter(typeof<AnalysisTokenFilterDefinitionTypeConverter>)>]
        AnalysisTokenFilterDefinitionType =
        | Apostrophe
        | ArabicNormalization
        | ArabicStem
        | Asciifolding
        | BengaliNormalization
        | BrazilianStem
        | CjkBigram
        | CjkWidth
        | Classic
        | CommonGrams
        | Condition
        | CzechStem
        | DecimalDigit
        | DelimitedPayload
        | DictionaryDecompounder
        | DutchStem
        | EdgeNgram
        | Elision
        | Fingerprint
        | FlattenGraph
        | FrenchStem
        | GermanNormalization
        | GermanStem
        | HindiNormalization
        | Hunspell
        | HyphenationDecompounder
        | IcuCollation
        | IcuFolding
        | IcuNormalizer
        | IcuTransform
        | IndicNormalization
        | JaStop
        | Keep
        | KeepTypes
        | KeywordMarker
        | KeywordRepeat
        | Kstem
        | KuromojiPartOfSpeech
        | KuromojiReadingform
        | KuromojiStemmer
        | Length
        | Limit
        | Lowercase
        | MinHash
        | Multiplexer
        | Ngram
        | NoriPartOfSpeech
        | PatternCapture
        | PatternReplace
        | PersianNormalization
        | PersianStem
        | Phonetic
        | PorterStem
        | PredicateTokenFilter
        | RemoveDuplicates
        | Reverse
        | RussianStem
        | ScandinavianFolding
        | ScandinavianNormalization
        | SerbianNormalization
        | Shingle
        | Snowball
        | SoraniNormalization
        | Stemmer
        | StemmerOverride
        | Stop
        | Synonym
        | SynonymGraph
        | Trim
        | Truncate
        | Unique
        | Uppercase
        | WordDelimiter
        | WordDelimiterGraph
        with
        override this.ToString() =
            match this with
            | Apostrophe -> "apostrophe"
            | ArabicNormalization -> "arabic_normalization"
            | ArabicStem -> "arabic_stem"
            | Asciifolding -> "asciifolding"
            | BengaliNormalization -> "bengali_normalization"
            | BrazilianStem -> "brazilian_stem"
            | CjkBigram -> "cjk_bigram"
            | CjkWidth -> "cjk_width"
            | Classic -> "classic"
            | CommonGrams -> "common_grams"
            | Condition -> "condition"
            | CzechStem -> "czech_stem"
            | DecimalDigit -> "decimal_digit"
            | DelimitedPayload -> "delimited_payload"
            | DictionaryDecompounder -> "dictionary_decompounder"
            | DutchStem -> "dutch_stem"
            | EdgeNgram -> "edge_ngram"
            | Elision -> "elision"
            | Fingerprint -> "fingerprint"
            | FlattenGraph -> "flatten_graph"
            | FrenchStem -> "french_stem"
            | GermanNormalization -> "german_normalization"
            | GermanStem -> "german_stem"
            | HindiNormalization -> "hindi_normalization"
            | Hunspell -> "hunspell"
            | HyphenationDecompounder -> "hyphenation_decompounder"
            | IcuCollation -> "icu_collation"
            | IcuFolding -> "icu_folding"
            | IcuNormalizer -> "icu_normalizer"
            | IcuTransform -> "icu_transform"
            | IndicNormalization -> "indic_normalization"
            | JaStop -> "ja_stop"
            | Keep -> "keep"
            | KeepTypes -> "keep_types"
            | KeywordMarker -> "keyword_marker"
            | KeywordRepeat -> "keyword_repeat"
            | Kstem -> "kstem"
            | KuromojiPartOfSpeech -> "kuromoji_part_of_speech"
            | KuromojiReadingform -> "kuromoji_readingform"
            | KuromojiStemmer -> "kuromoji_stemmer"
            | Length -> "length"
            | Limit -> "limit"
            | Lowercase -> "lowercase"
            | MinHash -> "min_hash"
            | Multiplexer -> "multiplexer"
            | Ngram -> "ngram"
            | NoriPartOfSpeech -> "nori_part_of_speech"
            | PatternCapture -> "pattern_capture"
            | PatternReplace -> "pattern_replace"
            | PersianNormalization -> "persian_normalization"
            | PersianStem -> "persian_stem"
            | Phonetic -> "phonetic"
            | PorterStem -> "porter_stem"
            | PredicateTokenFilter -> "predicate_token_filter"
            | RemoveDuplicates -> "remove_duplicates"
            | Reverse -> "reverse"
            | RussianStem -> "russian_stem"
            | ScandinavianFolding -> "scandinavian_folding"
            | ScandinavianNormalization -> "scandinavian_normalization"
            | SerbianNormalization -> "serbian_normalization"
            | Shingle -> "shingle"
            | Snowball -> "snowball"
            | SoraniNormalization -> "sorani_normalization"
            | Stemmer -> "stemmer"
            | StemmerOverride -> "stemmer_override"
            | Stop -> "stop"
            | Synonym -> "synonym"
            | SynonymGraph -> "synonym_graph"
            | Trim -> "trim"
            | Truncate -> "truncate"
            | Unique -> "unique"
            | Uppercase -> "uppercase"
            | WordDelimiter -> "word_delimiter"
            | WordDelimiterGraph -> "word_delimiter_graph"

    and AnalysisTokenizerBase = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
    }

    and AnalysisCharGroupTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("tokenize_on_chars")>]
        TokenizeOnChars: string array
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
    }

    and AnalysisClassicTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
    }

    and AnalysisTokenCharConverter() =
        inherit JsonConverter<AnalysisTokenChar>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisTokenChar, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisTokenChar.Letter -> "letter"
                | AnalysisTokenChar.Digit -> "digit"
                | AnalysisTokenChar.Whitespace -> "whitespace"
                | AnalysisTokenChar.Punctuation -> "punctuation"
                | AnalysisTokenChar.Symbol -> "symbol"
                | AnalysisTokenChar.Custom -> "custom"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "letter" -> AnalysisTokenChar.Letter
            | "digit" -> AnalysisTokenChar.Digit
            | "whitespace" -> AnalysisTokenChar.Whitespace
            | "punctuation" -> AnalysisTokenChar.Punctuation
            | "symbol" -> AnalysisTokenChar.Symbol
            | "custom" -> AnalysisTokenChar.Custom
            | s -> failwith $"Unknown AnalysisTokenChar: {s}"

    and [<JsonConverter(typeof<AnalysisTokenCharConverter>)>]
        AnalysisTokenChar =
        | Letter
        | Digit
        | Whitespace
        | Punctuation
        | Symbol
        | Custom
        with
        override this.ToString() =
            match this with
            | Letter -> "letter"
            | Digit -> "digit"
            | Whitespace -> "whitespace"
            | Punctuation -> "punctuation"
            | Symbol -> "symbol"
            | Custom -> "custom"

    and AnalysisEdgeNGramTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("custom_token_chars")>]
        CustomTokenChars: string option
        [<JsonPropertyName("max_gram")>]
        MaxGram: float option
        [<JsonPropertyName("min_gram")>]
        MinGram: float option
        [<JsonPropertyName("token_chars")>]
        TokenChars: AnalysisTokenChar array option
    }

    and AnalysisIcuTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("rule_files")>]
        RuleFiles: string
    }

    and AnalysisKeywordTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("buffer_size")>]
        BufferSize: float option
    }

    and AnalysisKuromojiTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("discard_punctuation")>]
        DiscardPunctuation: bool option
        [<JsonPropertyName("mode")>]
        Mode: AnalysisKuromojiTokenizationMode
        [<JsonPropertyName("nbest_cost")>]
        NbestCost: float option
        [<JsonPropertyName("nbest_examples")>]
        NbestExamples: string option
        [<JsonPropertyName("user_dictionary")>]
        UserDictionary: string option
        [<JsonPropertyName("user_dictionary_rules")>]
        UserDictionaryRules: string array option
        [<JsonPropertyName("discard_compound_token")>]
        DiscardCompoundToken: bool option
    }

    and AnalysisLetterTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisLowercaseTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisNGramTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("custom_token_chars")>]
        CustomTokenChars: string option
        [<JsonPropertyName("max_gram")>]
        MaxGram: float option
        [<JsonPropertyName("min_gram")>]
        MinGram: float option
        [<JsonPropertyName("token_chars")>]
        TokenChars: AnalysisTokenChar array option
    }

    and AnalysisNoriTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("decompound_mode")>]
        DecompoundMode: AnalysisNoriDecompoundMode option
        [<JsonPropertyName("discard_punctuation")>]
        DiscardPunctuation: bool option
        [<JsonPropertyName("user_dictionary")>]
        UserDictionary: string option
        [<JsonPropertyName("user_dictionary_rules")>]
        UserDictionaryRules: string array option
    }

    and AnalysisPathHierarchyTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("buffer_size")>]
        BufferSize: Stringifiedinteger option
        [<JsonPropertyName("delimiter")>]
        Delimiter: string option
        [<JsonPropertyName("replacement")>]
        Replacement: string option
        [<JsonPropertyName("reverse")>]
        Reverse: Stringifiedboolean option
        [<JsonPropertyName("skip")>]
        Skip: Stringifiedinteger option
    }

    and AnalysisPatternTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("flags")>]
        Flags: string option
        [<JsonPropertyName("group")>]
        Group: float option
        [<JsonPropertyName("pattern")>]
        Pattern: string option
    }

    and AnalysisSimplePatternSplitTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("pattern")>]
        Pattern: string option
    }

    and AnalysisSimplePatternTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("pattern")>]
        Pattern: string option
    }

    and AnalysisStandardTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
    }

    and AnalysisThaiTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalysisUaxEmailUrlTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
    }

    and AnalysisWhitespaceTokenizer = {
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("max_token_length")>]
        MaxTokenLength: float option
    }

    and AnalysisTokenizerDefinitionConverter() =
        inherit JsonConverter<AnalysisTokenizerDefinition>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisTokenizerDefinition, options: JsonSerializerOptions) =
            match value with
            | AnalysisTokenizerDefinition.CharGroup v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Classic v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.EdgeNgram v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.IcuTokenizer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Keyword v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.KuromojiTokenizer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Letter v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Lowercase v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Ngram v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.NoriTokenizer v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.PathHierarchy v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Pattern v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.SimplePattern v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.SimplePatternSplit v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Standard v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Thai v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.UaxUrlEmail v -> JsonSerializer.Serialize(writer, v, options)
            | AnalysisTokenizerDefinition.Whitespace v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "char_group" -> AnalysisTokenizerDefinition.CharGroup (JsonSerializer.Deserialize<AnalysisCharGroupTokenizer>(json, options))
            | "classic" -> AnalysisTokenizerDefinition.Classic (JsonSerializer.Deserialize<AnalysisClassicTokenizer>(json, options))
            | "edge_ngram" -> AnalysisTokenizerDefinition.EdgeNgram (JsonSerializer.Deserialize<AnalysisEdgeNGramTokenizer>(json, options))
            | "icu_tokenizer" -> AnalysisTokenizerDefinition.IcuTokenizer (JsonSerializer.Deserialize<AnalysisIcuTokenizer>(json, options))
            | "keyword" -> AnalysisTokenizerDefinition.Keyword (JsonSerializer.Deserialize<AnalysisKeywordTokenizer>(json, options))
            | "kuromoji_tokenizer" -> AnalysisTokenizerDefinition.KuromojiTokenizer (JsonSerializer.Deserialize<AnalysisKuromojiTokenizer>(json, options))
            | "letter" -> AnalysisTokenizerDefinition.Letter (JsonSerializer.Deserialize<AnalysisLetterTokenizer>(json, options))
            | "lowercase" -> AnalysisTokenizerDefinition.Lowercase (JsonSerializer.Deserialize<AnalysisLowercaseTokenizer>(json, options))
            | "ngram" -> AnalysisTokenizerDefinition.Ngram (JsonSerializer.Deserialize<AnalysisNGramTokenizer>(json, options))
            | "nori_tokenizer" -> AnalysisTokenizerDefinition.NoriTokenizer (JsonSerializer.Deserialize<AnalysisNoriTokenizer>(json, options))
            | "path_hierarchy" -> AnalysisTokenizerDefinition.PathHierarchy (JsonSerializer.Deserialize<AnalysisPathHierarchyTokenizer>(json, options))
            | "pattern" -> AnalysisTokenizerDefinition.Pattern (JsonSerializer.Deserialize<AnalysisPatternTokenizer>(json, options))
            | "simple_pattern" -> AnalysisTokenizerDefinition.SimplePattern (JsonSerializer.Deserialize<AnalysisSimplePatternTokenizer>(json, options))
            | "simple_pattern_split" -> AnalysisTokenizerDefinition.SimplePatternSplit (JsonSerializer.Deserialize<AnalysisSimplePatternSplitTokenizer>(json, options))
            | "standard" -> AnalysisTokenizerDefinition.Standard (JsonSerializer.Deserialize<AnalysisStandardTokenizer>(json, options))
            | "thai" -> AnalysisTokenizerDefinition.Thai (JsonSerializer.Deserialize<AnalysisThaiTokenizer>(json, options))
            | "uax_url_email" -> AnalysisTokenizerDefinition.UaxUrlEmail (JsonSerializer.Deserialize<AnalysisUaxEmailUrlTokenizer>(json, options))
            | "whitespace" -> AnalysisTokenizerDefinition.Whitespace (JsonSerializer.Deserialize<AnalysisWhitespaceTokenizer>(json, options))
            | s -> failwith $"Unknown AnalysisTokenizerDefinition type: {s}"

    and [<JsonConverter(typeof<AnalysisTokenizerDefinitionConverter>)>]
        AnalysisTokenizerDefinition =
        | CharGroup of AnalysisCharGroupTokenizer
        | Classic of AnalysisClassicTokenizer
        | EdgeNgram of AnalysisEdgeNGramTokenizer
        | IcuTokenizer of AnalysisIcuTokenizer
        | Keyword of AnalysisKeywordTokenizer
        | KuromojiTokenizer of AnalysisKuromojiTokenizer
        | Letter of AnalysisLetterTokenizer
        | Lowercase of AnalysisLowercaseTokenizer
        | Ngram of AnalysisNGramTokenizer
        | NoriTokenizer of AnalysisNoriTokenizer
        | PathHierarchy of AnalysisPathHierarchyTokenizer
        | Pattern of AnalysisPatternTokenizer
        | SimplePattern of AnalysisSimplePatternTokenizer
        | SimplePatternSplit of AnalysisSimplePatternSplitTokenizer
        | Standard of AnalysisStandardTokenizer
        | Thai of AnalysisThaiTokenizer
        | UaxUrlEmail of AnalysisUaxEmailUrlTokenizer
        | Whitespace of AnalysisWhitespaceTokenizer

    and AnalysisTokenizerDefinitionTypeConverter() =
        inherit JsonConverter<AnalysisTokenizerDefinitionType>()

        override _.Write(writer: Utf8JsonWriter, value: AnalysisTokenizerDefinitionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AnalysisTokenizerDefinitionType.CharGroup -> "char_group"
                | AnalysisTokenizerDefinitionType.Classic -> "classic"
                | AnalysisTokenizerDefinitionType.EdgeNgram -> "edge_ngram"
                | AnalysisTokenizerDefinitionType.IcuTokenizer -> "icu_tokenizer"
                | AnalysisTokenizerDefinitionType.Keyword -> "keyword"
                | AnalysisTokenizerDefinitionType.KuromojiTokenizer -> "kuromoji_tokenizer"
                | AnalysisTokenizerDefinitionType.Letter -> "letter"
                | AnalysisTokenizerDefinitionType.Lowercase -> "lowercase"
                | AnalysisTokenizerDefinitionType.Ngram -> "ngram"
                | AnalysisTokenizerDefinitionType.NoriTokenizer -> "nori_tokenizer"
                | AnalysisTokenizerDefinitionType.PathHierarchy -> "path_hierarchy"
                | AnalysisTokenizerDefinitionType.Pattern -> "pattern"
                | AnalysisTokenizerDefinitionType.SimplePattern -> "simple_pattern"
                | AnalysisTokenizerDefinitionType.SimplePatternSplit -> "simple_pattern_split"
                | AnalysisTokenizerDefinitionType.Standard -> "standard"
                | AnalysisTokenizerDefinitionType.Thai -> "thai"
                | AnalysisTokenizerDefinitionType.UaxUrlEmail -> "uax_url_email"
                | AnalysisTokenizerDefinitionType.Whitespace -> "whitespace"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "char_group" -> AnalysisTokenizerDefinitionType.CharGroup
            | "classic" -> AnalysisTokenizerDefinitionType.Classic
            | "edge_ngram" -> AnalysisTokenizerDefinitionType.EdgeNgram
            | "icu_tokenizer" -> AnalysisTokenizerDefinitionType.IcuTokenizer
            | "keyword" -> AnalysisTokenizerDefinitionType.Keyword
            | "kuromoji_tokenizer" -> AnalysisTokenizerDefinitionType.KuromojiTokenizer
            | "letter" -> AnalysisTokenizerDefinitionType.Letter
            | "lowercase" -> AnalysisTokenizerDefinitionType.Lowercase
            | "ngram" -> AnalysisTokenizerDefinitionType.Ngram
            | "nori_tokenizer" -> AnalysisTokenizerDefinitionType.NoriTokenizer
            | "path_hierarchy" -> AnalysisTokenizerDefinitionType.PathHierarchy
            | "pattern" -> AnalysisTokenizerDefinitionType.Pattern
            | "simple_pattern" -> AnalysisTokenizerDefinitionType.SimplePattern
            | "simple_pattern_split" -> AnalysisTokenizerDefinitionType.SimplePatternSplit
            | "standard" -> AnalysisTokenizerDefinitionType.Standard
            | "thai" -> AnalysisTokenizerDefinitionType.Thai
            | "uax_url_email" -> AnalysisTokenizerDefinitionType.UaxUrlEmail
            | "whitespace" -> AnalysisTokenizerDefinitionType.Whitespace
            | s -> failwith $"Unknown AnalysisTokenizerDefinitionType: {s}"

    and [<JsonConverter(typeof<AnalysisTokenizerDefinitionTypeConverter>)>]
        AnalysisTokenizerDefinitionType =
        | CharGroup
        | Classic
        | EdgeNgram
        | IcuTokenizer
        | Keyword
        | KuromojiTokenizer
        | Letter
        | Lowercase
        | Ngram
        | NoriTokenizer
        | PathHierarchy
        | Pattern
        | SimplePattern
        | SimplePatternSplit
        | Standard
        | Thai
        | UaxUrlEmail
        | Whitespace
        with
        override this.ToString() =
            match this with
            | CharGroup -> "char_group"
            | Classic -> "classic"
            | EdgeNgram -> "edge_ngram"
            | IcuTokenizer -> "icu_tokenizer"
            | Keyword -> "keyword"
            | KuromojiTokenizer -> "kuromoji_tokenizer"
            | Letter -> "letter"
            | Lowercase -> "lowercase"
            | Ngram -> "ngram"
            | NoriTokenizer -> "nori_tokenizer"
            | PathHierarchy -> "path_hierarchy"
            | Pattern -> "pattern"
            | SimplePattern -> "simple_pattern"
            | SimplePatternSplit -> "simple_pattern_split"
            | Standard -> "standard"
            | Thai -> "thai"
            | UaxUrlEmail -> "uax_url_email"
            | Whitespace -> "whitespace"

    and TypesIndexSettingsTimeSeries = {
        [<JsonPropertyName("end_time")>]
        EndTime: DateTime option
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
    }

    and TypesCacheQueries = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and TypesQueries = {
        [<JsonPropertyName("cache")>]
        Cache: TypesCacheQueries option
    }

    and TypesSettingsSimilarityBm25 = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("b")>]
        B: float option
        [<JsonPropertyName("discount_overlaps")>]
        DiscountOverlaps: bool option
        [<JsonPropertyName("k1")>]
        K1: float option
    }

    and TypesSettingsSimilarityBoolean = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and DFIIndependenceMeasureConverter() =
        inherit JsonConverter<DFIIndependenceMeasure>()

        override _.Write(writer: Utf8JsonWriter, value: DFIIndependenceMeasure, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DFIIndependenceMeasure.Standardized -> "standardized"
                | DFIIndependenceMeasure.Saturated -> "saturated"
                | DFIIndependenceMeasure.Chisquared -> "chisquared"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "standardized" -> DFIIndependenceMeasure.Standardized
            | "saturated" -> DFIIndependenceMeasure.Saturated
            | "chisquared" -> DFIIndependenceMeasure.Chisquared
            | s -> failwith $"Unknown DFIIndependenceMeasure: {s}"

    and [<JsonConverter(typeof<DFIIndependenceMeasureConverter>)>]
        DFIIndependenceMeasure =
        | Standardized
        | Saturated
        | Chisquared
        with
        override this.ToString() =
            match this with
            | Standardized -> "standardized"
            | Saturated -> "saturated"
            | Chisquared -> "chisquared"

    and TypesSettingsSimilarityDfi = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("independence_measure")>]
        IndependenceMeasure: DFIIndependenceMeasure
    }

    and DFRAfterEffectConverter() =
        inherit JsonConverter<DFRAfterEffect>()

        override _.Write(writer: Utf8JsonWriter, value: DFRAfterEffect, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DFRAfterEffect.No -> "no"
                | DFRAfterEffect.B -> "b"
                | DFRAfterEffect.L -> "l"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "no" -> DFRAfterEffect.No
            | "b" -> DFRAfterEffect.B
            | "l" -> DFRAfterEffect.L
            | s -> failwith $"Unknown DFRAfterEffect: {s}"

    and [<JsonConverter(typeof<DFRAfterEffectConverter>)>]
        DFRAfterEffect =
        | No
        | B
        | L
        with
        override this.ToString() =
            match this with
            | No -> "no"
            | B -> "b"
            | L -> "l"

    and DFRBasicModelConverter() =
        inherit JsonConverter<DFRBasicModel>()

        override _.Write(writer: Utf8JsonWriter, value: DFRBasicModel, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DFRBasicModel.Be -> "be"
                | DFRBasicModel.D -> "d"
                | DFRBasicModel.G -> "g"
                | DFRBasicModel.If -> "if"
                | DFRBasicModel.In -> "in"
                | DFRBasicModel.Ine -> "ine"
                | DFRBasicModel.P -> "p"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "be" -> DFRBasicModel.Be
            | "d" -> DFRBasicModel.D
            | "g" -> DFRBasicModel.G
            | "if" -> DFRBasicModel.If
            | "in" -> DFRBasicModel.In
            | "ine" -> DFRBasicModel.Ine
            | "p" -> DFRBasicModel.P
            | s -> failwith $"Unknown DFRBasicModel: {s}"

    and [<JsonConverter(typeof<DFRBasicModelConverter>)>]
        DFRBasicModel =
        | Be
        | D
        | G
        | If
        | In
        | Ine
        | P
        with
        override this.ToString() =
            match this with
            | Be -> "be"
            | D -> "d"
            | G -> "g"
            | If -> "if"
            | In -> "in"
            | Ine -> "ine"
            | P -> "p"

    and NormalizationConverter() =
        inherit JsonConverter<Normalization>()

        override _.Write(writer: Utf8JsonWriter, value: Normalization, _options: JsonSerializerOptions) =
            let str =
                match value with
                | Normalization.No -> "no"
                | Normalization.H1 -> "h1"
                | Normalization.H2 -> "h2"
                | Normalization.H3 -> "h3"
                | Normalization.Z -> "z"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "no" -> Normalization.No
            | "h1" -> Normalization.H1
            | "h2" -> Normalization.H2
            | "h3" -> Normalization.H3
            | "z" -> Normalization.Z
            | s -> failwith $"Unknown Normalization: {s}"

    and [<JsonConverter(typeof<NormalizationConverter>)>]
        Normalization =
        | No
        | H1
        | H2
        | H3
        | Z
        with
        override this.ToString() =
            match this with
            | No -> "no"
            | H1 -> "h1"
            | H2 -> "h2"
            | H3 -> "h3"
            | Z -> "z"

    and TypesSettingsSimilarityDfr = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("after_effect")>]
        AfterEffect: DFRAfterEffect
        [<JsonPropertyName("basic_model")>]
        BasicModel: DFRBasicModel
        [<JsonPropertyName("normalization")>]
        Normalization: Normalization
    }

    and IBDistributionConverter() =
        inherit JsonConverter<IBDistribution>()

        override _.Write(writer: Utf8JsonWriter, value: IBDistribution, _options: JsonSerializerOptions) =
            let str =
                match value with
                | IBDistribution.Ll -> "ll"
                | IBDistribution.Spl -> "spl"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ll" -> IBDistribution.Ll
            | "spl" -> IBDistribution.Spl
            | s -> failwith $"Unknown IBDistribution: {s}"

    and [<JsonConverter(typeof<IBDistributionConverter>)>]
        IBDistribution =
        | Ll
        | Spl
        with
        override this.ToString() =
            match this with
            | Ll -> "ll"
            | Spl -> "spl"

    and IBLambdaConverter() =
        inherit JsonConverter<IBLambda>()

        override _.Write(writer: Utf8JsonWriter, value: IBLambda, _options: JsonSerializerOptions) =
            let str =
                match value with
                | IBLambda.Df -> "df"
                | IBLambda.Ttf -> "ttf"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "df" -> IBLambda.Df
            | "ttf" -> IBLambda.Ttf
            | s -> failwith $"Unknown IBLambda: {s}"

    and [<JsonConverter(typeof<IBLambdaConverter>)>]
        IBLambda =
        | Df
        | Ttf
        with
        override this.ToString() =
            match this with
            | Df -> "df"
            | Ttf -> "ttf"

    and TypesSettingsSimilarityIb = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("distribution")>]
        Distribution: IBDistribution
        [<JsonPropertyName("lambda")>]
        Lambda: IBLambda
        [<JsonPropertyName("normalization")>]
        Normalization: Normalization
    }

    and TypesSettingsSimilarityLmd = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("mu")>]
        Mu: float option
    }

    and TypesSettingsSimilarityLmj = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("lambda")>]
        Lambda: float option
    }

    and TypesSettingsSimilarityScripted = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("script")>]
        Script: Script
        [<JsonPropertyName("weight_script")>]
        WeightScript: Script option
    }

    and TypesSettingsSimilarityConverter() =
        inherit JsonConverter<TypesSettingsSimilarity>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSettingsSimilarity, options: JsonSerializerOptions) =
            match value with
            | TypesSettingsSimilarity.BM25 v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.DFI v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.DFR v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.IB v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.LMDirichlet v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.LMJelinekMercer v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.Boolean v -> JsonSerializer.Serialize(writer, v, options)
            | TypesSettingsSimilarity.Scripted v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "BM25" -> TypesSettingsSimilarity.BM25 (JsonSerializer.Deserialize<TypesSettingsSimilarityBm25>(json, options))
            | "DFI" -> TypesSettingsSimilarity.DFI (JsonSerializer.Deserialize<TypesSettingsSimilarityDfi>(json, options))
            | "DFR" -> TypesSettingsSimilarity.DFR (JsonSerializer.Deserialize<TypesSettingsSimilarityDfr>(json, options))
            | "IB" -> TypesSettingsSimilarity.IB (JsonSerializer.Deserialize<TypesSettingsSimilarityIb>(json, options))
            | "LMDirichlet" -> TypesSettingsSimilarity.LMDirichlet (JsonSerializer.Deserialize<TypesSettingsSimilarityLmd>(json, options))
            | "LMJelinekMercer" -> TypesSettingsSimilarity.LMJelinekMercer (JsonSerializer.Deserialize<TypesSettingsSimilarityLmj>(json, options))
            | "boolean" -> TypesSettingsSimilarity.Boolean (JsonSerializer.Deserialize<TypesSettingsSimilarityBoolean>(json, options))
            | "scripted" -> TypesSettingsSimilarity.Scripted (JsonSerializer.Deserialize<TypesSettingsSimilarityScripted>(json, options))
            | s -> failwith $"Unknown TypesSettingsSimilarity type: {s}"

    and [<JsonConverter(typeof<TypesSettingsSimilarityConverter>)>]
        TypesSettingsSimilarity =
        | BM25 of TypesSettingsSimilarityBm25
        | DFI of TypesSettingsSimilarityDfi
        | DFR of TypesSettingsSimilarityDfr
        | IB of TypesSettingsSimilarityIb
        | LMDirichlet of TypesSettingsSimilarityLmd
        | LMJelinekMercer of TypesSettingsSimilarityLmj
        | Boolean of TypesSettingsSimilarityBoolean
        | Scripted of TypesSettingsSimilarityScripted

    and TypesSettingsSimilarityTypeConverter() =
        inherit JsonConverter<TypesSettingsSimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSettingsSimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSettingsSimilarityType.BM25 -> "BM25"
                | TypesSettingsSimilarityType.DFI -> "DFI"
                | TypesSettingsSimilarityType.DFR -> "DFR"
                | TypesSettingsSimilarityType.IB -> "IB"
                | TypesSettingsSimilarityType.LMDirichlet -> "LMDirichlet"
                | TypesSettingsSimilarityType.LMJelinekMercer -> "LMJelinekMercer"
                | TypesSettingsSimilarityType.Boolean -> "boolean"
                | TypesSettingsSimilarityType.Scripted -> "scripted"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "BM25" -> TypesSettingsSimilarityType.BM25
            | "DFI" -> TypesSettingsSimilarityType.DFI
            | "DFR" -> TypesSettingsSimilarityType.DFR
            | "IB" -> TypesSettingsSimilarityType.IB
            | "LMDirichlet" -> TypesSettingsSimilarityType.LMDirichlet
            | "LMJelinekMercer" -> TypesSettingsSimilarityType.LMJelinekMercer
            | "boolean" -> TypesSettingsSimilarityType.Boolean
            | "scripted" -> TypesSettingsSimilarityType.Scripted
            | s -> failwith $"Unknown TypesSettingsSimilarityType: {s}"

    and [<JsonConverter(typeof<TypesSettingsSimilarityTypeConverter>)>]
        TypesSettingsSimilarityType =
        | BM25
        | DFI
        | DFR
        | IB
        | LMDirichlet
        | LMJelinekMercer
        | Boolean
        | Scripted
        with
        override this.ToString() =
            match this with
            | BM25 -> "BM25"
            | DFI -> "DFI"
            | DFR -> "DFR"
            | IB -> "IB"
            | LMDirichlet -> "LMDirichlet"
            | LMJelinekMercer -> "LMJelinekMercer"
            | Boolean -> "boolean"
            | Scripted -> "scripted"

    and TypesMappingLimitSettingsDepth = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesMappingLimitSettingsDimensionFields = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesMappingLimitSettingsFieldNameLength = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesMappingLimitSettingsNestedFields = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesMappingLimitSettingsNestedObjects = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesSourceModeConverter() =
        inherit JsonConverter<TypesSourceMode>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSourceMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSourceMode.Disabled -> "disabled"
                | TypesSourceMode.Stored -> "stored"
                | TypesSourceMode.Synthetic -> "synthetic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "disabled" -> TypesSourceMode.Disabled
            | "stored" -> TypesSourceMode.Stored
            | "synthetic" -> TypesSourceMode.Synthetic
            | s -> failwith $"Unknown TypesSourceMode: {s}"

    and [<JsonConverter(typeof<TypesSourceModeConverter>)>]
        TypesSourceMode =
        | Disabled
        | Stored
        | Synthetic
        with
        override this.ToString() =
            match this with
            | Disabled -> "disabled"
            | Stored -> "stored"
            | Synthetic -> "synthetic"

    and TypesMappingLimitSettingsSourceFields = {
        [<JsonPropertyName("mode")>]
        Mode: TypesSourceMode
    }

    and TypesMappingLimitSettingsTotalFields = {
        [<JsonPropertyName("limit")>]
        Limit: System.Text.Json.JsonElement option
        [<JsonPropertyName("ignore_dynamic_beyond_limit")>]
        IgnoreDynamicBeyondLimit: System.Text.Json.JsonElement option
    }

    /// <summary>
    /// Mapping Limit Settings
    /// </summary>
    and TypesMappingLimitSettings = {
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("total_fields")>]
        TotalFields: TypesMappingLimitSettingsTotalFields option
        [<JsonPropertyName("depth")>]
        Depth: TypesMappingLimitSettingsDepth option
        [<JsonPropertyName("nested_fields")>]
        NestedFields: TypesMappingLimitSettingsNestedFields option
        [<JsonPropertyName("nested_objects")>]
        NestedObjects: TypesMappingLimitSettingsNestedObjects option
        [<JsonPropertyName("field_name_length")>]
        FieldNameLength: TypesMappingLimitSettingsFieldNameLength option
        [<JsonPropertyName("dimension_fields")>]
        DimensionFields: TypesMappingLimitSettingsDimensionFields option
        [<JsonPropertyName("source")>]
        Source: TypesMappingLimitSettingsSourceFields option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: System.Text.Json.JsonElement option
    }

    and TypesIndexingSlowlogTresholds = {
        [<JsonPropertyName("index")>]
        Index: TypesSlowlogTresholdLevels option
    }

    and TypesIndexingSlowlogSettings = {
        [<JsonPropertyName("level")>]
        Level: string option
        [<JsonPropertyName("source")>]
        Source: float option
        [<JsonPropertyName("reformat")>]
        Reformat: bool option
        [<JsonPropertyName("threshold")>]
        Threshold: TypesIndexingSlowlogTresholds option
    }

    and TypesIndexingPressureMemory = {
        [<JsonPropertyName("limit")>]
        Limit: float option
    }

    and TypesIndexingPressure = {
        [<JsonPropertyName("memory")>]
        Memory: TypesIndexingPressureMemory
    }

    and TypesStorageType = obj

    and TypesStorage = {
        [<JsonPropertyName("type")>]
        Type: TypesStorageType
        [<JsonPropertyName("allow_mmap")>]
        AllowMmap: bool option
        [<JsonPropertyName("stats_refresh_interval")>]
        StatsRefreshInterval: Duration option
    }

    and FollowInfoFollowerIndexParameters = {
        [<JsonPropertyName("max_outstanding_read_requests")>]
        MaxOutstandingReadRequests: float option
        [<JsonPropertyName("max_outstanding_write_requests")>]
        MaxOutstandingWriteRequests: float option
        [<JsonPropertyName("max_read_request_operation_count")>]
        MaxReadRequestOperationCount: float option
        [<JsonPropertyName("max_read_request_size")>]
        MaxReadRequestSize: ByteSize option
        [<JsonPropertyName("max_retry_delay")>]
        MaxRetryDelay: Duration option
        [<JsonPropertyName("max_write_buffer_count")>]
        MaxWriteBufferCount: float option
        [<JsonPropertyName("max_write_buffer_size")>]
        MaxWriteBufferSize: ByteSize option
        [<JsonPropertyName("max_write_request_operation_count")>]
        MaxWriteRequestOperationCount: float option
        [<JsonPropertyName("max_write_request_size")>]
        MaxWriteRequestSize: ByteSize option
        [<JsonPropertyName("read_poll_timeout")>]
        ReadPollTimeout: Duration option
    }

    and FollowInfoFollowerIndexStatusConverter() =
        inherit JsonConverter<FollowInfoFollowerIndexStatus>()

        override _.Write(writer: Utf8JsonWriter, value: FollowInfoFollowerIndexStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | FollowInfoFollowerIndexStatus.Active -> "active"
                | FollowInfoFollowerIndexStatus.Paused -> "paused"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "active" -> FollowInfoFollowerIndexStatus.Active
            | "paused" -> FollowInfoFollowerIndexStatus.Paused
            | s -> failwith $"Unknown FollowInfoFollowerIndexStatus: {s}"

    and [<JsonConverter(typeof<FollowInfoFollowerIndexStatusConverter>)>]
        FollowInfoFollowerIndexStatus =
        | Active
        | Paused
        with
        override this.ToString() =
            match this with
            | Active -> "active"
            | Paused -> "paused"

    and FollowInfoFollowerIndex = {
        [<JsonPropertyName("follower_index")>]
        FollowerIndex: IndexName
        [<JsonPropertyName("leader_index")>]
        LeaderIndex: IndexName
        [<JsonPropertyName("parameters")>]
        Parameters: FollowInfoFollowerIndexParameters option
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: Name
        [<JsonPropertyName("status")>]
        Status: FollowInfoFollowerIndexStatus
    }

    and TypesReadException = {
        [<JsonPropertyName("exception")>]
        Exception: ErrorCause
        [<JsonPropertyName("from_seq_no")>]
        FromSeqNo: SequenceNumber
        [<JsonPropertyName("retries")>]
        Retries: float
    }

    and TypesShardStats = {
        [<JsonPropertyName("bytes_read")>]
        BytesRead: float
        [<JsonPropertyName("failed_read_requests")>]
        FailedReadRequests: float
        [<JsonPropertyName("failed_write_requests")>]
        FailedWriteRequests: float
        [<JsonPropertyName("fatal_exception")>]
        FatalException: ErrorCause option
        [<JsonPropertyName("follower_aliases_version")>]
        FollowerAliasesVersion: VersionNumber
        [<JsonPropertyName("follower_global_checkpoint")>]
        FollowerGlobalCheckpoint: float
        [<JsonPropertyName("follower_index")>]
        FollowerIndex: string
        [<JsonPropertyName("follower_mapping_version")>]
        FollowerMappingVersion: VersionNumber
        [<JsonPropertyName("follower_max_seq_no")>]
        FollowerMaxSeqNo: SequenceNumber
        [<JsonPropertyName("follower_settings_version")>]
        FollowerSettingsVersion: VersionNumber
        [<JsonPropertyName("last_requested_seq_no")>]
        LastRequestedSeqNo: SequenceNumber
        [<JsonPropertyName("leader_global_checkpoint")>]
        LeaderGlobalCheckpoint: float
        [<JsonPropertyName("leader_index")>]
        LeaderIndex: string
        [<JsonPropertyName("leader_max_seq_no")>]
        LeaderMaxSeqNo: SequenceNumber
        [<JsonPropertyName("operations_read")>]
        OperationsRead: float
        [<JsonPropertyName("operations_written")>]
        OperationsWritten: float
        [<JsonPropertyName("outstanding_read_requests")>]
        OutstandingReadRequests: float
        [<JsonPropertyName("outstanding_write_requests")>]
        OutstandingWriteRequests: float
        [<JsonPropertyName("read_exceptions")>]
        ReadExceptions: TypesReadException array
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: string
        [<JsonPropertyName("shard_id")>]
        ShardId: float
        [<JsonPropertyName("successful_read_requests")>]
        SuccessfulReadRequests: float
        [<JsonPropertyName("successful_write_requests")>]
        SuccessfulWriteRequests: float
        [<JsonPropertyName("time_since_last_read")>]
        TimeSinceLastRead: Duration option
        [<JsonPropertyName("time_since_last_read_millis")>]
        TimeSinceLastReadMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_read_remote_exec_time")>]
        TotalReadRemoteExecTime: Duration option
        [<JsonPropertyName("total_read_remote_exec_time_millis")>]
        TotalReadRemoteExecTimeMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_read_time")>]
        TotalReadTime: Duration option
        [<JsonPropertyName("total_read_time_millis")>]
        TotalReadTimeMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_write_time")>]
        TotalWriteTime: Duration option
        [<JsonPropertyName("total_write_time_millis")>]
        TotalWriteTimeMillis: DurationValueUnitMillis
        [<JsonPropertyName("write_buffer_operation_count")>]
        WriteBufferOperationCount: float
        [<JsonPropertyName("write_buffer_size_in_bytes")>]
        WriteBufferSizeInBytes: ByteSize
    }

    and TypesFollowIndexStats = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("shards")>]
        Shards: TypesShardStats array
    }

    and IndexPattern = string

    and IndexPatterns = IndexPattern array

    and GetAutoFollowPatternAutoFollowPatternSummary = {
        [<JsonPropertyName("active")>]
        Active: bool
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: string
        [<JsonPropertyName("follow_index_pattern")>]
        FollowIndexPattern: IndexPattern option
        [<JsonPropertyName("leader_index_patterns")>]
        LeaderIndexPatterns: IndexPatterns
        [<JsonPropertyName("leader_index_exclusion_patterns")>]
        LeaderIndexExclusionPatterns: IndexPatterns
        [<JsonPropertyName("max_outstanding_read_requests")>]
        MaxOutstandingReadRequests: float
    }

    and GetAutoFollowPatternAutoFollowPattern = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("pattern")>]
        Pattern: GetAutoFollowPatternAutoFollowPatternSummary
    }

    and StatsAutoFollowedCluster = {
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("last_seen_metadata_version")>]
        LastSeenMetadataVersion: VersionNumber
        [<JsonPropertyName("time_since_last_check_millis")>]
        TimeSinceLastCheckMillis: DurationValueUnitMillis
    }

    and StatsAutoFollowStats = {
        [<JsonPropertyName("auto_followed_clusters")>]
        AutoFollowedClusters: StatsAutoFollowedCluster array
        [<JsonPropertyName("number_of_failed_follow_indices")>]
        NumberOfFailedFollowIndices: float
        [<JsonPropertyName("number_of_failed_remote_cluster_state_requests")>]
        NumberOfFailedRemoteClusterStateRequests: float
        [<JsonPropertyName("number_of_successful_follow_indices")>]
        NumberOfSuccessfulFollowIndices: float
        [<JsonPropertyName("recent_auto_follow_errors")>]
        RecentAutoFollowErrors: ErrorCause array
    }

    and StatsFollowStats = {
        [<JsonPropertyName("indices")>]
        Indices: TypesFollowIndexStats array
    }

    and ScrollIds = obj

    and AllocationExplainDecisionConverter() =
        inherit JsonConverter<AllocationExplainDecision>()

        override _.Write(writer: Utf8JsonWriter, value: AllocationExplainDecision, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AllocationExplainDecision.Yes -> "yes"
                | AllocationExplainDecision.No -> "no"
                | AllocationExplainDecision.WorseBalance -> "worse_balance"
                | AllocationExplainDecision.Throttled -> "throttled"
                | AllocationExplainDecision.AwaitingInfo -> "awaiting_info"
                | AllocationExplainDecision.AllocationDelayed -> "allocation_delayed"
                | AllocationExplainDecision.NoValidShardCopy -> "no_valid_shard_copy"
                | AllocationExplainDecision.NoAttempt -> "no_attempt"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "yes" -> AllocationExplainDecision.Yes
            | "no" -> AllocationExplainDecision.No
            | "worse_balance" -> AllocationExplainDecision.WorseBalance
            | "throttled" -> AllocationExplainDecision.Throttled
            | "awaiting_info" -> AllocationExplainDecision.AwaitingInfo
            | "allocation_delayed" -> AllocationExplainDecision.AllocationDelayed
            | "no_valid_shard_copy" -> AllocationExplainDecision.NoValidShardCopy
            | "no_attempt" -> AllocationExplainDecision.NoAttempt
            | s -> failwith $"Unknown AllocationExplainDecision: {s}"

    and [<JsonConverter(typeof<AllocationExplainDecisionConverter>)>]
        AllocationExplainDecision =
        | Yes
        | No
        | WorseBalance
        | Throttled
        | AwaitingInfo
        | AllocationDelayed
        | NoValidShardCopy
        | NoAttempt
        with
        override this.ToString() =
            match this with
            | Yes -> "yes"
            | No -> "no"
            | WorseBalance -> "worse_balance"
            | Throttled -> "throttled"
            | AwaitingInfo -> "awaiting_info"
            | AllocationDelayed -> "allocation_delayed"
            | NoValidShardCopy -> "no_valid_shard_copy"
            | NoAttempt -> "no_attempt"

    and AllocationExplainAllocationExplainDecisionConverter() =
        inherit JsonConverter<AllocationExplainAllocationExplainDecision>()

        override _.Write(writer: Utf8JsonWriter, value: AllocationExplainAllocationExplainDecision, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AllocationExplainAllocationExplainDecision.NO -> "NO"
                | AllocationExplainAllocationExplainDecision.YES -> "YES"
                | AllocationExplainAllocationExplainDecision.THROTTLE -> "THROTTLE"
                | AllocationExplainAllocationExplainDecision.ALWAYS -> "ALWAYS"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "NO" -> AllocationExplainAllocationExplainDecision.NO
            | "YES" -> AllocationExplainAllocationExplainDecision.YES
            | "THROTTLE" -> AllocationExplainAllocationExplainDecision.THROTTLE
            | "ALWAYS" -> AllocationExplainAllocationExplainDecision.ALWAYS
            | s -> failwith $"Unknown AllocationExplainAllocationExplainDecision: {s}"

    and [<JsonConverter(typeof<AllocationExplainAllocationExplainDecisionConverter>)>]
        AllocationExplainAllocationExplainDecision =
        | NO
        | YES
        | THROTTLE
        | ALWAYS
        with
        override this.ToString() =
            match this with
            | NO -> "NO"
            | YES -> "YES"
            | THROTTLE -> "THROTTLE"
            | ALWAYS -> "ALWAYS"

    and AllocationExplainAllocationDecision = {
        [<JsonPropertyName("decider")>]
        Decider: string
        [<JsonPropertyName("decision")>]
        Decision: AllocationExplainAllocationExplainDecision
        [<JsonPropertyName("explanation")>]
        Explanation: string
    }

    and AllocationExplainDiskUsage = {
        [<JsonPropertyName("path")>]
        Path: string
        [<JsonPropertyName("total_bytes")>]
        TotalBytes: float
        [<JsonPropertyName("used_bytes")>]
        UsedBytes: float
        [<JsonPropertyName("free_bytes")>]
        FreeBytes: float
        [<JsonPropertyName("free_disk_percent")>]
        FreeDiskPercent: float
        [<JsonPropertyName("used_disk_percent")>]
        UsedDiskPercent: float
    }

    and AllocationExplainNodeDiskUsage = {
        [<JsonPropertyName("node_name")>]
        NodeName: Name
        [<JsonPropertyName("least_available")>]
        LeastAvailable: AllocationExplainDiskUsage
        [<JsonPropertyName("most_available")>]
        MostAvailable: AllocationExplainDiskUsage
    }

    and AllocationExplainReservedSize = {
        [<JsonPropertyName("node_id")>]
        NodeId: Id
        [<JsonPropertyName("path")>]
        Path: string
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("shards")>]
        Shards: string array
    }

    and AllocationExplainClusterInfo = {
        [<JsonPropertyName("nodes")>]
        Nodes: Map<string, AllocationExplainNodeDiskUsage>
        [<JsonPropertyName("shard_sizes")>]
        ShardSizes: Map<string, float>
        [<JsonPropertyName("shard_data_set_sizes")>]
        ShardDataSetSizes: Map<string, string> option
        [<JsonPropertyName("shard_paths")>]
        ShardPaths: Map<string, string>
        [<JsonPropertyName("reserved_sizes")>]
        ReservedSizes: AllocationExplainReservedSize array
    }

    and NodeRoleConverter() =
        inherit JsonConverter<NodeRole>()

        override _.Write(writer: Utf8JsonWriter, value: NodeRole, _options: JsonSerializerOptions) =
            let str =
                match value with
                | NodeRole.Master -> "master"
                | NodeRole.Data -> "data"
                | NodeRole.DataCold -> "data_cold"
                | NodeRole.DataContent -> "data_content"
                | NodeRole.DataFrozen -> "data_frozen"
                | NodeRole.DataHot -> "data_hot"
                | NodeRole.DataWarm -> "data_warm"
                | NodeRole.Client -> "client"
                | NodeRole.Ingest -> "ingest"
                | NodeRole.Ml -> "ml"
                | NodeRole.VotingOnly -> "voting_only"
                | NodeRole.Transform -> "transform"
                | NodeRole.RemoteClusterClient -> "remote_cluster_client"
                | NodeRole.CoordinatingOnly -> "coordinating_only"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "master" -> NodeRole.Master
            | "data" -> NodeRole.Data
            | "data_cold" -> NodeRole.DataCold
            | "data_content" -> NodeRole.DataContent
            | "data_frozen" -> NodeRole.DataFrozen
            | "data_hot" -> NodeRole.DataHot
            | "data_warm" -> NodeRole.DataWarm
            | "client" -> NodeRole.Client
            | "ingest" -> NodeRole.Ingest
            | "ml" -> NodeRole.Ml
            | "voting_only" -> NodeRole.VotingOnly
            | "transform" -> NodeRole.Transform
            | "remote_cluster_client" -> NodeRole.RemoteClusterClient
            | "coordinating_only" -> NodeRole.CoordinatingOnly
            | s -> failwith $"Unknown NodeRole: {s}"

    and [<JsonConverter(typeof<NodeRoleConverter>)>]
        NodeRole =
        | Master
        | Data
        | DataCold
        | DataContent
        | DataFrozen
        | DataHot
        | DataWarm
        | Client
        | Ingest
        | Ml
        | VotingOnly
        | Transform
        | RemoteClusterClient
        | CoordinatingOnly
        with
        override this.ToString() =
            match this with
            | Master -> "master"
            | Data -> "data"
            | DataCold -> "data_cold"
            | DataContent -> "data_content"
            | DataFrozen -> "data_frozen"
            | DataHot -> "data_hot"
            | DataWarm -> "data_warm"
            | Client -> "client"
            | Ingest -> "ingest"
            | Ml -> "ml"
            | VotingOnly -> "voting_only"
            | Transform -> "transform"
            | RemoteClusterClient -> "remote_cluster_client"
            | CoordinatingOnly -> "coordinating_only"

    and NodeRoles = NodeRole array

    and TransportAddress = string

    and AllocationExplainCurrentNode = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("weight_ranking")>]
        WeightRanking: float
    }

    and AllocationExplainAllocationStore = {
        [<JsonPropertyName("allocation_id")>]
        AllocationId: string
        [<JsonPropertyName("found")>]
        Found: bool
        [<JsonPropertyName("in_sync")>]
        InSync: bool
        [<JsonPropertyName("matching_size_in_bytes")>]
        MatchingSizeInBytes: float
        [<JsonPropertyName("matching_sync_id")>]
        MatchingSyncId: bool
        [<JsonPropertyName("store_exception")>]
        StoreException: string
    }

    and AllocationExplainNodeAllocationExplanation = {
        [<JsonPropertyName("deciders")>]
        Deciders: AllocationExplainAllocationDecision array option
        [<JsonPropertyName("node_attributes")>]
        NodeAttributes: Map<string, string>
        [<JsonPropertyName("node_decision")>]
        NodeDecision: AllocationExplainDecision
        [<JsonPropertyName("node_id")>]
        NodeId: Id
        [<JsonPropertyName("node_name")>]
        NodeName: Name
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles
        [<JsonPropertyName("store")>]
        Store: AllocationExplainAllocationStore option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("weight_ranking")>]
        WeightRanking: float option
    }

    and AllocationExplainUnassignedInformationReasonConverter() =
        inherit JsonConverter<AllocationExplainUnassignedInformationReason>()

        override _.Write(writer: Utf8JsonWriter, value: AllocationExplainUnassignedInformationReason, _options: JsonSerializerOptions) =
            let str =
                match value with
                | AllocationExplainUnassignedInformationReason.INDEXCREATED -> "INDEX_CREATED"
                | AllocationExplainUnassignedInformationReason.CLUSTERRECOVERED -> "CLUSTER_RECOVERED"
                | AllocationExplainUnassignedInformationReason.INDEXREOPENED -> "INDEX_REOPENED"
                | AllocationExplainUnassignedInformationReason.DANGLINGINDEXIMPORTED -> "DANGLING_INDEX_IMPORTED"
                | AllocationExplainUnassignedInformationReason.NEWINDEXRESTORED -> "NEW_INDEX_RESTORED"
                | AllocationExplainUnassignedInformationReason.EXISTINGINDEXRESTORED -> "EXISTING_INDEX_RESTORED"
                | AllocationExplainUnassignedInformationReason.REPLICAADDED -> "REPLICA_ADDED"
                | AllocationExplainUnassignedInformationReason.ALLOCATIONFAILED -> "ALLOCATION_FAILED"
                | AllocationExplainUnassignedInformationReason.NODELEFT -> "NODE_LEFT"
                | AllocationExplainUnassignedInformationReason.REROUTECANCELLED -> "REROUTE_CANCELLED"
                | AllocationExplainUnassignedInformationReason.REINITIALIZED -> "REINITIALIZED"
                | AllocationExplainUnassignedInformationReason.REALLOCATEDREPLICA -> "REALLOCATED_REPLICA"
                | AllocationExplainUnassignedInformationReason.PRIMARYFAILED -> "PRIMARY_FAILED"
                | AllocationExplainUnassignedInformationReason.FORCEDEMPTYPRIMARY -> "FORCED_EMPTY_PRIMARY"
                | AllocationExplainUnassignedInformationReason.MANUALALLOCATION -> "MANUAL_ALLOCATION"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "INDEX_CREATED" -> AllocationExplainUnassignedInformationReason.INDEXCREATED
            | "CLUSTER_RECOVERED" -> AllocationExplainUnassignedInformationReason.CLUSTERRECOVERED
            | "INDEX_REOPENED" -> AllocationExplainUnassignedInformationReason.INDEXREOPENED
            | "DANGLING_INDEX_IMPORTED" -> AllocationExplainUnassignedInformationReason.DANGLINGINDEXIMPORTED
            | "NEW_INDEX_RESTORED" -> AllocationExplainUnassignedInformationReason.NEWINDEXRESTORED
            | "EXISTING_INDEX_RESTORED" -> AllocationExplainUnassignedInformationReason.EXISTINGINDEXRESTORED
            | "REPLICA_ADDED" -> AllocationExplainUnassignedInformationReason.REPLICAADDED
            | "ALLOCATION_FAILED" -> AllocationExplainUnassignedInformationReason.ALLOCATIONFAILED
            | "NODE_LEFT" -> AllocationExplainUnassignedInformationReason.NODELEFT
            | "REROUTE_CANCELLED" -> AllocationExplainUnassignedInformationReason.REROUTECANCELLED
            | "REINITIALIZED" -> AllocationExplainUnassignedInformationReason.REINITIALIZED
            | "REALLOCATED_REPLICA" -> AllocationExplainUnassignedInformationReason.REALLOCATEDREPLICA
            | "PRIMARY_FAILED" -> AllocationExplainUnassignedInformationReason.PRIMARYFAILED
            | "FORCED_EMPTY_PRIMARY" -> AllocationExplainUnassignedInformationReason.FORCEDEMPTYPRIMARY
            | "MANUAL_ALLOCATION" -> AllocationExplainUnassignedInformationReason.MANUALALLOCATION
            | s -> failwith $"Unknown AllocationExplainUnassignedInformationReason: {s}"

    and [<JsonConverter(typeof<AllocationExplainUnassignedInformationReasonConverter>)>]
        AllocationExplainUnassignedInformationReason =
        | INDEXCREATED
        | CLUSTERRECOVERED
        | INDEXREOPENED
        | DANGLINGINDEXIMPORTED
        | NEWINDEXRESTORED
        | EXISTINGINDEXRESTORED
        | REPLICAADDED
        | ALLOCATIONFAILED
        | NODELEFT
        | REROUTECANCELLED
        | REINITIALIZED
        | REALLOCATEDREPLICA
        | PRIMARYFAILED
        | FORCEDEMPTYPRIMARY
        | MANUALALLOCATION
        with
        override this.ToString() =
            match this with
            | INDEXCREATED -> "INDEX_CREATED"
            | CLUSTERRECOVERED -> "CLUSTER_RECOVERED"
            | INDEXREOPENED -> "INDEX_REOPENED"
            | DANGLINGINDEXIMPORTED -> "DANGLING_INDEX_IMPORTED"
            | NEWINDEXRESTORED -> "NEW_INDEX_RESTORED"
            | EXISTINGINDEXRESTORED -> "EXISTING_INDEX_RESTORED"
            | REPLICAADDED -> "REPLICA_ADDED"
            | ALLOCATIONFAILED -> "ALLOCATION_FAILED"
            | NODELEFT -> "NODE_LEFT"
            | REROUTECANCELLED -> "REROUTE_CANCELLED"
            | REINITIALIZED -> "REINITIALIZED"
            | REALLOCATEDREPLICA -> "REALLOCATED_REPLICA"
            | PRIMARYFAILED -> "PRIMARY_FAILED"
            | FORCEDEMPTYPRIMARY -> "FORCED_EMPTY_PRIMARY"
            | MANUALALLOCATION -> "MANUAL_ALLOCATION"

    and AllocationExplainUnassignedInformation = {
        [<JsonPropertyName("at")>]
        At: DateTime
        [<JsonPropertyName("last_allocation_status")>]
        LastAllocationStatus: string option
        [<JsonPropertyName("reason")>]
        Reason: AllocationExplainUnassignedInformationReason
        [<JsonPropertyName("details")>]
        Details: string option
        [<JsonPropertyName("failed_allocation_attempts")>]
        FailedAllocationAttempts: float option
        [<JsonPropertyName("delayed")>]
        Delayed: bool option
        [<JsonPropertyName("allocation_status")>]
        AllocationStatus: string option
    }

    and MappingAllField = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: string
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("omit_norms")>]
        OmitNorms: bool
        [<JsonPropertyName("search_analyzer")>]
        SearchAnalyzer: string
        [<JsonPropertyName("similarity")>]
        Similarity: string
        [<JsonPropertyName("store")>]
        Store: bool
        [<JsonPropertyName("store_term_vector_offsets")>]
        StoreTermVectorOffsets: bool
        [<JsonPropertyName("store_term_vector_payloads")>]
        StoreTermVectorPayloads: bool
        [<JsonPropertyName("store_term_vector_positions")>]
        StoreTermVectorPositions: bool
        [<JsonPropertyName("store_term_vectors")>]
        StoreTermVectors: bool
    }

    and MappingDataStreamTimestamp = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and MappingDynamicMappingConverter() =
        inherit JsonConverter<MappingDynamicMapping>()

        override _.Write(writer: Utf8JsonWriter, value: MappingDynamicMapping, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingDynamicMapping.Strict -> "strict"
                | MappingDynamicMapping.Runtime -> "runtime"
                | MappingDynamicMapping.True -> "true"
                | MappingDynamicMapping.False -> "false"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "strict" -> MappingDynamicMapping.Strict
            | "runtime" -> MappingDynamicMapping.Runtime
            | "true" -> MappingDynamicMapping.True
            | "false" -> MappingDynamicMapping.False
            | s -> failwith $"Unknown MappingDynamicMapping: {s}"

    and [<JsonConverter(typeof<MappingDynamicMappingConverter>)>]
        MappingDynamicMapping =
        | Strict
        | Runtime
        | True
        | False
        with
        override this.ToString() =
            match this with
            | Strict -> "strict"
            | Runtime -> "runtime"
            | True -> "true"
            | False -> "false"

    and MappingMatchTypeConverter() =
        inherit JsonConverter<MappingMatchType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingMatchType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingMatchType.Simple -> "simple"
                | MappingMatchType.Regex -> "regex"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "simple" -> MappingMatchType.Simple
            | "regex" -> MappingMatchType.Regex
            | s -> failwith $"Unknown MappingMatchType: {s}"

    and [<JsonConverter(typeof<MappingMatchTypeConverter>)>]
        MappingMatchType =
        | Simple
        | Regex
        with
        override this.ToString() =
            match this with
            | Simple -> "simple"
            | Regex -> "regex"

    and MappingSyntheticSourceKeepEnumConverter() =
        inherit JsonConverter<MappingSyntheticSourceKeepEnum>()

        override _.Write(writer: Utf8JsonWriter, value: MappingSyntheticSourceKeepEnum, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingSyntheticSourceKeepEnum.None -> "none"
                | MappingSyntheticSourceKeepEnum.Arrays -> "arrays"
                | MappingSyntheticSourceKeepEnum.All -> "all"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> MappingSyntheticSourceKeepEnum.None
            | "arrays" -> MappingSyntheticSourceKeepEnum.Arrays
            | "all" -> MappingSyntheticSourceKeepEnum.All
            | s -> failwith $"Unknown MappingSyntheticSourceKeepEnum: {s}"

    and [<JsonConverter(typeof<MappingSyntheticSourceKeepEnumConverter>)>]
        MappingSyntheticSourceKeepEnum =
        | None
        | Arrays
        | All
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | Arrays -> "arrays"
            | All -> "all"

    and MappingPropertyBase = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
    }

    and MappingTimeSeriesMetricTypeConverter() =
        inherit JsonConverter<MappingTimeSeriesMetricType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingTimeSeriesMetricType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingTimeSeriesMetricType.Gauge -> "gauge"
                | MappingTimeSeriesMetricType.Counter -> "counter"
                | MappingTimeSeriesMetricType.Summary -> "summary"
                | MappingTimeSeriesMetricType.Histogram -> "histogram"
                | MappingTimeSeriesMetricType.Position -> "position"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "gauge" -> MappingTimeSeriesMetricType.Gauge
            | "counter" -> MappingTimeSeriesMetricType.Counter
            | "summary" -> MappingTimeSeriesMetricType.Summary
            | "histogram" -> MappingTimeSeriesMetricType.Histogram
            | "position" -> MappingTimeSeriesMetricType.Position
            | s -> failwith $"Unknown MappingTimeSeriesMetricType: {s}"

    and [<JsonConverter(typeof<MappingTimeSeriesMetricTypeConverter>)>]
        MappingTimeSeriesMetricType =
        | Gauge
        | Counter
        | Summary
        | Histogram
        | Position
        with
        override this.ToString() =
            match this with
            | Gauge -> "gauge"
            | Counter -> "counter"
            | Summary -> "summary"
            | Histogram -> "histogram"
            | Position -> "position"

    and MappingAggregateMetricDoubleProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("default_metric")>]
        DefaultMetric: string
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("metrics")>]
        Metrics: string array
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
    }

    and MappingCorePropertyBase = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
    }

    and MappingDocValuesPropertyBase = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
    }

    and MappingBinaryProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingOnScriptErrorConverter() =
        inherit JsonConverter<MappingOnScriptError>()

        override _.Write(writer: Utf8JsonWriter, value: MappingOnScriptError, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingOnScriptError.Fail -> "fail"
                | MappingOnScriptError.Continue -> "continue"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "fail" -> MappingOnScriptError.Fail
            | "continue" -> MappingOnScriptError.Continue
            | s -> failwith $"Unknown MappingOnScriptError: {s}"

    and [<JsonConverter(typeof<MappingOnScriptErrorConverter>)>]
        MappingOnScriptError =
        | Fail
        | Continue
        with
        override this.ToString() =
            match this with
            | Fail -> "fail"
            | Continue -> "continue"

    and TypesNumericFielddataFormatConverter() =
        inherit JsonConverter<TypesNumericFielddataFormat>()

        override _.Write(writer: Utf8JsonWriter, value: TypesNumericFielddataFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesNumericFielddataFormat.Array -> "array"
                | TypesNumericFielddataFormat.Disabled -> "disabled"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "array" -> TypesNumericFielddataFormat.Array
            | "disabled" -> TypesNumericFielddataFormat.Disabled
            | s -> failwith $"Unknown TypesNumericFielddataFormat: {s}"

    and [<JsonConverter(typeof<TypesNumericFielddataFormatConverter>)>]
        TypesNumericFielddataFormat =
        | Array
        | Disabled
        with
        override this.ToString() =
            match this with
            | Array -> "array"
            | Disabled -> "disabled"

    and TypesNumericFielddata = {
        [<JsonPropertyName("format")>]
        Format: TypesNumericFielddataFormat
    }

    and MappingBooleanProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("fielddata")>]
        Fielddata: TypesNumericFielddata option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and Byte = float

    and MappingNumberPropertyBase = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
    }

    and MappingByteNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: Byte option
    }

    and MappingSuggestContext = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("path")>]
        Path: Field option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("precision")>]
        Precision: System.Text.Json.JsonElement option
    }

    and MappingCompletionProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("contexts")>]
        Contexts: MappingSuggestContext array option
        [<JsonPropertyName("max_input_length")>]
        MaxInputLength: float option
        [<JsonPropertyName("preserve_position_increments")>]
        PreservePositionIncrements: bool option
        [<JsonPropertyName("preserve_separators")>]
        PreserveSeparators: bool option
        [<JsonPropertyName("search_analyzer")>]
        SearchAnalyzer: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingConstantKeywordProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("value")>]
        Value: obj option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingCountedKeywordProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("index")>]
        Index: bool option
    }

    and MappingDateNanosProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("null_value")>]
        NullValue: DateTime option
        [<JsonPropertyName("precision_step")>]
        PrecisionStep: float option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingDateProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("fielddata")>]
        Fielddata: TypesNumericFielddata option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("null_value")>]
        NullValue: DateTime option
        [<JsonPropertyName("precision_step")>]
        PrecisionStep: float option
        [<JsonPropertyName("locale")>]
        Locale: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingRangePropertyBase = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
    }

    and MappingDateRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingDenseVectorElementTypeConverter() =
        inherit JsonConverter<MappingDenseVectorElementType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingDenseVectorElementType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingDenseVectorElementType.Bit -> "bit"
                | MappingDenseVectorElementType.Byte -> "byte"
                | MappingDenseVectorElementType.Float -> "float"
                | MappingDenseVectorElementType.Bfloat16 -> "bfloat16"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "bit" -> MappingDenseVectorElementType.Bit
            | "byte" -> MappingDenseVectorElementType.Byte
            | "float" -> MappingDenseVectorElementType.Float
            | "bfloat16" -> MappingDenseVectorElementType.Bfloat16
            | s -> failwith $"Unknown MappingDenseVectorElementType: {s}"

    and [<JsonConverter(typeof<MappingDenseVectorElementTypeConverter>)>]
        MappingDenseVectorElementType =
        | Bit
        | Byte
        | Float
        | Bfloat16
        with
        override this.ToString() =
            match this with
            | Bit -> "bit"
            | Byte -> "byte"
            | Float -> "float"
            | Bfloat16 -> "bfloat16"

    and MappingDenseVectorIndexOptionsRescoreVector = {
        [<JsonPropertyName("oversample")>]
        Oversample: float
    }

    and MappingDenseVectorIndexOptionsTypeConverter() =
        inherit JsonConverter<MappingDenseVectorIndexOptionsType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingDenseVectorIndexOptionsType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingDenseVectorIndexOptionsType.BbqFlat -> "bbq_flat"
                | MappingDenseVectorIndexOptionsType.BbqHnsw -> "bbq_hnsw"
                | MappingDenseVectorIndexOptionsType.BbqDisk -> "bbq_disk"
                | MappingDenseVectorIndexOptionsType.Flat -> "flat"
                | MappingDenseVectorIndexOptionsType.Hnsw -> "hnsw"
                | MappingDenseVectorIndexOptionsType.Int4Flat -> "int4_flat"
                | MappingDenseVectorIndexOptionsType.Int4Hnsw -> "int4_hnsw"
                | MappingDenseVectorIndexOptionsType.Int8Flat -> "int8_flat"
                | MappingDenseVectorIndexOptionsType.Int8Hnsw -> "int8_hnsw"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "bbq_flat" -> MappingDenseVectorIndexOptionsType.BbqFlat
            | "bbq_hnsw" -> MappingDenseVectorIndexOptionsType.BbqHnsw
            | "bbq_disk" -> MappingDenseVectorIndexOptionsType.BbqDisk
            | "flat" -> MappingDenseVectorIndexOptionsType.Flat
            | "hnsw" -> MappingDenseVectorIndexOptionsType.Hnsw
            | "int4_flat" -> MappingDenseVectorIndexOptionsType.Int4Flat
            | "int4_hnsw" -> MappingDenseVectorIndexOptionsType.Int4Hnsw
            | "int8_flat" -> MappingDenseVectorIndexOptionsType.Int8Flat
            | "int8_hnsw" -> MappingDenseVectorIndexOptionsType.Int8Hnsw
            | s -> failwith $"Unknown MappingDenseVectorIndexOptionsType: {s}"

    and [<JsonConverter(typeof<MappingDenseVectorIndexOptionsTypeConverter>)>]
        MappingDenseVectorIndexOptionsType =
        | BbqFlat
        | BbqHnsw
        | BbqDisk
        | Flat
        | Hnsw
        | Int4Flat
        | Int4Hnsw
        | Int8Flat
        | Int8Hnsw
        with
        override this.ToString() =
            match this with
            | BbqFlat -> "bbq_flat"
            | BbqHnsw -> "bbq_hnsw"
            | BbqDisk -> "bbq_disk"
            | Flat -> "flat"
            | Hnsw -> "hnsw"
            | Int4Flat -> "int4_flat"
            | Int4Hnsw -> "int4_hnsw"
            | Int8Flat -> "int8_flat"
            | Int8Hnsw -> "int8_hnsw"

    and MappingDenseVectorIndexOptions = {
        [<JsonPropertyName("confidence_interval")>]
        ConfidenceInterval: float option
        [<JsonPropertyName("ef_construction")>]
        EfConstruction: float option
        [<JsonPropertyName("m")>]
        M: float option
        [<JsonPropertyName("type")>]
        Type: MappingDenseVectorIndexOptionsType
        [<JsonPropertyName("rescore_vector")>]
        RescoreVector: MappingDenseVectorIndexOptionsRescoreVector option
        [<JsonPropertyName("on_disk_rescore")>]
        OnDiskRescore: bool option
    }

    and MappingDenseVectorSimilarityConverter() =
        inherit JsonConverter<MappingDenseVectorSimilarity>()

        override _.Write(writer: Utf8JsonWriter, value: MappingDenseVectorSimilarity, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingDenseVectorSimilarity.Cosine -> "cosine"
                | MappingDenseVectorSimilarity.DotProduct -> "dot_product"
                | MappingDenseVectorSimilarity.L2Norm -> "l2_norm"
                | MappingDenseVectorSimilarity.MaxInnerProduct -> "max_inner_product"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> MappingDenseVectorSimilarity.Cosine
            | "dot_product" -> MappingDenseVectorSimilarity.DotProduct
            | "l2_norm" -> MappingDenseVectorSimilarity.L2Norm
            | "max_inner_product" -> MappingDenseVectorSimilarity.MaxInnerProduct
            | s -> failwith $"Unknown MappingDenseVectorSimilarity: {s}"

    and [<JsonConverter(typeof<MappingDenseVectorSimilarityConverter>)>]
        MappingDenseVectorSimilarity =
        | Cosine
        | DotProduct
        | L2Norm
        | MaxInnerProduct
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"
            | MaxInnerProduct -> "max_inner_product"

    and MappingDenseVectorProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("dims")>]
        Dims: float option
        [<JsonPropertyName("element_type")>]
        ElementType: MappingDenseVectorElementType option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingDenseVectorIndexOptions option
        [<JsonPropertyName("similarity")>]
        Similarity: MappingDenseVectorSimilarity option
    }

    and MappingDoubleNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
    }

    and MappingDoubleRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingIndexOptionsConverter() =
        inherit JsonConverter<MappingIndexOptions>()

        override _.Write(writer: Utf8JsonWriter, value: MappingIndexOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingIndexOptions.Docs -> "docs"
                | MappingIndexOptions.Freqs -> "freqs"
                | MappingIndexOptions.Positions -> "positions"
                | MappingIndexOptions.Offsets -> "offsets"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "docs" -> MappingIndexOptions.Docs
            | "freqs" -> MappingIndexOptions.Freqs
            | "positions" -> MappingIndexOptions.Positions
            | "offsets" -> MappingIndexOptions.Offsets
            | s -> failwith $"Unknown MappingIndexOptions: {s}"

    and [<JsonConverter(typeof<MappingIndexOptionsConverter>)>]
        MappingIndexOptions =
        | Docs
        | Freqs
        | Positions
        | Offsets
        with
        override this.ToString() =
            match this with
            | Docs -> "docs"
            | Freqs -> "freqs"
            | Positions -> "positions"
            | Offsets -> "offsets"

    and MappingTermVectorOptionConverter() =
        inherit JsonConverter<MappingTermVectorOption>()

        override _.Write(writer: Utf8JsonWriter, value: MappingTermVectorOption, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingTermVectorOption.No -> "no"
                | MappingTermVectorOption.Yes -> "yes"
                | MappingTermVectorOption.WithOffsets -> "with_offsets"
                | MappingTermVectorOption.WithPositions -> "with_positions"
                | MappingTermVectorOption.WithPositionsOffsets -> "with_positions_offsets"
                | MappingTermVectorOption.WithPositionsOffsetsPayloads -> "with_positions_offsets_payloads"
                | MappingTermVectorOption.WithPositionsPayloads -> "with_positions_payloads"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "no" -> MappingTermVectorOption.No
            | "yes" -> MappingTermVectorOption.Yes
            | "with_offsets" -> MappingTermVectorOption.WithOffsets
            | "with_positions" -> MappingTermVectorOption.WithPositions
            | "with_positions_offsets" -> MappingTermVectorOption.WithPositionsOffsets
            | "with_positions_offsets_payloads" -> MappingTermVectorOption.WithPositionsOffsetsPayloads
            | "with_positions_payloads" -> MappingTermVectorOption.WithPositionsPayloads
            | s -> failwith $"Unknown MappingTermVectorOption: {s}"

    and [<JsonConverter(typeof<MappingTermVectorOptionConverter>)>]
        MappingTermVectorOption =
        | No
        | Yes
        | WithOffsets
        | WithPositions
        | WithPositionsOffsets
        | WithPositionsOffsetsPayloads
        | WithPositionsPayloads
        with
        override this.ToString() =
            match this with
            | No -> "no"
            | Yes -> "yes"
            | WithOffsets -> "with_offsets"
            | WithPositions -> "with_positions"
            | WithPositionsOffsets -> "with_positions_offsets"
            | WithPositionsOffsetsPayloads -> "with_positions_offsets_payloads"
            | WithPositionsPayloads -> "with_positions_payloads"

    and MappingTextIndexPrefixes = {
        [<JsonPropertyName("max_chars")>]
        MaxChars: float
        [<JsonPropertyName("min_chars")>]
        MinChars: float
    }

    and MappingDynamicProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: FieldValue option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("eager_global_ordinals")>]
        EagerGlobalOrdinals: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("index_phrases")>]
        IndexPhrases: bool option
        [<JsonPropertyName("index_prefixes")>]
        IndexPrefixes: System.Text.Json.JsonElement option
        [<JsonPropertyName("norms")>]
        Norms: bool option
        [<JsonPropertyName("position_increment_gap")>]
        PositionIncrementGap: float option
        [<JsonPropertyName("search_analyzer")>]
        SearchAnalyzer: string option
        [<JsonPropertyName("search_quote_analyzer")>]
        SearchQuoteAnalyzer: string option
        [<JsonPropertyName("term_vector")>]
        TermVector: MappingTermVectorOption option
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("precision_step")>]
        PrecisionStep: float option
        [<JsonPropertyName("locale")>]
        Locale: string option
    }

    and MappingExponentialHistogramProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingFieldAliasProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("path")>]
        Path: Field option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingFlattenedProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("depth_limit")>]
        DepthLimit: float option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("eager_global_ordinals")>]
        EagerGlobalOrdinals: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("null_value")>]
        NullValue: string option
        [<JsonPropertyName("similarity")>]
        Similarity: string option
        [<JsonPropertyName("split_queries_on_whitespace")>]
        SplitQueriesOnWhitespace: bool option
        [<JsonPropertyName("time_series_dimensions")>]
        TimeSeriesDimensions: string array option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingFloatNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
    }

    and MappingFloatRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingGeoPointMetricTypeConverter() =
        inherit JsonConverter<MappingGeoPointMetricType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingGeoPointMetricType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingGeoPointMetricType.Gauge -> "gauge"
                | MappingGeoPointMetricType.Counter -> "counter"
                | MappingGeoPointMetricType.Position -> "position"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "gauge" -> MappingGeoPointMetricType.Gauge
            | "counter" -> MappingGeoPointMetricType.Counter
            | "position" -> MappingGeoPointMetricType.Position
            | s -> failwith $"Unknown MappingGeoPointMetricType: {s}"

    and [<JsonConverter(typeof<MappingGeoPointMetricTypeConverter>)>]
        MappingGeoPointMetricType =
        | Gauge
        | Counter
        | Position
        with
        override this.ToString() =
            match this with
            | Gauge -> "gauge"
            | Counter -> "counter"
            | Position -> "position"

    and MappingGeoPointProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("ignore_z_value")>]
        IgnoreZValue: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: GeoLocation option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingGeoPointMetricType option
    }

    and MappingGeoOrientationConverter() =
        inherit JsonConverter<MappingGeoOrientation>()

        override _.Write(writer: Utf8JsonWriter, value: MappingGeoOrientation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingGeoOrientation.Right -> "right"
                | MappingGeoOrientation.RIGHT -> "RIGHT"
                | MappingGeoOrientation.Counterclockwise -> "counterclockwise"
                | MappingGeoOrientation.Ccw -> "ccw"
                | MappingGeoOrientation.Left -> "left"
                | MappingGeoOrientation.LEFT -> "LEFT"
                | MappingGeoOrientation.Clockwise -> "clockwise"
                | MappingGeoOrientation.Cw -> "cw"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "right" -> MappingGeoOrientation.Right
            | "RIGHT" -> MappingGeoOrientation.RIGHT
            | "counterclockwise" -> MappingGeoOrientation.Counterclockwise
            | "ccw" -> MappingGeoOrientation.Ccw
            | "left" -> MappingGeoOrientation.Left
            | "LEFT" -> MappingGeoOrientation.LEFT
            | "clockwise" -> MappingGeoOrientation.Clockwise
            | "cw" -> MappingGeoOrientation.Cw
            | s -> failwith $"Unknown MappingGeoOrientation: {s}"

    and [<JsonConverter(typeof<MappingGeoOrientationConverter>)>]
        MappingGeoOrientation =
        | Right
        | RIGHT
        | Counterclockwise
        | Ccw
        | Left
        | LEFT
        | Clockwise
        | Cw
        with
        override this.ToString() =
            match this with
            | Right -> "right"
            | RIGHT -> "RIGHT"
            | Counterclockwise -> "counterclockwise"
            | Ccw -> "ccw"
            | Left -> "left"
            | LEFT -> "LEFT"
            | Clockwise -> "clockwise"
            | Cw -> "cw"

    and MappingGeoStrategyConverter() =
        inherit JsonConverter<MappingGeoStrategy>()

        override _.Write(writer: Utf8JsonWriter, value: MappingGeoStrategy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingGeoStrategy.Recursive -> "recursive"
                | MappingGeoStrategy.Term -> "term"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "recursive" -> MappingGeoStrategy.Recursive
            | "term" -> MappingGeoStrategy.Term
            | s -> failwith $"Unknown MappingGeoStrategy: {s}"

    and [<JsonConverter(typeof<MappingGeoStrategyConverter>)>]
        MappingGeoStrategy =
        | Recursive
        | Term
        with
        override this.ToString() =
            match this with
            | Recursive -> "recursive"
            | Term -> "term"

    /// <summary>
    /// The `geo_shape` data type facilitates the indexing of and searching with arbitrary geo shapes such as rectangles
    /// and polygons.
    /// </summary>
    and MappingGeoShapeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("ignore_z_value")>]
        IgnoreZValue: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("orientation")>]
        Orientation: MappingGeoOrientation option
        [<JsonPropertyName("strategy")>]
        Strategy: MappingGeoStrategy option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingHalfFloatNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
    }

    and MappingHistogramProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingIcuCollationProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("norms")>]
        Norms: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: string option
        [<JsonPropertyName("rules")>]
        Rules: string option
        [<JsonPropertyName("language")>]
        Language: string option
        [<JsonPropertyName("country")>]
        Country: string option
        [<JsonPropertyName("variant")>]
        Variant: string option
        [<JsonPropertyName("strength")>]
        Strength: AnalysisIcuCollationStrength option
        [<JsonPropertyName("decomposition")>]
        Decomposition: AnalysisIcuCollationDecomposition option
        [<JsonPropertyName("alternate")>]
        Alternate: AnalysisIcuCollationAlternate option
        [<JsonPropertyName("case_level")>]
        CaseLevel: bool option
        [<JsonPropertyName("case_first")>]
        CaseFirst: AnalysisIcuCollationCaseFirst option
        [<JsonPropertyName("numeric")>]
        Numeric: bool option
        [<JsonPropertyName("variable_top")>]
        VariableTop: string option
        [<JsonPropertyName("hiragana_quaternary_mode")>]
        HiraganaQuaternaryMode: bool option
    }

    and MappingIntegerNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
    }

    and MappingIntegerRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingIpProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: string option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingIpRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingJoinProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("relations")>]
        Relations: Map<string, System.Text.Json.JsonElement> option
        [<JsonPropertyName("eager_global_ordinals")>]
        EagerGlobalOrdinals: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingKeywordProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("eager_global_ordinals")>]
        EagerGlobalOrdinals: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("normalizer")>]
        Normalizer: string option
        [<JsonPropertyName("norms")>]
        Norms: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: string option
        [<JsonPropertyName("similarity")>]
        Similarity: System.Text.Json.JsonElement option
        [<JsonPropertyName("split_queries_on_whitespace")>]
        SplitQueriesOnWhitespace: bool option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingLongNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
    }

    and MappingLongRangeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    /// <summary>
    /// A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field
    /// effectively stores data the same way as a text field that only indexes documents (index_options: docs) and
    /// disables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries
    /// </summary>
    and MappingMatchOnlyTextProperty = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
    }

    and MappingMurmur3HashProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingNestedProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("include_in_parent")>]
        IncludeInParent: bool option
        [<JsonPropertyName("include_in_root")>]
        IncludeInRoot: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingSubobjectsConverter() =
        inherit JsonConverter<MappingSubobjects>()

        override _.Write(writer: Utf8JsonWriter, value: MappingSubobjects, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingSubobjects.True -> "true"
                | MappingSubobjects.False -> "false"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "true" -> MappingSubobjects.True
            | "false" -> MappingSubobjects.False
            | s -> failwith $"Unknown MappingSubobjects: {s}"

    and [<JsonConverter(typeof<MappingSubobjectsConverter>)>]
        MappingSubobjects =
        | True
        | False
        with
        override this.ToString() =
            match this with
            | True -> "true"
            | False -> "false"

    and MappingObjectProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("subobjects")>]
        Subobjects: MappingSubobjects option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and MappingPassthroughObjectProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("priority")>]
        Priority: float option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
    }

    and MappingPercolatorProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingPointProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("ignore_z_value")>]
        IgnoreZValue: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: string option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingRankFeatureProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("positive_score_impact")>]
        PositiveScoreImpact: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingRankFeaturesProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("positive_score_impact")>]
        PositiveScoreImpact: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingRankVectorElementTypeConverter() =
        inherit JsonConverter<MappingRankVectorElementType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingRankVectorElementType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingRankVectorElementType.Byte -> "byte"
                | MappingRankVectorElementType.Float -> "float"
                | MappingRankVectorElementType.Bit -> "bit"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "byte" -> MappingRankVectorElementType.Byte
            | "float" -> MappingRankVectorElementType.Float
            | "bit" -> MappingRankVectorElementType.Bit
            | s -> failwith $"Unknown MappingRankVectorElementType: {s}"

    and [<JsonConverter(typeof<MappingRankVectorElementTypeConverter>)>]
        MappingRankVectorElementType =
        | Byte
        | Float
        | Bit
        with
        override this.ToString() =
            match this with
            | Byte -> "byte"
            | Float -> "float"
            | Bit -> "bit"

    /// <summary>
    /// Technical preview
    /// </summary>
    and MappingRankVectorProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("element_type")>]
        ElementType: MappingRankVectorElementType option
        [<JsonPropertyName("dims")>]
        Dims: float option
    }

    and MappingScaledFloatNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: float option
        [<JsonPropertyName("scaling_factor")>]
        ScalingFactor: float option
    }

    and MappingSearchAsYouTypeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("max_shingle_size")>]
        MaxShingleSize: float option
        [<JsonPropertyName("norms")>]
        Norms: bool option
        [<JsonPropertyName("search_analyzer")>]
        SearchAnalyzer: string option
        [<JsonPropertyName("search_quote_analyzer")>]
        SearchQuoteAnalyzer: string option
        [<JsonPropertyName("similarity")>]
        Similarity: System.Text.Json.JsonElement option
        [<JsonPropertyName("term_vector")>]
        TermVector: MappingTermVectorOption option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingChunkingSettings = {
        [<JsonPropertyName("strategy")>]
        Strategy: string
        [<JsonPropertyName("separator_group")>]
        SeparatorGroup: string option
        [<JsonPropertyName("separators")>]
        Separators: string array option
        [<JsonPropertyName("max_chunk_size")>]
        MaxChunkSize: float
        [<JsonPropertyName("overlap")>]
        Overlap: float option
        [<JsonPropertyName("sentence_overlap")>]
        SentenceOverlap: float option
    }

    and MappingSparseVectorIndexOptions = {
        [<JsonPropertyName("prune")>]
        Prune: bool option
        [<JsonPropertyName("pruning_config")>]
        PruningConfig: TokenPruningConfig option
    }

    and MappingSemanticTextIndexOptions = {
        [<JsonPropertyName("dense_vector")>]
        DenseVector: MappingDenseVectorIndexOptions option
        [<JsonPropertyName("sparse_vector")>]
        SparseVector: MappingSparseVectorIndexOptions option
    }

    and MappingSemanticTextProperty = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("inference_id")>]
        InferenceId: Id option
        [<JsonPropertyName("search_inference_id")>]
        SearchInferenceId: Id option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingSemanticTextIndexOptions option
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: System.Text.Json.JsonElement option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
    }

    /// <summary>
    /// The `shape` data type facilitates the indexing of and searching with arbitrary `x, y` cartesian shapes such as
    /// rectangles and polygons.
    /// </summary>
    and MappingShapeProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("ignore_z_value")>]
        IgnoreZValue: bool option
        [<JsonPropertyName("orientation")>]
        Orientation: MappingGeoOrientation option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and Short = float

    and MappingShortNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: Short option
    }

    and MappingSparseVectorProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingSparseVectorIndexOptions option
    }

    and TypesFielddataFrequencyFilter = {
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min")>]
        Min: float
        [<JsonPropertyName("min_segment_size")>]
        MinSegmentSize: float
    }

    and MappingTextProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("eager_global_ordinals")>]
        EagerGlobalOrdinals: bool option
        [<JsonPropertyName("fielddata")>]
        Fielddata: bool option
        [<JsonPropertyName("fielddata_frequency_filter")>]
        FielddataFrequencyFilter: TypesFielddataFrequencyFilter option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("index_options")>]
        IndexOptions: MappingIndexOptions option
        [<JsonPropertyName("index_phrases")>]
        IndexPhrases: bool option
        [<JsonPropertyName("index_prefixes")>]
        IndexPrefixes: System.Text.Json.JsonElement option
        [<JsonPropertyName("norms")>]
        Norms: bool option
        [<JsonPropertyName("position_increment_gap")>]
        PositionIncrementGap: float option
        [<JsonPropertyName("search_analyzer")>]
        SearchAnalyzer: string option
        [<JsonPropertyName("search_quote_analyzer")>]
        SearchQuoteAnalyzer: string option
        [<JsonPropertyName("similarity")>]
        Similarity: System.Text.Json.JsonElement option
        [<JsonPropertyName("term_vector")>]
        TermVector: MappingTermVectorOption option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingTokenCountProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("analyzer")>]
        Analyzer: string option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("null_value")>]
        NullValue: float option
        [<JsonPropertyName("enable_position_increments")>]
        EnablePositionIncrements: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and Ulong = float

    and MappingUnsignedLongNumberProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("coerce")>]
        Coerce: bool option
        [<JsonPropertyName("ignore_malformed")>]
        IgnoreMalformed: bool option
        [<JsonPropertyName("index")>]
        Index: bool option
        [<JsonPropertyName("on_script_error")>]
        OnScriptError: MappingOnScriptError option
        [<JsonPropertyName("script")>]
        Script: Script option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: Ulong option
    }

    and MappingVersionProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and MappingWildcardProperty = {
        [<JsonPropertyName("meta")>]
        Meta: Map<string, string> option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("ignore_above")>]
        IgnoreAbove: float option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, MappingProperty> option
        [<JsonPropertyName("synthetic_source_keep")>]
        SyntheticSourceKeep: MappingSyntheticSourceKeepEnum option
        [<JsonPropertyName("copy_to")>]
        CopyTo: Fields option
        [<JsonPropertyName("store")>]
        Store: bool option
        [<JsonPropertyName("doc_values")>]
        DocValues: bool option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("null_value")>]
        NullValue: string option
    }

    and MappingPropertyConverter() =
        inherit JsonConverter<MappingProperty>()

        override _.Write(writer: Utf8JsonWriter, value: MappingProperty, options: JsonSerializerOptions) =
            match value with
            | MappingProperty.AggregateMetricDouble v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Alias v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Binary v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Boolean v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Byte v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Completion v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.ConstantKeyword v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.CountedKeyword v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Date v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.DateNanos v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.DateRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.DenseVector v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Double v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.DoubleRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.ExponentialHistogram v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Flattened v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Float v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.FloatRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.GeoPoint v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.GeoShape v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.HalfFloat v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Histogram v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.IcuCollationKeyword v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Integer v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.IntegerRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Ip v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.IpRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Join v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Keyword v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Long v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.LongRange v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.MatchOnlyText v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Murmur3 v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Nested v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Object v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Passthrough v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Percolator v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Point v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.RankFeature v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.RankFeatures v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.RankVectors v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.ScaledFloat v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.SearchAsYouType v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.SemanticText v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Shape v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Short v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.SparseVector v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Text v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.TokenCount v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.UnsignedLong v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Version v -> JsonSerializer.Serialize(writer, v, options)
            | MappingProperty.Wildcard v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "aggregate_metric_double" -> MappingProperty.AggregateMetricDouble (JsonSerializer.Deserialize<MappingAggregateMetricDoubleProperty>(json, options))
            | "alias" -> MappingProperty.Alias (JsonSerializer.Deserialize<MappingFieldAliasProperty>(json, options))
            | "binary" -> MappingProperty.Binary (JsonSerializer.Deserialize<MappingBinaryProperty>(json, options))
            | "boolean" -> MappingProperty.Boolean (JsonSerializer.Deserialize<MappingBooleanProperty>(json, options))
            | "byte" -> MappingProperty.Byte (JsonSerializer.Deserialize<MappingByteNumberProperty>(json, options))
            | "completion" -> MappingProperty.Completion (JsonSerializer.Deserialize<MappingCompletionProperty>(json, options))
            | "constant_keyword" -> MappingProperty.ConstantKeyword (JsonSerializer.Deserialize<MappingConstantKeywordProperty>(json, options))
            | "counted_keyword" -> MappingProperty.CountedKeyword (JsonSerializer.Deserialize<MappingCountedKeywordProperty>(json, options))
            | "date" -> MappingProperty.Date (JsonSerializer.Deserialize<MappingDateProperty>(json, options))
            | "date_nanos" -> MappingProperty.DateNanos (JsonSerializer.Deserialize<MappingDateNanosProperty>(json, options))
            | "date_range" -> MappingProperty.DateRange (JsonSerializer.Deserialize<MappingDateRangeProperty>(json, options))
            | "dense_vector" -> MappingProperty.DenseVector (JsonSerializer.Deserialize<MappingDenseVectorProperty>(json, options))
            | "double" -> MappingProperty.Double (JsonSerializer.Deserialize<MappingDoubleNumberProperty>(json, options))
            | "double_range" -> MappingProperty.DoubleRange (JsonSerializer.Deserialize<MappingDoubleRangeProperty>(json, options))
            | "exponential_histogram" -> MappingProperty.ExponentialHistogram (JsonSerializer.Deserialize<MappingExponentialHistogramProperty>(json, options))
            | "flattened" -> MappingProperty.Flattened (JsonSerializer.Deserialize<MappingFlattenedProperty>(json, options))
            | "float" -> MappingProperty.Float (JsonSerializer.Deserialize<MappingFloatNumberProperty>(json, options))
            | "float_range" -> MappingProperty.FloatRange (JsonSerializer.Deserialize<MappingFloatRangeProperty>(json, options))
            | "geo_point" -> MappingProperty.GeoPoint (JsonSerializer.Deserialize<MappingGeoPointProperty>(json, options))
            | "geo_shape" -> MappingProperty.GeoShape (JsonSerializer.Deserialize<MappingGeoShapeProperty>(json, options))
            | "half_float" -> MappingProperty.HalfFloat (JsonSerializer.Deserialize<MappingHalfFloatNumberProperty>(json, options))
            | "histogram" -> MappingProperty.Histogram (JsonSerializer.Deserialize<MappingHistogramProperty>(json, options))
            | "icu_collation_keyword" -> MappingProperty.IcuCollationKeyword (JsonSerializer.Deserialize<MappingIcuCollationProperty>(json, options))
            | "integer" -> MappingProperty.Integer (JsonSerializer.Deserialize<MappingIntegerNumberProperty>(json, options))
            | "integer_range" -> MappingProperty.IntegerRange (JsonSerializer.Deserialize<MappingIntegerRangeProperty>(json, options))
            | "ip" -> MappingProperty.Ip (JsonSerializer.Deserialize<MappingIpProperty>(json, options))
            | "ip_range" -> MappingProperty.IpRange (JsonSerializer.Deserialize<MappingIpRangeProperty>(json, options))
            | "join" -> MappingProperty.Join (JsonSerializer.Deserialize<MappingJoinProperty>(json, options))
            | "keyword" -> MappingProperty.Keyword (JsonSerializer.Deserialize<MappingKeywordProperty>(json, options))
            | "long" -> MappingProperty.Long (JsonSerializer.Deserialize<MappingLongNumberProperty>(json, options))
            | "long_range" -> MappingProperty.LongRange (JsonSerializer.Deserialize<MappingLongRangeProperty>(json, options))
            | "match_only_text" -> MappingProperty.MatchOnlyText (JsonSerializer.Deserialize<MappingMatchOnlyTextProperty>(json, options))
            | "murmur3" -> MappingProperty.Murmur3 (JsonSerializer.Deserialize<MappingMurmur3HashProperty>(json, options))
            | "nested" -> MappingProperty.Nested (JsonSerializer.Deserialize<MappingNestedProperty>(json, options))
            | "object" -> MappingProperty.Object (JsonSerializer.Deserialize<MappingObjectProperty>(json, options))
            | "passthrough" -> MappingProperty.Passthrough (JsonSerializer.Deserialize<MappingPassthroughObjectProperty>(json, options))
            | "percolator" -> MappingProperty.Percolator (JsonSerializer.Deserialize<MappingPercolatorProperty>(json, options))
            | "point" -> MappingProperty.Point (JsonSerializer.Deserialize<MappingPointProperty>(json, options))
            | "rank_feature" -> MappingProperty.RankFeature (JsonSerializer.Deserialize<MappingRankFeatureProperty>(json, options))
            | "rank_features" -> MappingProperty.RankFeatures (JsonSerializer.Deserialize<MappingRankFeaturesProperty>(json, options))
            | "rank_vectors" -> MappingProperty.RankVectors (JsonSerializer.Deserialize<MappingRankVectorProperty>(json, options))
            | "scaled_float" -> MappingProperty.ScaledFloat (JsonSerializer.Deserialize<MappingScaledFloatNumberProperty>(json, options))
            | "search_as_you_type" -> MappingProperty.SearchAsYouType (JsonSerializer.Deserialize<MappingSearchAsYouTypeProperty>(json, options))
            | "semantic_text" -> MappingProperty.SemanticText (JsonSerializer.Deserialize<MappingSemanticTextProperty>(json, options))
            | "shape" -> MappingProperty.Shape (JsonSerializer.Deserialize<MappingShapeProperty>(json, options))
            | "short" -> MappingProperty.Short (JsonSerializer.Deserialize<MappingShortNumberProperty>(json, options))
            | "sparse_vector" -> MappingProperty.SparseVector (JsonSerializer.Deserialize<MappingSparseVectorProperty>(json, options))
            | "text" -> MappingProperty.Text (JsonSerializer.Deserialize<MappingTextProperty>(json, options))
            | "token_count" -> MappingProperty.TokenCount (JsonSerializer.Deserialize<MappingTokenCountProperty>(json, options))
            | "unsigned_long" -> MappingProperty.UnsignedLong (JsonSerializer.Deserialize<MappingUnsignedLongNumberProperty>(json, options))
            | "version" -> MappingProperty.Version (JsonSerializer.Deserialize<MappingVersionProperty>(json, options))
            | "wildcard" -> MappingProperty.Wildcard (JsonSerializer.Deserialize<MappingWildcardProperty>(json, options))
            | s -> failwith $"Unknown MappingProperty type: {s}"

    and [<JsonConverter(typeof<MappingPropertyConverter>)>]
        MappingProperty =
        | AggregateMetricDouble of MappingAggregateMetricDoubleProperty
        | Alias of MappingFieldAliasProperty
        | Binary of MappingBinaryProperty
        | Boolean of MappingBooleanProperty
        | Byte of MappingByteNumberProperty
        | Completion of MappingCompletionProperty
        | ConstantKeyword of MappingConstantKeywordProperty
        | CountedKeyword of MappingCountedKeywordProperty
        | Date of MappingDateProperty
        | DateNanos of MappingDateNanosProperty
        | DateRange of MappingDateRangeProperty
        | DenseVector of MappingDenseVectorProperty
        | Double of MappingDoubleNumberProperty
        | DoubleRange of MappingDoubleRangeProperty
        | ExponentialHistogram of MappingExponentialHistogramProperty
        | Flattened of MappingFlattenedProperty
        | Float of MappingFloatNumberProperty
        | FloatRange of MappingFloatRangeProperty
        | GeoPoint of MappingGeoPointProperty
        | GeoShape of MappingGeoShapeProperty
        | HalfFloat of MappingHalfFloatNumberProperty
        | Histogram of MappingHistogramProperty
        | IcuCollationKeyword of MappingIcuCollationProperty
        | Integer of MappingIntegerNumberProperty
        | IntegerRange of MappingIntegerRangeProperty
        | Ip of MappingIpProperty
        | IpRange of MappingIpRangeProperty
        | Join of MappingJoinProperty
        | Keyword of MappingKeywordProperty
        | Long of MappingLongNumberProperty
        | LongRange of MappingLongRangeProperty
        | MatchOnlyText of MappingMatchOnlyTextProperty
        | Murmur3 of MappingMurmur3HashProperty
        | Nested of MappingNestedProperty
        | Object of MappingObjectProperty
        | Passthrough of MappingPassthroughObjectProperty
        | Percolator of MappingPercolatorProperty
        | Point of MappingPointProperty
        | RankFeature of MappingRankFeatureProperty
        | RankFeatures of MappingRankFeaturesProperty
        | RankVectors of MappingRankVectorProperty
        | ScaledFloat of MappingScaledFloatNumberProperty
        | SearchAsYouType of MappingSearchAsYouTypeProperty
        | SemanticText of MappingSemanticTextProperty
        | Shape of MappingShapeProperty
        | Short of MappingShortNumberProperty
        | SparseVector of MappingSparseVectorProperty
        | Text of MappingTextProperty
        | TokenCount of MappingTokenCountProperty
        | UnsignedLong of MappingUnsignedLongNumberProperty
        | Version of MappingVersionProperty
        | Wildcard of MappingWildcardProperty

    and MappingPropertyTypeConverter() =
        inherit JsonConverter<MappingPropertyType>()

        override _.Write(writer: Utf8JsonWriter, value: MappingPropertyType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingPropertyType.AggregateMetricDouble -> "aggregate_metric_double"
                | MappingPropertyType.Alias -> "alias"
                | MappingPropertyType.Binary -> "binary"
                | MappingPropertyType.Boolean -> "boolean"
                | MappingPropertyType.Byte -> "byte"
                | MappingPropertyType.Completion -> "completion"
                | MappingPropertyType.ConstantKeyword -> "constant_keyword"
                | MappingPropertyType.CountedKeyword -> "counted_keyword"
                | MappingPropertyType.Date -> "date"
                | MappingPropertyType.DateNanos -> "date_nanos"
                | MappingPropertyType.DateRange -> "date_range"
                | MappingPropertyType.DenseVector -> "dense_vector"
                | MappingPropertyType.Double -> "double"
                | MappingPropertyType.DoubleRange -> "double_range"
                | MappingPropertyType.ExponentialHistogram -> "exponential_histogram"
                | MappingPropertyType.Flattened -> "flattened"
                | MappingPropertyType.Float -> "float"
                | MappingPropertyType.FloatRange -> "float_range"
                | MappingPropertyType.GeoPoint -> "geo_point"
                | MappingPropertyType.GeoShape -> "geo_shape"
                | MappingPropertyType.HalfFloat -> "half_float"
                | MappingPropertyType.Histogram -> "histogram"
                | MappingPropertyType.IcuCollationKeyword -> "icu_collation_keyword"
                | MappingPropertyType.Integer -> "integer"
                | MappingPropertyType.IntegerRange -> "integer_range"
                | MappingPropertyType.Ip -> "ip"
                | MappingPropertyType.IpRange -> "ip_range"
                | MappingPropertyType.Join -> "join"
                | MappingPropertyType.Keyword -> "keyword"
                | MappingPropertyType.Long -> "long"
                | MappingPropertyType.LongRange -> "long_range"
                | MappingPropertyType.MatchOnlyText -> "match_only_text"
                | MappingPropertyType.Murmur3 -> "murmur3"
                | MappingPropertyType.Nested -> "nested"
                | MappingPropertyType.Object -> "object"
                | MappingPropertyType.Passthrough -> "passthrough"
                | MappingPropertyType.Percolator -> "percolator"
                | MappingPropertyType.Point -> "point"
                | MappingPropertyType.RankFeature -> "rank_feature"
                | MappingPropertyType.RankFeatures -> "rank_features"
                | MappingPropertyType.RankVectors -> "rank_vectors"
                | MappingPropertyType.ScaledFloat -> "scaled_float"
                | MappingPropertyType.SearchAsYouType -> "search_as_you_type"
                | MappingPropertyType.SemanticText -> "semantic_text"
                | MappingPropertyType.Shape -> "shape"
                | MappingPropertyType.Short -> "short"
                | MappingPropertyType.SparseVector -> "sparse_vector"
                | MappingPropertyType.Text -> "text"
                | MappingPropertyType.TokenCount -> "token_count"
                | MappingPropertyType.UnsignedLong -> "unsigned_long"
                | MappingPropertyType.Version -> "version"
                | MappingPropertyType.Wildcard -> "wildcard"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "aggregate_metric_double" -> MappingPropertyType.AggregateMetricDouble
            | "alias" -> MappingPropertyType.Alias
            | "binary" -> MappingPropertyType.Binary
            | "boolean" -> MappingPropertyType.Boolean
            | "byte" -> MappingPropertyType.Byte
            | "completion" -> MappingPropertyType.Completion
            | "constant_keyword" -> MappingPropertyType.ConstantKeyword
            | "counted_keyword" -> MappingPropertyType.CountedKeyword
            | "date" -> MappingPropertyType.Date
            | "date_nanos" -> MappingPropertyType.DateNanos
            | "date_range" -> MappingPropertyType.DateRange
            | "dense_vector" -> MappingPropertyType.DenseVector
            | "double" -> MappingPropertyType.Double
            | "double_range" -> MappingPropertyType.DoubleRange
            | "exponential_histogram" -> MappingPropertyType.ExponentialHistogram
            | "flattened" -> MappingPropertyType.Flattened
            | "float" -> MappingPropertyType.Float
            | "float_range" -> MappingPropertyType.FloatRange
            | "geo_point" -> MappingPropertyType.GeoPoint
            | "geo_shape" -> MappingPropertyType.GeoShape
            | "half_float" -> MappingPropertyType.HalfFloat
            | "histogram" -> MappingPropertyType.Histogram
            | "icu_collation_keyword" -> MappingPropertyType.IcuCollationKeyword
            | "integer" -> MappingPropertyType.Integer
            | "integer_range" -> MappingPropertyType.IntegerRange
            | "ip" -> MappingPropertyType.Ip
            | "ip_range" -> MappingPropertyType.IpRange
            | "join" -> MappingPropertyType.Join
            | "keyword" -> MappingPropertyType.Keyword
            | "long" -> MappingPropertyType.Long
            | "long_range" -> MappingPropertyType.LongRange
            | "match_only_text" -> MappingPropertyType.MatchOnlyText
            | "murmur3" -> MappingPropertyType.Murmur3
            | "nested" -> MappingPropertyType.Nested
            | "object" -> MappingPropertyType.Object
            | "passthrough" -> MappingPropertyType.Passthrough
            | "percolator" -> MappingPropertyType.Percolator
            | "point" -> MappingPropertyType.Point
            | "rank_feature" -> MappingPropertyType.RankFeature
            | "rank_features" -> MappingPropertyType.RankFeatures
            | "rank_vectors" -> MappingPropertyType.RankVectors
            | "scaled_float" -> MappingPropertyType.ScaledFloat
            | "search_as_you_type" -> MappingPropertyType.SearchAsYouType
            | "semantic_text" -> MappingPropertyType.SemanticText
            | "shape" -> MappingPropertyType.Shape
            | "short" -> MappingPropertyType.Short
            | "sparse_vector" -> MappingPropertyType.SparseVector
            | "text" -> MappingPropertyType.Text
            | "token_count" -> MappingPropertyType.TokenCount
            | "unsigned_long" -> MappingPropertyType.UnsignedLong
            | "version" -> MappingPropertyType.Version
            | "wildcard" -> MappingPropertyType.Wildcard
            | s -> failwith $"Unknown MappingPropertyType: {s}"

    and [<JsonConverter(typeof<MappingPropertyTypeConverter>)>]
        MappingPropertyType =
        | AggregateMetricDouble
        | Alias
        | Binary
        | Boolean
        | Byte
        | Completion
        | ConstantKeyword
        | CountedKeyword
        | Date
        | DateNanos
        | DateRange
        | DenseVector
        | Double
        | DoubleRange
        | ExponentialHistogram
        | Flattened
        | Float
        | FloatRange
        | GeoPoint
        | GeoShape
        | HalfFloat
        | Histogram
        | IcuCollationKeyword
        | Integer
        | IntegerRange
        | Ip
        | IpRange
        | Join
        | Keyword
        | Long
        | LongRange
        | MatchOnlyText
        | Murmur3
        | Nested
        | Object
        | Passthrough
        | Percolator
        | Point
        | RankFeature
        | RankFeatures
        | RankVectors
        | ScaledFloat
        | SearchAsYouType
        | SemanticText
        | Shape
        | Short
        | SparseVector
        | Text
        | TokenCount
        | UnsignedLong
        | Version
        | Wildcard
        with
        override this.ToString() =
            match this with
            | AggregateMetricDouble -> "aggregate_metric_double"
            | Alias -> "alias"
            | Binary -> "binary"
            | Boolean -> "boolean"
            | Byte -> "byte"
            | Completion -> "completion"
            | ConstantKeyword -> "constant_keyword"
            | CountedKeyword -> "counted_keyword"
            | Date -> "date"
            | DateNanos -> "date_nanos"
            | DateRange -> "date_range"
            | DenseVector -> "dense_vector"
            | Double -> "double"
            | DoubleRange -> "double_range"
            | ExponentialHistogram -> "exponential_histogram"
            | Flattened -> "flattened"
            | Float -> "float"
            | FloatRange -> "float_range"
            | GeoPoint -> "geo_point"
            | GeoShape -> "geo_shape"
            | HalfFloat -> "half_float"
            | Histogram -> "histogram"
            | IcuCollationKeyword -> "icu_collation_keyword"
            | Integer -> "integer"
            | IntegerRange -> "integer_range"
            | Ip -> "ip"
            | IpRange -> "ip_range"
            | Join -> "join"
            | Keyword -> "keyword"
            | Long -> "long"
            | LongRange -> "long_range"
            | MatchOnlyText -> "match_only_text"
            | Murmur3 -> "murmur3"
            | Nested -> "nested"
            | Object -> "object"
            | Passthrough -> "passthrough"
            | Percolator -> "percolator"
            | Point -> "point"
            | RankFeature -> "rank_feature"
            | RankFeatures -> "rank_features"
            | RankVectors -> "rank_vectors"
            | ScaledFloat -> "scaled_float"
            | SearchAsYouType -> "search_as_you_type"
            | SemanticText -> "semantic_text"
            | Shape -> "shape"
            | Short -> "short"
            | SparseVector -> "sparse_vector"
            | Text -> "text"
            | TokenCount -> "token_count"
            | UnsignedLong -> "unsigned_long"
            | Version -> "version"
            | Wildcard -> "wildcard"

    and MappingDynamicTemplate = {
        [<JsonPropertyName("match")>]
        Match: System.Text.Json.JsonElement option
        [<JsonPropertyName("path_match")>]
        PathMatch: System.Text.Json.JsonElement option
        [<JsonPropertyName("unmatch")>]
        Unmatch: System.Text.Json.JsonElement option
        [<JsonPropertyName("path_unmatch")>]
        PathUnmatch: System.Text.Json.JsonElement option
        [<JsonPropertyName("match_mapping_type")>]
        MatchMappingType: System.Text.Json.JsonElement option
        [<JsonPropertyName("unmatch_mapping_type")>]
        UnmatchMappingType: System.Text.Json.JsonElement option
        [<JsonPropertyName("match_pattern")>]
        MatchPattern: MappingMatchType option
        [<JsonPropertyName("mapping")>]
        Mapping: MappingProperty option
        [<JsonPropertyName("runtime")>]
        Runtime: MappingRuntimeField option
    }

    and MappingFieldNamesField = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and MappingIndexField = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and MappingRoutingField = {
        [<JsonPropertyName("required")>]
        Required: bool
    }

    and MappingSizeField = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and MappingSourceFieldModeConverter() =
        inherit JsonConverter<MappingSourceFieldMode>()

        override _.Write(writer: Utf8JsonWriter, value: MappingSourceFieldMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MappingSourceFieldMode.Disabled -> "disabled"
                | MappingSourceFieldMode.Stored -> "stored"
                | MappingSourceFieldMode.Synthetic -> "synthetic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "disabled" -> MappingSourceFieldMode.Disabled
            | "stored" -> MappingSourceFieldMode.Stored
            | "synthetic" -> MappingSourceFieldMode.Synthetic
            | s -> failwith $"Unknown MappingSourceFieldMode: {s}"

    and [<JsonConverter(typeof<MappingSourceFieldModeConverter>)>]
        MappingSourceFieldMode =
        | Disabled
        | Stored
        | Synthetic
        with
        override this.ToString() =
            match this with
            | Disabled -> "disabled"
            | Stored -> "stored"
            | Synthetic -> "synthetic"

    and MappingSourceField = {
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("compress_threshold")>]
        CompressThreshold: string option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("excludes")>]
        Excludes: string array option
        [<JsonPropertyName("includes")>]
        Includes: string array option
        [<JsonPropertyName("mode")>]
        Mode: MappingSourceFieldMode option
    }

    and MappingTypeMapping = {
        [<JsonPropertyName("all_field")>]
        AllField: MappingAllField option
        [<JsonPropertyName("date_detection")>]
        DateDetection: bool option
        [<JsonPropertyName("dynamic")>]
        Dynamic: MappingDynamicMapping option
        [<JsonPropertyName("dynamic_date_formats")>]
        DynamicDateFormats: string array option
        [<JsonPropertyName("dynamic_templates")>]
        DynamicTemplates: Map<string, MappingDynamicTemplate> array option
        [<JsonPropertyName("_field_names")>]
        FieldNames: MappingFieldNamesField option
        [<JsonPropertyName("index_field")>]
        IndexField: MappingIndexField option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("numeric_detection")>]
        NumericDetection: bool option
        [<JsonPropertyName("properties")>]
        Properties: Map<string, MappingProperty> option
        [<JsonPropertyName("_routing")>]
        Routing: MappingRoutingField option
        [<JsonPropertyName("_size")>]
        Size: MappingSizeField option
        [<JsonPropertyName("_source")>]
        Source: MappingSourceField option
        [<JsonPropertyName("runtime")>]
        Runtime: Map<string, MappingRuntimeField> option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("subobjects")>]
        Subobjects: MappingSubobjects option
        [<JsonPropertyName("_data_stream_timestamp")>]
        DataStreamTimestamp: MappingDataStreamTimestamp option
    }

    and TypesAliasDefinition = {
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("index_routing")>]
        IndexRouting: string option
        [<JsonPropertyName("is_write_index")>]
        IsWriteIndex: bool option
        [<JsonPropertyName("routing")>]
        Routing: string option
        [<JsonPropertyName("search_routing")>]
        SearchRouting: string option
        [<JsonPropertyName("is_hidden")>]
        IsHidden: bool option
    }

    and TypesDownsamplingRound = {
        [<JsonPropertyName("after")>]
        After: Duration
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: DurationLarge
    }

    and TypesSamplingMethodConverter() =
        inherit JsonConverter<TypesSamplingMethod>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSamplingMethod, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSamplingMethod.Aggregate -> "aggregate"
                | TypesSamplingMethod.LastValue -> "last_value"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "aggregate" -> TypesSamplingMethod.Aggregate
            | "last_value" -> TypesSamplingMethod.LastValue
            | s -> failwith $"Unknown TypesSamplingMethod: {s}"

    and [<JsonConverter(typeof<TypesSamplingMethodConverter>)>]
        TypesSamplingMethod =
        | Aggregate
        | LastValue
        with
        override this.ToString() =
            match this with
            | Aggregate -> "aggregate"
            | LastValue -> "last_value"

    /// <summary>
    /// Data stream lifecycle denotes that a data stream is managed by the data stream lifecycle and contains the configuration.
    /// </summary>
    and TypesDataStreamLifecycle = {
        [<JsonPropertyName("data_retention")>]
        DataRetention: Duration option
        [<JsonPropertyName("downsampling")>]
        Downsampling: TypesDownsamplingRound array option
        [<JsonPropertyName("downsampling_method")>]
        DownsamplingMethod: TypesSamplingMethod option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
    }

    and TypesDataStreamLifecycleRolloverConditions = {
        [<JsonPropertyName("min_age")>]
        MinAge: Duration option
        [<JsonPropertyName("max_age")>]
        MaxAge: string option
        [<JsonPropertyName("min_docs")>]
        MinDocs: float option
        [<JsonPropertyName("max_docs")>]
        MaxDocs: float option
        [<JsonPropertyName("min_size")>]
        MinSize: ByteSize option
        [<JsonPropertyName("max_size")>]
        MaxSize: ByteSize option
        [<JsonPropertyName("min_primary_shard_size")>]
        MinPrimaryShardSize: ByteSize option
        [<JsonPropertyName("max_primary_shard_size")>]
        MaxPrimaryShardSize: ByteSize option
        [<JsonPropertyName("min_primary_shard_docs")>]
        MinPrimaryShardDocs: float option
        [<JsonPropertyName("max_primary_shard_docs")>]
        MaxPrimaryShardDocs: float option
    }

    /// <summary>
    /// Data stream lifecycle with rollover can be used to display the configuration including the default rollover conditions,
    /// if asked.
    /// </summary>
    and TypesDataStreamLifecycleWithRollover = {
        [<JsonPropertyName("data_retention")>]
        DataRetention: Duration option
        [<JsonPropertyName("downsampling")>]
        Downsampling: TypesDownsamplingRound array option
        [<JsonPropertyName("downsampling_method")>]
        DownsamplingMethod: TypesSamplingMethod option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("rollover")>]
        Rollover: TypesDataStreamLifecycleRolloverConditions option
    }

    /// <summary>
    /// The failure store lifecycle configures the data stream lifecycle configuration for failure indices.
    /// </summary>
    and TypesFailureStoreLifecycle = {
        [<JsonPropertyName("data_retention")>]
        DataRetention: Duration option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
    }

    /// <summary>
    /// Data stream failure store contains the configuration of the failure store for a given data stream.
    /// </summary>
    and TypesDataStreamFailureStore = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesFailureStoreLifecycle option
    }

    /// <summary>
    /// Data stream options contain the configuration of data stream level features for a given data stream, for example,
    /// the failure store configuration.
    /// </summary>
    and TypesDataStreamOptions = {
        [<JsonPropertyName("failure_store")>]
        FailureStore: TypesDataStreamFailureStore option
    }

    and TypesComponentTemplateSummary = {
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("settings")>]
        Settings: Map<string, TypesIndexSettings> option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAliasDefinition> option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycleWithRollover option
        [<JsonPropertyName("data_stream_options")>]
        DataStreamOptions: TypesDataStreamOptions option
    }

    and TypesComponentTemplateNode = {
        [<JsonPropertyName("template")>]
        Template: TypesComponentTemplateSummary
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("deprecated")>]
        Deprecated: bool option
        [<JsonPropertyName("created_date")>]
        CreatedDate: DateTime option
        [<JsonPropertyName("created_date_millis")>]
        CreatedDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: DateTime option
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis option
    }

    and TypesComponentTemplate = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("component_template")>]
        ComponentTemplate: TypesComponentTemplateNode
    }

    and LevelConverter() =
        inherit JsonConverter<Level>()

        override _.Write(writer: Utf8JsonWriter, value: Level, _options: JsonSerializerOptions) =
            let str =
                match value with
                | Level.Cluster -> "cluster"
                | Level.Indices -> "indices"
                | Level.Shards -> "shards"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cluster" -> Level.Cluster
            | "indices" -> Level.Indices
            | "shards" -> Level.Shards
            | s -> failwith $"Unknown Level: {s}"

    and [<JsonConverter(typeof<LevelConverter>)>]
        Level =
        | Cluster
        | Indices
        | Shards
        with
        override this.ToString() =
            match this with
            | Cluster -> "cluster"
            | Indices -> "indices"
            | Shards -> "shards"

    and WaitForEventsConverter() =
        inherit JsonConverter<WaitForEvents>()

        override _.Write(writer: Utf8JsonWriter, value: WaitForEvents, _options: JsonSerializerOptions) =
            let str =
                match value with
                | WaitForEvents.Immediate -> "immediate"
                | WaitForEvents.Urgent -> "urgent"
                | WaitForEvents.High -> "high"
                | WaitForEvents.Normal -> "normal"
                | WaitForEvents.Low -> "low"
                | WaitForEvents.Languid -> "languid"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "immediate" -> WaitForEvents.Immediate
            | "urgent" -> WaitForEvents.Urgent
            | "high" -> WaitForEvents.High
            | "normal" -> WaitForEvents.Normal
            | "low" -> WaitForEvents.Low
            | "languid" -> WaitForEvents.Languid
            | s -> failwith $"Unknown WaitForEvents: {s}"

    and [<JsonConverter(typeof<WaitForEventsConverter>)>]
        WaitForEvents =
        | Immediate
        | Urgent
        | High
        | Normal
        | Low
        | Languid
        with
        override this.ToString() =
            match this with
            | Immediate -> "immediate"
            | Urgent -> "urgent"
            | High -> "high"
            | Normal -> "normal"
            | Low -> "low"
            | Languid -> "languid"

    and HealthWaitForNodes = obj

    and HealthShardHealthStats = {
        [<JsonPropertyName("active_shards")>]
        ActiveShards: float
        [<JsonPropertyName("initializing_shards")>]
        InitializingShards: float
        [<JsonPropertyName("primary_active")>]
        PrimaryActive: bool
        [<JsonPropertyName("relocating_shards")>]
        RelocatingShards: float
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("unassigned_shards")>]
        UnassignedShards: float
        [<JsonPropertyName("unassigned_primary_shards")>]
        UnassignedPrimaryShards: float
    }

    and HealthIndexHealthStats = {
        [<JsonPropertyName("active_primary_shards")>]
        ActivePrimaryShards: float
        [<JsonPropertyName("active_shards")>]
        ActiveShards: float
        [<JsonPropertyName("initializing_shards")>]
        InitializingShards: float
        [<JsonPropertyName("number_of_replicas")>]
        NumberOfReplicas: float
        [<JsonPropertyName("number_of_shards")>]
        NumberOfShards: float
        [<JsonPropertyName("relocating_shards")>]
        RelocatingShards: float
        [<JsonPropertyName("shards")>]
        Shards: Map<string, HealthShardHealthStats> option
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("unassigned_shards")>]
        UnassignedShards: float
        [<JsonPropertyName("unassigned_primary_shards")>]
        UnassignedPrimaryShards: float
    }

    and HealthHealthResponseBody = {
        [<JsonPropertyName("active_primary_shards")>]
        ActivePrimaryShards: float
        [<JsonPropertyName("active_shards")>]
        ActiveShards: float
        [<JsonPropertyName("active_shards_percent")>]
        ActiveShardsPercent: string option
        [<JsonPropertyName("active_shards_percent_as_number")>]
        ActiveShardsPercentAsNumber: float
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("delayed_unassigned_shards")>]
        DelayedUnassignedShards: float
        [<JsonPropertyName("indices")>]
        Indices: Map<string, HealthIndexHealthStats> option
        [<JsonPropertyName("initializing_shards")>]
        InitializingShards: float
        [<JsonPropertyName("number_of_data_nodes")>]
        NumberOfDataNodes: float
        [<JsonPropertyName("number_of_in_flight_fetch")>]
        NumberOfInFlightFetch: float
        [<JsonPropertyName("number_of_nodes")>]
        NumberOfNodes: float
        [<JsonPropertyName("number_of_pending_tasks")>]
        NumberOfPendingTasks: float
        [<JsonPropertyName("relocating_shards")>]
        RelocatingShards: float
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("task_max_waiting_in_queue")>]
        TaskMaxWaitingInQueue: Duration option
        [<JsonPropertyName("task_max_waiting_in_queue_millis")>]
        TaskMaxWaitingInQueueMillis: DurationValueUnitMillis
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool
        [<JsonPropertyName("unassigned_primary_shards")>]
        UnassignedPrimaryShards: float
        [<JsonPropertyName("unassigned_shards")>]
        UnassignedShards: float
    }

    and ClusterInfoTargetConverter() =
        inherit JsonConverter<ClusterInfoTarget>()

        override _.Write(writer: Utf8JsonWriter, value: ClusterInfoTarget, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ClusterInfoTarget.All -> "_all"
                | ClusterInfoTarget.Http -> "http"
                | ClusterInfoTarget.Ingest -> "ingest"
                | ClusterInfoTarget.ThreadPool -> "thread_pool"
                | ClusterInfoTarget.Script -> "script"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> ClusterInfoTarget.All
            | "http" -> ClusterInfoTarget.Http
            | "ingest" -> ClusterInfoTarget.Ingest
            | "thread_pool" -> ClusterInfoTarget.ThreadPool
            | "script" -> ClusterInfoTarget.Script
            | s -> failwith $"Unknown ClusterInfoTarget: {s}"

    and [<JsonConverter(typeof<ClusterInfoTargetConverter>)>]
        ClusterInfoTarget =
        | All
        | Http
        | Ingest
        | ThreadPool
        | Script
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | Http -> "http"
            | Ingest -> "ingest"
            | ThreadPool -> "thread_pool"
            | Script -> "script"

    and ClusterInfoTargets = obj

    and TypesClient = {
        [<JsonPropertyName("id")>]
        Id: float option
        [<JsonPropertyName("agent")>]
        Agent: string option
        [<JsonPropertyName("local_address")>]
        LocalAddress: string option
        [<JsonPropertyName("remote_address")>]
        RemoteAddress: string option
        [<JsonPropertyName("last_uri")>]
        LastUri: string option
        [<JsonPropertyName("opened_time_millis")>]
        OpenedTimeMillis: float option
        [<JsonPropertyName("closed_time_millis")>]
        ClosedTimeMillis: float option
        [<JsonPropertyName("last_request_time_millis")>]
        LastRequestTimeMillis: float option
        [<JsonPropertyName("request_count")>]
        RequestCount: float option
        [<JsonPropertyName("request_size_bytes")>]
        RequestSizeBytes: float option
        [<JsonPropertyName("x_opaque_id")>]
        XOpaqueId: string option
    }

    and TypesSizeHttpHistogram = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("ge_bytes")>]
        GeBytes: float option
        [<JsonPropertyName("lt_bytes")>]
        LtBytes: float option
    }

    and TypesHttpRouteRequests = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("total_size_in_bytes")>]
        TotalSizeInBytes: float
        [<JsonPropertyName("size_histogram")>]
        SizeHistogram: TypesSizeHttpHistogram array
    }

    and TypesTimeHttpHistogram = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("ge_millis")>]
        GeMillis: float option
        [<JsonPropertyName("lt_millis")>]
        LtMillis: float option
    }

    and TypesHttpRouteResponses = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("total_size_in_bytes")>]
        TotalSizeInBytes: float
        [<JsonPropertyName("handling_time_histogram")>]
        HandlingTimeHistogram: TypesTimeHttpHistogram array
        [<JsonPropertyName("size_histogram")>]
        SizeHistogram: TypesSizeHttpHistogram array
    }

    and TypesHttpRoute = {
        [<JsonPropertyName("requests")>]
        Requests: TypesHttpRouteRequests
        [<JsonPropertyName("responses")>]
        Responses: TypesHttpRouteResponses
    }

    and TypesHttp = {
        [<JsonPropertyName("current_open")>]
        CurrentOpen: float option
        [<JsonPropertyName("total_opened")>]
        TotalOpened: float option
        [<JsonPropertyName("clients")>]
        Clients: TypesClient array option
        [<JsonPropertyName("routes")>]
        Routes: Map<string, TypesHttpRoute>
    }

    and TypesProcessor = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("current")>]
        Current: float option
        [<JsonPropertyName("failed")>]
        Failed: float option
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis option
    }

    and TypesKeyedProcessor = {
        [<JsonPropertyName("stats")>]
        Stats: TypesProcessor option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesIngestStats = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("processors")>]
        Processors: Map<string, TypesKeyedProcessor> array
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("ingested_as_first_pipeline_in_bytes")>]
        IngestedAsFirstPipelineInBytes: float
        [<JsonPropertyName("produced_as_first_pipeline_in_bytes")>]
        ProducedAsFirstPipelineInBytes: float
    }

    and TypesIngestTotal = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
    }

    and TypesIngest = {
        [<JsonPropertyName("pipelines")>]
        Pipelines: Map<string, TypesIngestStats> option
        [<JsonPropertyName("total")>]
        Total: TypesIngestTotal option
    }

    and TypesThreadCount = {
        [<JsonPropertyName("active")>]
        Active: float option
        [<JsonPropertyName("completed")>]
        Completed: float option
        [<JsonPropertyName("largest")>]
        Largest: float option
        [<JsonPropertyName("queue")>]
        Queue: float option
        [<JsonPropertyName("rejected")>]
        Rejected: float option
        [<JsonPropertyName("threads")>]
        Threads: float option
    }

    and TypesContext = {
        [<JsonPropertyName("context")>]
        Context: string option
        [<JsonPropertyName("compilations")>]
        Compilations: float option
        [<JsonPropertyName("cache_evictions")>]
        CacheEvictions: float option
        [<JsonPropertyName("compilation_limit_triggered")>]
        CompilationLimitTriggered: float option
    }

    and TypesScripting = {
        [<JsonPropertyName("cache_evictions")>]
        CacheEvictions: float option
        [<JsonPropertyName("compilations")>]
        Compilations: float option
        [<JsonPropertyName("compilations_history")>]
        CompilationsHistory: Map<string, float> option
        [<JsonPropertyName("compilation_limit_triggered")>]
        CompilationLimitTriggered: float option
        [<JsonPropertyName("contexts")>]
        Contexts: TypesContext array option
    }

    and PendingTasksPendingTask = {
        [<JsonPropertyName("executing")>]
        Executing: bool
        [<JsonPropertyName("insert_order")>]
        InsertOrder: float
        [<JsonPropertyName("priority")>]
        Priority: string
        [<JsonPropertyName("source")>]
        Source: string
        [<JsonPropertyName("time_in_queue")>]
        TimeInQueue: Duration option
        [<JsonPropertyName("time_in_queue_millis")>]
        TimeInQueueMillis: DurationValueUnitMillis
    }

    and TypesAlias = {
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("index_routing")>]
        IndexRouting: Routing option
        [<JsonPropertyName("is_hidden")>]
        IsHidden: bool option
        [<JsonPropertyName("is_write_index")>]
        IsWriteIndex: bool option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("search_routing")>]
        SearchRouting: Routing option
    }

    /// <summary>
    /// Template equivalent of FailureStoreLifecycle that allows nullable values.
    /// </summary>
    and TypesFailureStoreLifecycleTemplate = {
        [<JsonPropertyName("data_retention")>]
        DataRetention: System.Text.Json.JsonElement option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
    }

    /// <summary>
    /// Template equivalent of DataStreamFailureStore that allows nullable values.
    /// </summary>
    and TypesDataStreamFailureStoreTemplate = {
        [<JsonPropertyName("enabled")>]
        Enabled: System.Text.Json.JsonElement option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: System.Text.Json.JsonElement option
    }

    /// <summary>
    /// Data stream options template contains the same information as DataStreamOptions but allows them to be set explicitly to null.
    /// </summary>
    and TypesDataStreamOptionsTemplate = {
        [<JsonPropertyName("failure_store")>]
        FailureStore: System.Text.Json.JsonElement option
    }

    and PutIndexTemplateIndexTemplateMapping = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAlias> option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycle option
        [<JsonPropertyName("data_stream_options")>]
        DataStreamOptions: System.Text.Json.JsonElement option
    }

    and RemoteInfoClusterRemoteProxyInfo = {
        [<JsonPropertyName("mode")>]
        Mode: string
        [<JsonPropertyName("connected")>]
        Connected: bool
        [<JsonPropertyName("initial_connect_timeout")>]
        InitialConnectTimeout: Duration
        [<JsonPropertyName("skip_unavailable")>]
        SkipUnavailable: bool
        [<JsonPropertyName("proxy_address")>]
        ProxyAddress: string
        [<JsonPropertyName("server_name")>]
        ServerName: string
        [<JsonPropertyName("num_proxy_sockets_connected")>]
        NumProxySocketsConnected: float
        [<JsonPropertyName("max_proxy_socket_connections")>]
        MaxProxySocketConnections: float
        [<JsonPropertyName("cluster_credentials")>]
        ClusterCredentials: string option
    }

    and RemoteInfoClusterRemoteSniffInfo = {
        [<JsonPropertyName("mode")>]
        Mode: string
        [<JsonPropertyName("connected")>]
        Connected: bool
        [<JsonPropertyName("max_connections_per_cluster")>]
        MaxConnectionsPerCluster: float
        [<JsonPropertyName("num_nodes_connected")>]
        NumNodesConnected: float
        [<JsonPropertyName("initial_connect_timeout")>]
        InitialConnectTimeout: Duration
        [<JsonPropertyName("skip_unavailable")>]
        SkipUnavailable: bool
        [<JsonPropertyName("seeds")>]
        Seeds: string array
    }

    and RemoteInfoClusterRemoteInfoConverter() =
        inherit JsonConverter<RemoteInfoClusterRemoteInfo>()

        override _.Write(writer: Utf8JsonWriter, value: RemoteInfoClusterRemoteInfo, options: JsonSerializerOptions) =
            match value with
            | RemoteInfoClusterRemoteInfo.Proxy v -> JsonSerializer.Serialize(writer, v, options)
            | RemoteInfoClusterRemoteInfo.Sniff v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("mode") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "proxy" -> RemoteInfoClusterRemoteInfo.Proxy (JsonSerializer.Deserialize<RemoteInfoClusterRemoteProxyInfo>(json, options))
            | "sniff" -> RemoteInfoClusterRemoteInfo.Sniff (JsonSerializer.Deserialize<RemoteInfoClusterRemoteSniffInfo>(json, options))
            | s -> failwith $"Unknown RemoteInfoClusterRemoteInfo type: {s}"

    and [<JsonConverter(typeof<RemoteInfoClusterRemoteInfoConverter>)>]
        RemoteInfoClusterRemoteInfo =
        | Proxy of RemoteInfoClusterRemoteProxyInfo
        | Sniff of RemoteInfoClusterRemoteSniffInfo

    and RemoteInfoClusterRemoteInfoTypeConverter() =
        inherit JsonConverter<RemoteInfoClusterRemoteInfoType>()

        override _.Write(writer: Utf8JsonWriter, value: RemoteInfoClusterRemoteInfoType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | RemoteInfoClusterRemoteInfoType.Proxy -> "proxy"
                | RemoteInfoClusterRemoteInfoType.Sniff -> "sniff"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "proxy" -> RemoteInfoClusterRemoteInfoType.Proxy
            | "sniff" -> RemoteInfoClusterRemoteInfoType.Sniff
            | s -> failwith $"Unknown RemoteInfoClusterRemoteInfoType: {s}"

    and [<JsonConverter(typeof<RemoteInfoClusterRemoteInfoTypeConverter>)>]
        RemoteInfoClusterRemoteInfoType =
        | Proxy
        | Sniff
        with
        override this.ToString() =
            match this with
            | Proxy -> "proxy"
            | Sniff -> "sniff"

    and RerouteCommandAllocatePrimaryAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("node")>]
        Node: string
        [<JsonPropertyName("accept_data_loss")>]
        AcceptDataLoss: bool
    }

    and RerouteCommandAllocateReplicaAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("node")>]
        Node: string
    }

    and RerouteCommandCancelAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("node")>]
        Node: string
        [<JsonPropertyName("allow_primary")>]
        AllowPrimary: bool option
    }

    and RerouteCommandMoveAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("from_node")>]
        FromNode: string
        [<JsonPropertyName("to_node")>]
        ToNode: string
    }

    and RerouteCommand = {
        [<JsonPropertyName("cancel")>]
        Cancel: RerouteCommandCancelAction option
        [<JsonPropertyName("move")>]
        Move: RerouteCommandMoveAction option
        [<JsonPropertyName("allocate_replica")>]
        AllocateReplica: RerouteCommandAllocateReplicaAction option
        [<JsonPropertyName("allocate_stale_primary")>]
        AllocateStalePrimary: RerouteCommandAllocatePrimaryAction option
        [<JsonPropertyName("allocate_empty_primary")>]
        AllocateEmptyPrimary: RerouteCommandAllocatePrimaryAction option
    }

    and RerouteRerouteDecision = {
        [<JsonPropertyName("decider")>]
        Decider: string
        [<JsonPropertyName("decision")>]
        Decision: string
        [<JsonPropertyName("explanation")>]
        Explanation: string
    }

    and NodeName = string

    and RerouteRerouteParameters = {
        [<JsonPropertyName("allow_primary")>]
        AllowPrimary: bool
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("node")>]
        Node: NodeName
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("from_node")>]
        FromNode: NodeName option
        [<JsonPropertyName("to_node")>]
        ToNode: NodeName option
    }

    and RerouteRerouteExplanation = {
        [<JsonPropertyName("command")>]
        Command: string
        [<JsonPropertyName("decisions")>]
        Decisions: RerouteRerouteDecision array
        [<JsonPropertyName("parameters")>]
        Parameters: RerouteRerouteParameters
    }

    and StateClusterStateMetricConverter() =
        inherit JsonConverter<StateClusterStateMetric>()

        override _.Write(writer: Utf8JsonWriter, value: StateClusterStateMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StateClusterStateMetric.All -> "_all"
                | StateClusterStateMetric.Version -> "version"
                | StateClusterStateMetric.MasterNode -> "master_node"
                | StateClusterStateMetric.Blocks -> "blocks"
                | StateClusterStateMetric.Nodes -> "nodes"
                | StateClusterStateMetric.Metadata -> "metadata"
                | StateClusterStateMetric.RoutingTable -> "routing_table"
                | StateClusterStateMetric.RoutingNodes -> "routing_nodes"
                | StateClusterStateMetric.Customs -> "customs"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> StateClusterStateMetric.All
            | "version" -> StateClusterStateMetric.Version
            | "master_node" -> StateClusterStateMetric.MasterNode
            | "blocks" -> StateClusterStateMetric.Blocks
            | "nodes" -> StateClusterStateMetric.Nodes
            | "metadata" -> StateClusterStateMetric.Metadata
            | "routing_table" -> StateClusterStateMetric.RoutingTable
            | "routing_nodes" -> StateClusterStateMetric.RoutingNodes
            | "customs" -> StateClusterStateMetric.Customs
            | s -> failwith $"Unknown StateClusterStateMetric: {s}"

    and [<JsonConverter(typeof<StateClusterStateMetricConverter>)>]
        StateClusterStateMetric =
        | All
        | Version
        | MasterNode
        | Blocks
        | Nodes
        | Metadata
        | RoutingTable
        | RoutingNodes
        | Customs
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | Version -> "version"
            | MasterNode -> "master_node"
            | Blocks -> "blocks"
            | Nodes -> "nodes"
            | Metadata -> "metadata"
            | RoutingTable -> "routing_table"
            | RoutingNodes -> "routing_nodes"
            | Customs -> "customs"

    and StateClusterStateMetrics = obj

    and StatsCCSUsageTimeValue = {
        [<JsonPropertyName("max")>]
        Max: DurationValueUnitMillis
        [<JsonPropertyName("avg")>]
        Avg: DurationValueUnitMillis
        [<JsonPropertyName("p90")>]
        P90: DurationValueUnitMillis
    }

    and StatsCCSUsageClusterStats = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("skipped")>]
        Skipped: float
        [<JsonPropertyName("took")>]
        Took: StatsCCSUsageTimeValue
    }

    and StatsCCSUsageStats = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("success")>]
        Success: float
        [<JsonPropertyName("skipped")>]
        Skipped: float
        [<JsonPropertyName("took")>]
        Took: StatsCCSUsageTimeValue
        [<JsonPropertyName("took_mrt_true")>]
        TookMrtTrue: StatsCCSUsageTimeValue option
        [<JsonPropertyName("took_mrt_false")>]
        TookMrtFalse: StatsCCSUsageTimeValue option
        [<JsonPropertyName("remotes_per_search_max")>]
        RemotesPerSearchMax: float
        [<JsonPropertyName("remotes_per_search_avg")>]
        RemotesPerSearchAvg: float
        [<JsonPropertyName("failure_reasons")>]
        FailureReasons: Map<string, float>
        [<JsonPropertyName("features")>]
        Features: Map<string, float>
        [<JsonPropertyName("clients")>]
        Clients: Map<string, float>
        [<JsonPropertyName("clusters")>]
        Clusters: Map<string, StatsCCSUsageClusterStats>
    }

    and StatsRemoteClusterInfo = {
        [<JsonPropertyName("cluster_uuid")>]
        ClusterUuid: string
        [<JsonPropertyName("mode")>]
        Mode: string
        [<JsonPropertyName("skip_unavailable")>]
        SkipUnavailable: bool
        [<JsonPropertyName("transport.compress")>]
        TransportCompress: string
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("version")>]
        Version: VersionString array
        [<JsonPropertyName("nodes_count")>]
        NodesCount: float
        [<JsonPropertyName("shards_count")>]
        ShardsCount: float
        [<JsonPropertyName("indices_count")>]
        IndicesCount: float
        [<JsonPropertyName("indices_total_size_in_bytes")>]
        IndicesTotalSizeInBytes: float
        [<JsonPropertyName("indices_total_size")>]
        IndicesTotalSize: string option
        [<JsonPropertyName("max_heap_in_bytes")>]
        MaxHeapInBytes: float
        [<JsonPropertyName("max_heap")>]
        MaxHeap: string option
        [<JsonPropertyName("mem_total_in_bytes")>]
        MemTotalInBytes: float
        [<JsonPropertyName("mem_total")>]
        MemTotal: string option
    }

    and StatsCCSStats = {
        [<JsonPropertyName("clusters")>]
        Clusters: Map<string, StatsRemoteClusterInfo> option
        [<JsonPropertyName("_search")>]
        Search: StatsCCSUsageStats
        [<JsonPropertyName("_esql")>]
        Esql: StatsCCSUsageStats option
    }

    and FieldSizeUsage = {
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
    }

    and CompletionStats = {
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, FieldSizeUsage> option
    }

    and DocStats = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("deleted")>]
        Deleted: float option
        [<JsonPropertyName("total_size_in_bytes")>]
        TotalSizeInBytes: float
        [<JsonPropertyName("total_size")>]
        TotalSize: ByteSize option
    }

    and FieldMemoryUsage = {
        [<JsonPropertyName("memory_size")>]
        MemorySize: ByteSize option
        [<JsonPropertyName("memory_size_in_bytes")>]
        MemorySizeInBytes: float
    }

    and GlobalOrdinalFieldStats = {
        [<JsonPropertyName("build_time_in_millis")>]
        BuildTimeInMillis: UnitMillis
        [<JsonPropertyName("build_time")>]
        BuildTime: string option
        [<JsonPropertyName("shard_max_value_count")>]
        ShardMaxValueCount: float
    }

    and GlobalOrdinalsStats = {
        [<JsonPropertyName("build_time_in_millis")>]
        BuildTimeInMillis: UnitMillis
        [<JsonPropertyName("build_time")>]
        BuildTime: string option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, GlobalOrdinalFieldStats> option
    }

    and FielddataStats = {
        [<JsonPropertyName("evictions")>]
        Evictions: float option
        [<JsonPropertyName("memory_size")>]
        MemorySize: ByteSize option
        [<JsonPropertyName("memory_size_in_bytes")>]
        MemorySizeInBytes: float
        [<JsonPropertyName("fields")>]
        Fields: Map<string, FieldMemoryUsage> option
        [<JsonPropertyName("global_ordinals")>]
        GlobalOrdinals: GlobalOrdinalsStats
    }

    and QueryCacheStats = {
        [<JsonPropertyName("cache_count")>]
        CacheCount: float
        [<JsonPropertyName("cache_size")>]
        CacheSize: float
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("hit_count")>]
        HitCount: float
        [<JsonPropertyName("memory_size")>]
        MemorySize: ByteSize option
        [<JsonPropertyName("memory_size_in_bytes")>]
        MemorySizeInBytes: float
        [<JsonPropertyName("miss_count")>]
        MissCount: float
        [<JsonPropertyName("total_count")>]
        TotalCount: float
    }

    and StatsShardFileSizeInfo = {
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("min_size_in_bytes")>]
        MinSizeInBytes: float option
        [<JsonPropertyName("max_size_in_bytes")>]
        MaxSizeInBytes: float option
        [<JsonPropertyName("average_size_in_bytes")>]
        AverageSizeInBytes: float option
        [<JsonPropertyName("count")>]
        Count: float option
    }

    and SegmentsStats = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("doc_values_memory")>]
        DocValuesMemory: ByteSize option
        [<JsonPropertyName("doc_values_memory_in_bytes")>]
        DocValuesMemoryInBytes: float
        [<JsonPropertyName("file_sizes")>]
        FileSizes: Map<string, StatsShardFileSizeInfo>
        [<JsonPropertyName("fixed_bit_set")>]
        FixedBitSet: ByteSize option
        [<JsonPropertyName("fixed_bit_set_memory_in_bytes")>]
        FixedBitSetMemoryInBytes: float
        [<JsonPropertyName("index_writer_memory")>]
        IndexWriterMemory: ByteSize option
        [<JsonPropertyName("index_writer_memory_in_bytes")>]
        IndexWriterMemoryInBytes: float
        [<JsonPropertyName("max_unsafe_auto_id_timestamp")>]
        MaxUnsafeAutoIdTimestamp: float
        [<JsonPropertyName("memory")>]
        Memory: ByteSize option
        [<JsonPropertyName("memory_in_bytes")>]
        MemoryInBytes: float
        [<JsonPropertyName("norms_memory")>]
        NormsMemory: ByteSize option
        [<JsonPropertyName("norms_memory_in_bytes")>]
        NormsMemoryInBytes: float
        [<JsonPropertyName("points_memory")>]
        PointsMemory: ByteSize option
        [<JsonPropertyName("points_memory_in_bytes")>]
        PointsMemoryInBytes: float
        [<JsonPropertyName("stored_fields_memory_in_bytes")>]
        StoredFieldsMemoryInBytes: float
        [<JsonPropertyName("stored_fields_memory")>]
        StoredFieldsMemory: ByteSize option
        [<JsonPropertyName("terms_memory_in_bytes")>]
        TermsMemoryInBytes: float
        [<JsonPropertyName("terms_memory")>]
        TermsMemory: ByteSize option
        [<JsonPropertyName("term_vectors_memory")>]
        TermVectorsMemory: ByteSize option
        [<JsonPropertyName("term_vectors_memory_in_bytes")>]
        TermVectorsMemoryInBytes: float
        [<JsonPropertyName("version_map_memory")>]
        VersionMapMemory: ByteSize option
        [<JsonPropertyName("version_map_memory_in_bytes")>]
        VersionMapMemoryInBytes: float
    }

    and StoreStats = {
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("reserved")>]
        Reserved: ByteSize option
        [<JsonPropertyName("reserved_in_bytes")>]
        ReservedInBytes: float
        [<JsonPropertyName("total_data_set_size")>]
        TotalDataSetSize: ByteSize option
        [<JsonPropertyName("total_data_set_size_in_bytes")>]
        TotalDataSetSizeInBytes: float option
    }

    and StatsFieldTypes = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("index_count")>]
        IndexCount: float
        [<JsonPropertyName("indexed_vector_count")>]
        IndexedVectorCount: float option
        [<JsonPropertyName("indexed_vector_dim_max")>]
        IndexedVectorDimMax: float option
        [<JsonPropertyName("indexed_vector_dim_min")>]
        IndexedVectorDimMin: float option
        [<JsonPropertyName("script_count")>]
        ScriptCount: float option
        [<JsonPropertyName("vector_index_type_count")>]
        VectorIndexTypeCount: Map<string, float> option
        [<JsonPropertyName("vector_similarity_type_count")>]
        VectorSimilarityTypeCount: Map<string, float> option
        [<JsonPropertyName("vector_element_type_count")>]
        VectorElementTypeCount: Map<string, float> option
    }

    and StatsSynonymsStats = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("index_count")>]
        IndexCount: float
    }

    and StatsCharFilterTypes = {
        [<JsonPropertyName("analyzer_types")>]
        AnalyzerTypes: StatsFieldTypes array
        [<JsonPropertyName("built_in_analyzers")>]
        BuiltInAnalyzers: StatsFieldTypes array
        [<JsonPropertyName("built_in_char_filters")>]
        BuiltInCharFilters: StatsFieldTypes array
        [<JsonPropertyName("built_in_filters")>]
        BuiltInFilters: StatsFieldTypes array
        [<JsonPropertyName("built_in_tokenizers")>]
        BuiltInTokenizers: StatsFieldTypes array
        [<JsonPropertyName("char_filter_types")>]
        CharFilterTypes: StatsFieldTypes array
        [<JsonPropertyName("filter_types")>]
        FilterTypes: StatsFieldTypes array
        [<JsonPropertyName("tokenizer_types")>]
        TokenizerTypes: StatsFieldTypes array
        [<JsonPropertyName("synonyms")>]
        Synonyms: Map<string, StatsSynonymsStats>
    }

    and StatsClusterShardMetrics = {
        [<JsonPropertyName("avg")>]
        Avg: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min")>]
        Min: float
    }

    and StatsClusterIndicesShardsIndex = {
        [<JsonPropertyName("primaries")>]
        Primaries: StatsClusterShardMetrics
        [<JsonPropertyName("replication")>]
        Replication: StatsClusterShardMetrics
        [<JsonPropertyName("shards")>]
        Shards: StatsClusterShardMetrics
    }

    /// <summary>
    /// Contains statistics about shards assigned to selected nodes.
    /// </summary>
    and StatsClusterIndicesShards = {
        [<JsonPropertyName("index")>]
        Index: StatsClusterIndicesShardsIndex option
        [<JsonPropertyName("primaries")>]
        Primaries: float option
        [<JsonPropertyName("replication")>]
        Replication: float option
        [<JsonPropertyName("total")>]
        Total: float option
    }

    and StatsDenseVectorOffHeapStats = {
        [<JsonPropertyName("total_size_bytes")>]
        TotalSizeBytes: float
        [<JsonPropertyName("total_size")>]
        TotalSize: ByteSize option
        [<JsonPropertyName("total_veb_size_bytes")>]
        TotalVebSizeBytes: float
        [<JsonPropertyName("total_veb_size")>]
        TotalVebSize: ByteSize option
        [<JsonPropertyName("total_vec_size_bytes")>]
        TotalVecSizeBytes: float
        [<JsonPropertyName("total_vec_size")>]
        TotalVecSize: ByteSize option
        [<JsonPropertyName("total_veq_size_bytes")>]
        TotalVeqSizeBytes: float
        [<JsonPropertyName("total_veq_size")>]
        TotalVeqSize: ByteSize option
        [<JsonPropertyName("total_vex_size_bytes")>]
        TotalVexSizeBytes: float
        [<JsonPropertyName("total_vex_size")>]
        TotalVexSize: ByteSize option
        [<JsonPropertyName("total_cenif_size_bytes")>]
        TotalCenifSizeBytes: float
        [<JsonPropertyName("total_cenif_size")>]
        TotalCenifSize: ByteSize option
        [<JsonPropertyName("total_clivf_size_bytes")>]
        TotalClivfSizeBytes: float
        [<JsonPropertyName("total_clivf_size")>]
        TotalClivfSize: ByteSize option
        [<JsonPropertyName("fielddata")>]
        Fielddata: Map<string, Map<string, float>> option
    }

    and StatsDenseVectorStats = {
        [<JsonPropertyName("value_count")>]
        ValueCount: float
        [<JsonPropertyName("off_heap")>]
        OffHeap: StatsDenseVectorOffHeapStats option
    }

    and StatsRuntimeFieldTypes = {
        [<JsonPropertyName("chars_max")>]
        CharsMax: float
        [<JsonPropertyName("chars_total")>]
        CharsTotal: float
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("doc_max")>]
        DocMax: float
        [<JsonPropertyName("doc_total")>]
        DocTotal: float
        [<JsonPropertyName("index_count")>]
        IndexCount: float
        [<JsonPropertyName("lang")>]
        Lang: string array
        [<JsonPropertyName("lines_max")>]
        LinesMax: float
        [<JsonPropertyName("lines_total")>]
        LinesTotal: float
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("scriptless_count")>]
        ScriptlessCount: float
        [<JsonPropertyName("shadowed_count")>]
        ShadowedCount: float
        [<JsonPropertyName("source_max")>]
        SourceMax: float
        [<JsonPropertyName("source_total")>]
        SourceTotal: float
    }

    and StatsFieldTypesMappings = {
        [<JsonPropertyName("field_types")>]
        FieldTypes: StatsFieldTypes array
        [<JsonPropertyName("runtime_field_types")>]
        RuntimeFieldTypes: StatsRuntimeFieldTypes array
        [<JsonPropertyName("total_field_count")>]
        TotalFieldCount: float option
        [<JsonPropertyName("total_deduplicated_field_count")>]
        TotalDeduplicatedFieldCount: float option
        [<JsonPropertyName("total_deduplicated_mapping_size")>]
        TotalDeduplicatedMappingSize: ByteSize option
        [<JsonPropertyName("total_deduplicated_mapping_size_in_bytes")>]
        TotalDeduplicatedMappingSizeInBytes: float option
        [<JsonPropertyName("source_modes")>]
        SourceModes: Map<string, float>
    }

    and StatsIndicesVersions = {
        [<JsonPropertyName("index_count")>]
        IndexCount: float
        [<JsonPropertyName("primary_shard_count")>]
        PrimaryShardCount: float
        [<JsonPropertyName("total_primary_bytes")>]
        TotalPrimaryBytes: float
        [<JsonPropertyName("total_primary_size")>]
        TotalPrimarySize: ByteSize option
        [<JsonPropertyName("version")>]
        Version: VersionString
    }

    and StatsExtendedTextSimilarityRetrieverUsage = {
        [<JsonPropertyName("chunk_rescorer")>]
        ChunkRescorer: float option
    }

    and StatsExtendedRetrieversSearchUsage = {
        [<JsonPropertyName("text_similarity_reranker")>]
        TextSimilarityReranker: StatsExtendedTextSimilarityRetrieverUsage option
    }

    and StatsExtendedSearchUsage = {
        [<JsonPropertyName("retrievers")>]
        Retrievers: StatsExtendedRetrieversSearchUsage option
    }

    and StatsSearchUsageStats = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("queries")>]
        Queries: Map<string, float>
        [<JsonPropertyName("rescorers")>]
        Rescorers: Map<string, float>
        [<JsonPropertyName("sections")>]
        Sections: Map<string, float>
        [<JsonPropertyName("retrievers")>]
        Retrievers: Map<string, float>
        [<JsonPropertyName("extended")>]
        Extended: StatsExtendedSearchUsage
    }

    and StatsSparseVectorStats = {
        [<JsonPropertyName("value_count")>]
        ValueCount: float
    }

    and StatsClusterIndices = {
        [<JsonPropertyName("analysis")>]
        Analysis: StatsCharFilterTypes option
        [<JsonPropertyName("completion")>]
        Completion: CompletionStats
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("docs")>]
        Docs: DocStats
        [<JsonPropertyName("fielddata")>]
        Fielddata: FielddataStats
        [<JsonPropertyName("query_cache")>]
        QueryCache: QueryCacheStats
        [<JsonPropertyName("search")>]
        Search: StatsSearchUsageStats
        [<JsonPropertyName("segments")>]
        Segments: SegmentsStats
        [<JsonPropertyName("shards")>]
        Shards: StatsClusterIndicesShards
        [<JsonPropertyName("store")>]
        Store: StoreStats
        [<JsonPropertyName("mappings")>]
        Mappings: StatsFieldTypesMappings option
        [<JsonPropertyName("versions")>]
        Versions: StatsIndicesVersions array option
        [<JsonPropertyName("dense_vector")>]
        DenseVector: StatsDenseVectorStats
        [<JsonPropertyName("sparse_vector")>]
        SparseVector: StatsSparseVectorStats
    }

    and PluginStats = {
        [<JsonPropertyName("classname")>]
        Classname: string
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("elasticsearch_version")>]
        ElasticsearchVersion: VersionString
        [<JsonPropertyName("extended_plugins")>]
        ExtendedPlugins: string array
        [<JsonPropertyName("has_native_controller")>]
        HasNativeController: bool
        [<JsonPropertyName("java_version")>]
        JavaVersion: VersionString
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("licensed")>]
        Licensed: bool
    }

    and StatsClusterFileSystem = {
        [<JsonPropertyName("path")>]
        Path: string option
        [<JsonPropertyName("mount")>]
        Mount: string option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("available_in_bytes")>]
        AvailableInBytes: float option
        [<JsonPropertyName("available")>]
        Available: ByteSize option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float option
        [<JsonPropertyName("free")>]
        Free: ByteSize option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float option
        [<JsonPropertyName("total")>]
        Total: ByteSize option
        [<JsonPropertyName("low_watermark_free_space")>]
        LowWatermarkFreeSpace: ByteSize option
        [<JsonPropertyName("low_watermark_free_space_in_bytes")>]
        LowWatermarkFreeSpaceInBytes: float option
        [<JsonPropertyName("high_watermark_free_space")>]
        HighWatermarkFreeSpace: ByteSize option
        [<JsonPropertyName("high_watermark_free_space_in_bytes")>]
        HighWatermarkFreeSpaceInBytes: float option
        [<JsonPropertyName("flood_stage_free_space")>]
        FloodStageFreeSpace: ByteSize option
        [<JsonPropertyName("flood_stage_free_space_in_bytes")>]
        FloodStageFreeSpaceInBytes: float option
        [<JsonPropertyName("frozen_flood_stage_free_space")>]
        FrozenFloodStageFreeSpace: ByteSize option
        [<JsonPropertyName("frozen_flood_stage_free_space_in_bytes")>]
        FrozenFloodStageFreeSpaceInBytes: float option
    }

    and StatsClusterProcessor = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
    }

    and StatsClusterIngest = {
        [<JsonPropertyName("number_of_pipelines")>]
        NumberOfPipelines: float
        [<JsonPropertyName("processor_stats")>]
        ProcessorStats: Map<string, StatsClusterProcessor>
    }

    and StatsClusterJvmMemory = {
        [<JsonPropertyName("heap_max_in_bytes")>]
        HeapMaxInBytes: float
        [<JsonPropertyName("heap_max")>]
        HeapMax: ByteSize option
        [<JsonPropertyName("heap_used_in_bytes")>]
        HeapUsedInBytes: float
        [<JsonPropertyName("heap_used")>]
        HeapUsed: ByteSize option
    }

    and StatsClusterJvmVersion = {
        [<JsonPropertyName("bundled_jdk")>]
        BundledJdk: bool
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("using_bundled_jdk")>]
        UsingBundledJdk: bool
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("vm_name")>]
        VmName: string
        [<JsonPropertyName("vm_vendor")>]
        VmVendor: string
        [<JsonPropertyName("vm_version")>]
        VmVersion: VersionString
    }

    and StatsClusterJvm = {
        [<JsonPropertyName("max_uptime_in_millis")>]
        MaxUptimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("max_uptime")>]
        MaxUptime: Duration option
        [<JsonPropertyName("mem")>]
        Mem: StatsClusterJvmMemory
        [<JsonPropertyName("threads")>]
        Threads: float
        [<JsonPropertyName("versions")>]
        Versions: StatsClusterJvmVersion array
    }

    and StatsClusterNetworkTypes = {
        [<JsonPropertyName("http_types")>]
        HttpTypes: Map<string, float>
        [<JsonPropertyName("transport_types")>]
        TransportTypes: Map<string, float>
    }

    and StatsClusterNodeCount = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("coordinating_only")>]
        CoordinatingOnly: float option
        [<JsonPropertyName("data")>]
        Data: float option
        [<JsonPropertyName("data_cold")>]
        DataCold: float option
        [<JsonPropertyName("data_content")>]
        DataContent: float option
        [<JsonPropertyName("data_frozen")>]
        DataFrozen: float option
        [<JsonPropertyName("data_hot")>]
        DataHot: float option
        [<JsonPropertyName("data_warm")>]
        DataWarm: float option
        [<JsonPropertyName("index")>]
        Index: float option
        [<JsonPropertyName("ingest")>]
        Ingest: float option
        [<JsonPropertyName("master")>]
        Master: float option
        [<JsonPropertyName("ml")>]
        Ml: float option
        [<JsonPropertyName("remote_cluster_client")>]
        RemoteClusterClient: float option
        [<JsonPropertyName("search")>]
        Search: float option
        [<JsonPropertyName("transform")>]
        Transform: float option
        [<JsonPropertyName("voting_only")>]
        VotingOnly: float option
    }

    and StatsClusterOperatingSystemArchitecture = {
        [<JsonPropertyName("arch")>]
        Arch: string
        [<JsonPropertyName("count")>]
        Count: float
    }

    and StatsClusterOperatingSystemName = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and StatsClusterOperatingSystemPrettyName = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("pretty_name")>]
        PrettyName: Name
    }

    and StatsOperatingSystemMemoryInfo = {
        [<JsonPropertyName("adjusted_total_in_bytes")>]
        AdjustedTotalInBytes: float option
        [<JsonPropertyName("adjusted_total")>]
        AdjustedTotal: ByteSize option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float
        [<JsonPropertyName("free")>]
        Free: ByteSize option
        [<JsonPropertyName("free_percent")>]
        FreePercent: float
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float
        [<JsonPropertyName("total")>]
        Total: ByteSize option
        [<JsonPropertyName("used_in_bytes")>]
        UsedInBytes: float
        [<JsonPropertyName("used")>]
        Used: ByteSize option
        [<JsonPropertyName("used_percent")>]
        UsedPercent: float
    }

    and StatsClusterOperatingSystem = {
        [<JsonPropertyName("allocated_processors")>]
        AllocatedProcessors: float
        [<JsonPropertyName("architectures")>]
        Architectures: StatsClusterOperatingSystemArchitecture array option
        [<JsonPropertyName("available_processors")>]
        AvailableProcessors: float
        [<JsonPropertyName("mem")>]
        Mem: StatsOperatingSystemMemoryInfo
        [<JsonPropertyName("names")>]
        Names: StatsClusterOperatingSystemName array
        [<JsonPropertyName("pretty_names")>]
        PrettyNames: StatsClusterOperatingSystemPrettyName array
    }

    and StatsClusterProcessCpu = {
        [<JsonPropertyName("percent")>]
        Percent: float
    }

    and StatsClusterProcessOpenFileDescriptors = {
        [<JsonPropertyName("avg")>]
        Avg: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min")>]
        Min: float
    }

    and StatsClusterProcess = {
        [<JsonPropertyName("cpu")>]
        Cpu: StatsClusterProcessCpu
        [<JsonPropertyName("open_file_descriptors")>]
        OpenFileDescriptors: StatsClusterProcessOpenFileDescriptors
    }

    and StatsIndexingPressure = {
        [<JsonPropertyName("memory")>]
        Memory: System.Text.Json.JsonElement
    }

    and StatsNodePackagingType = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("flavor")>]
        Flavor: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and StatsClusterNodes = {
        [<JsonPropertyName("count")>]
        Count: StatsClusterNodeCount
        [<JsonPropertyName("discovery_types")>]
        DiscoveryTypes: Map<string, float>
        [<JsonPropertyName("fs")>]
        Fs: StatsClusterFileSystem
        [<JsonPropertyName("indexing_pressure")>]
        IndexingPressure: StatsIndexingPressure
        [<JsonPropertyName("ingest")>]
        Ingest: StatsClusterIngest
        [<JsonPropertyName("jvm")>]
        Jvm: StatsClusterJvm
        [<JsonPropertyName("network_types")>]
        NetworkTypes: StatsClusterNetworkTypes
        [<JsonPropertyName("os")>]
        Os: StatsClusterOperatingSystem
        [<JsonPropertyName("packaging_types")>]
        PackagingTypes: StatsNodePackagingType array
        [<JsonPropertyName("plugins")>]
        Plugins: PluginStats array
        [<JsonPropertyName("process")>]
        Process: StatsClusterProcess
        [<JsonPropertyName("versions")>]
        Versions: VersionString array
    }

    and StatsRepositoryStatsShards = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("complete")>]
        Complete: float
        [<JsonPropertyName("incomplete")>]
        Incomplete: float
        [<JsonPropertyName("states")>]
        States: Map<string, float>
    }

    and StatsRepositoryStatsCurrentCounts = {
        [<JsonPropertyName("snapshots")>]
        Snapshots: float
        [<JsonPropertyName("clones")>]
        Clones: float
        [<JsonPropertyName("finalizations")>]
        Finalizations: float
        [<JsonPropertyName("deletions")>]
        Deletions: float
        [<JsonPropertyName("snapshot_deletions")>]
        SnapshotDeletions: float
        [<JsonPropertyName("active_deletions")>]
        ActiveDeletions: float
        [<JsonPropertyName("shards")>]
        Shards: StatsRepositoryStatsShards
    }

    and StatsPerRepositoryStats = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("oldest_start_time_millis")>]
        OldestStartTimeMillis: UnitMillis
        [<JsonPropertyName("oldest_start_time")>]
        OldestStartTime: DateFormat option
        [<JsonPropertyName("current_counts")>]
        CurrentCounts: StatsRepositoryStatsCurrentCounts
    }

    and StatsSnapshotCurrentCounts = {
        [<JsonPropertyName("snapshots")>]
        Snapshots: float
        [<JsonPropertyName("shard_snapshots")>]
        ShardSnapshots: float
        [<JsonPropertyName("snapshot_deletions")>]
        SnapshotDeletions: float
        [<JsonPropertyName("concurrent_operations")>]
        ConcurrentOperations: float
        [<JsonPropertyName("cleanups")>]
        Cleanups: float
    }

    and StatsClusterSnapshotStats = {
        [<JsonPropertyName("current_counts")>]
        CurrentCounts: StatsSnapshotCurrentCounts
        [<JsonPropertyName("repositories")>]
        Repositories: Map<string, StatsPerRepositoryStats>
    }

    /// <summary>
    /// Contains statistics about the number of nodes selected by the request.
    /// </summary>
    and NodeStatistics = {
        [<JsonPropertyName("failures")>]
        Failures: ErrorCause array option
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("successful")>]
        Successful: float
        [<JsonPropertyName("failed")>]
        Failed: float
    }

    and TypesNodesResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
    }

    and StatsStatsResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("cluster_uuid")>]
        ClusterUuid: Uuid
        [<JsonPropertyName("indices")>]
        Indices: StatsClusterIndices
        [<JsonPropertyName("nodes")>]
        Nodes2: StatsClusterNodes
        [<JsonPropertyName("repositories")>]
        Repositories: Map<string, Map<string, float>>
        [<JsonPropertyName("snapshots")>]
        Snapshots: StatsClusterSnapshotStats
        [<JsonPropertyName("status")>]
        Status: HealthStatus option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float
        [<JsonPropertyName("ccs")>]
        Ccs: StatsCCSStats
    }

    and TypesPressureMemory = {
        [<JsonPropertyName("all")>]
        All: ByteSize option
        [<JsonPropertyName("all_in_bytes")>]
        AllInBytes: float option
        [<JsonPropertyName("combined_coordinating_and_primary")>]
        CombinedCoordinatingAndPrimary: ByteSize option
        [<JsonPropertyName("combined_coordinating_and_primary_in_bytes")>]
        CombinedCoordinatingAndPrimaryInBytes: float option
        [<JsonPropertyName("coordinating")>]
        Coordinating: ByteSize option
        [<JsonPropertyName("coordinating_in_bytes")>]
        CoordinatingInBytes: float option
        [<JsonPropertyName("primary")>]
        Primary: ByteSize option
        [<JsonPropertyName("primary_in_bytes")>]
        PrimaryInBytes: float option
        [<JsonPropertyName("replica")>]
        Replica: ByteSize option
        [<JsonPropertyName("replica_in_bytes")>]
        ReplicaInBytes: float option
        [<JsonPropertyName("coordinating_rejections")>]
        CoordinatingRejections: float option
        [<JsonPropertyName("primary_rejections")>]
        PrimaryRejections: float option
        [<JsonPropertyName("replica_rejections")>]
        ReplicaRejections: float option
        [<JsonPropertyName("primary_document_rejections")>]
        PrimaryDocumentRejections: float option
        [<JsonPropertyName("large_operation_rejections")>]
        LargeOperationRejections: float option
    }

    and ResultConverter() =
        inherit JsonConverter<Result>()

        override _.Write(writer: Utf8JsonWriter, value: Result, _options: JsonSerializerOptions) =
            let str =
                match value with
                | Result.Created -> "created"
                | Result.Updated -> "updated"
                | Result.Deleted -> "deleted"
                | Result.NotFound -> "not_found"
                | Result.Noop -> "noop"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "created" -> Result.Created
            | "updated" -> Result.Updated
            | "deleted" -> Result.Deleted
            | "not_found" -> Result.NotFound
            | "noop" -> Result.Noop
            | s -> failwith $"Unknown Result: {s}"

    and [<JsonConverter(typeof<ResultConverter>)>]
        Result =
        | Created
        | Updated
        | Deleted
        | NotFound
        | Noop
        with
        override this.ToString() =
            match this with
            | Created -> "created"
            | Updated -> "updated"
            | Deleted -> "deleted"
            | NotFound -> "not_found"
            | Noop -> "noop"

    /// <summary>
    /// A scalar value.
    /// </summary>
    and ScalarValue = obj

    and TypesConnectorFieldTypeConverter() =
        inherit JsonConverter<TypesConnectorFieldType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConnectorFieldType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConnectorFieldType.Str -> "str"
                | TypesConnectorFieldType.Int -> "int"
                | TypesConnectorFieldType.List -> "list"
                | TypesConnectorFieldType.Bool -> "bool"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "str" -> TypesConnectorFieldType.Str
            | "int" -> TypesConnectorFieldType.Int
            | "list" -> TypesConnectorFieldType.List
            | "bool" -> TypesConnectorFieldType.Bool
            | s -> failwith $"Unknown TypesConnectorFieldType: {s}"

    and [<JsonConverter(typeof<TypesConnectorFieldTypeConverter>)>]
        TypesConnectorFieldType =
        | Str
        | Int
        | List
        | Bool
        with
        override this.ToString() =
            match this with
            | Str -> "str"
            | Int -> "int"
            | List -> "list"
            | Bool -> "bool"

    and TypesDependency = {
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("value")>]
        Value: ScalarValue
    }

    and TypesDisplayTypeConverter() =
        inherit JsonConverter<TypesDisplayType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDisplayType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDisplayType.Textbox -> "textbox"
                | TypesDisplayType.Textarea -> "textarea"
                | TypesDisplayType.Numeric -> "numeric"
                | TypesDisplayType.Toggle -> "toggle"
                | TypesDisplayType.Dropdown -> "dropdown"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "textbox" -> TypesDisplayType.Textbox
            | "textarea" -> TypesDisplayType.Textarea
            | "numeric" -> TypesDisplayType.Numeric
            | "toggle" -> TypesDisplayType.Toggle
            | "dropdown" -> TypesDisplayType.Dropdown
            | s -> failwith $"Unknown TypesDisplayType: {s}"

    and [<JsonConverter(typeof<TypesDisplayTypeConverter>)>]
        TypesDisplayType =
        | Textbox
        | Textarea
        | Numeric
        | Toggle
        | Dropdown
        with
        override this.ToString() =
            match this with
            | Textbox -> "textbox"
            | Textarea -> "textarea"
            | Numeric -> "numeric"
            | Toggle -> "toggle"
            | Dropdown -> "dropdown"

    and TypesSelectOption = {
        [<JsonPropertyName("label")>]
        Label: string
        [<JsonPropertyName("value")>]
        Value: ScalarValue
    }

    and TypesGreaterThanValidation = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("constraint")>]
        Constraint: float
    }

    and TypesIncludedInValidation = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("constraint")>]
        Constraint: ScalarValue array
    }

    and TypesLessThanValidation = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("constraint")>]
        Constraint: float
    }

    and TypesListTypeValidation = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("constraint")>]
        Constraint: string
    }

    and TypesRegexValidation = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("constraint")>]
        Constraint: string
    }

    and TypesValidationConverter() =
        inherit JsonConverter<TypesValidation>()

        override _.Write(writer: Utf8JsonWriter, value: TypesValidation, options: JsonSerializerOptions) =
            match value with
            | TypesValidation.GreaterThan v -> JsonSerializer.Serialize(writer, v, options)
            | TypesValidation.IncludedIn v -> JsonSerializer.Serialize(writer, v, options)
            | TypesValidation.LessThan v -> JsonSerializer.Serialize(writer, v, options)
            | TypesValidation.ListType v -> JsonSerializer.Serialize(writer, v, options)
            | TypesValidation.Regex v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "greater_than" -> TypesValidation.GreaterThan (JsonSerializer.Deserialize<TypesGreaterThanValidation>(json, options))
            | "included_in" -> TypesValidation.IncludedIn (JsonSerializer.Deserialize<TypesIncludedInValidation>(json, options))
            | "less_than" -> TypesValidation.LessThan (JsonSerializer.Deserialize<TypesLessThanValidation>(json, options))
            | "list_type" -> TypesValidation.ListType (JsonSerializer.Deserialize<TypesListTypeValidation>(json, options))
            | "regex" -> TypesValidation.Regex (JsonSerializer.Deserialize<TypesRegexValidation>(json, options))
            | s -> failwith $"Unknown TypesValidation type: {s}"

    and [<JsonConverter(typeof<TypesValidationConverter>)>]
        TypesValidation =
        | GreaterThan of TypesGreaterThanValidation
        | IncludedIn of TypesIncludedInValidation
        | LessThan of TypesLessThanValidation
        | ListType of TypesListTypeValidation
        | Regex of TypesRegexValidation

    and TypesValidationTypeConverter() =
        inherit JsonConverter<TypesValidationType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesValidationType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesValidationType.GreaterThan -> "greater_than"
                | TypesValidationType.IncludedIn -> "included_in"
                | TypesValidationType.LessThan -> "less_than"
                | TypesValidationType.ListType -> "list_type"
                | TypesValidationType.Regex -> "regex"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "greater_than" -> TypesValidationType.GreaterThan
            | "included_in" -> TypesValidationType.IncludedIn
            | "less_than" -> TypesValidationType.LessThan
            | "list_type" -> TypesValidationType.ListType
            | "regex" -> TypesValidationType.Regex
            | s -> failwith $"Unknown TypesValidationType: {s}"

    and [<JsonConverter(typeof<TypesValidationTypeConverter>)>]
        TypesValidationType =
        | GreaterThan
        | IncludedIn
        | LessThan
        | ListType
        | Regex
        with
        override this.ToString() =
            match this with
            | GreaterThan -> "greater_than"
            | IncludedIn -> "included_in"
            | LessThan -> "less_than"
            | ListType -> "list_type"
            | Regex -> "regex"

    and TypesConnectorConfigProperties = {
        [<JsonPropertyName("category")>]
        Category: string option
        [<JsonPropertyName("default_value")>]
        DefaultValue: ScalarValue
        [<JsonPropertyName("depends_on")>]
        DependsOn: TypesDependency array
        [<JsonPropertyName("display")>]
        Display: TypesDisplayType
        [<JsonPropertyName("label")>]
        Label: string
        [<JsonPropertyName("options")>]
        Options: TypesSelectOption array
        [<JsonPropertyName("order")>]
        Order: float option
        [<JsonPropertyName("placeholder")>]
        Placeholder: string option
        [<JsonPropertyName("required")>]
        Required: bool
        [<JsonPropertyName("sensitive")>]
        Sensitive: bool
        [<JsonPropertyName("tooltip")>]
        Tooltip: System.Text.Json.JsonElement option
        [<JsonPropertyName("type")>]
        Type: TypesConnectorFieldType option
        [<JsonPropertyName("ui_restrictions")>]
        UiRestrictions: string array option
        [<JsonPropertyName("validations")>]
        Validations: TypesValidation array option
        [<JsonPropertyName("value")>]
        Value: obj
    }

    and TypesConnectorConfiguration = Map<string, TypesConnectorConfigProperties>

    and TypesCustomSchedulingConfigurationOverrides = {
        [<JsonPropertyName("max_crawl_depth")>]
        MaxCrawlDepth: float option
        [<JsonPropertyName("sitemap_discovery_disabled")>]
        SitemapDiscoveryDisabled: bool option
        [<JsonPropertyName("domain_allowlist")>]
        DomainAllowlist: string array option
        [<JsonPropertyName("sitemap_urls")>]
        SitemapUrls: string array option
        [<JsonPropertyName("seed_urls")>]
        SeedUrls: string array option
    }

    and TypesCustomScheduling = {
        [<JsonPropertyName("configuration_overrides")>]
        ConfigurationOverrides: TypesCustomSchedulingConfigurationOverrides
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("interval")>]
        Interval: string
        [<JsonPropertyName("last_synced")>]
        LastSynced: DateTime option
        [<JsonPropertyName("name")>]
        Name: string
    }

    and TypesConnectorCustomScheduling = Map<string, TypesCustomScheduling>

    and TypesFeatureEnabled = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and TypesSyncRulesFeature = {
        [<JsonPropertyName("advanced")>]
        Advanced: TypesFeatureEnabled option
        [<JsonPropertyName("basic")>]
        Basic: TypesFeatureEnabled option
    }

    and TypesConnectorFeatures = {
        [<JsonPropertyName("document_level_security")>]
        DocumentLevelSecurity: TypesFeatureEnabled option
        [<JsonPropertyName("incremental_sync")>]
        IncrementalSync: TypesFeatureEnabled option
        [<JsonPropertyName("native_connector_api_keys")>]
        NativeConnectorApiKeys: TypesFeatureEnabled option
        [<JsonPropertyName("sync_rules")>]
        SyncRules: TypesSyncRulesFeature option
    }

    and TypesConnectorStatusConverter() =
        inherit JsonConverter<TypesConnectorStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConnectorStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConnectorStatus.Created -> "created"
                | TypesConnectorStatus.NeedsConfiguration -> "needs_configuration"
                | TypesConnectorStatus.Configured -> "configured"
                | TypesConnectorStatus.Connected -> "connected"
                | TypesConnectorStatus.Error -> "error"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "created" -> TypesConnectorStatus.Created
            | "needs_configuration" -> TypesConnectorStatus.NeedsConfiguration
            | "configured" -> TypesConnectorStatus.Configured
            | "connected" -> TypesConnectorStatus.Connected
            | "error" -> TypesConnectorStatus.Error
            | s -> failwith $"Unknown TypesConnectorStatus: {s}"

    and [<JsonConverter(typeof<TypesConnectorStatusConverter>)>]
        TypesConnectorStatus =
        | Created
        | NeedsConfiguration
        | Configured
        | Connected
        | Error
        with
        override this.ToString() =
            match this with
            | Created -> "created"
            | NeedsConfiguration -> "needs_configuration"
            | Configured -> "configured"
            | Connected -> "connected"
            | Error -> "error"

    and TypesFilteringAdvancedSnippet = {
        [<JsonPropertyName("created_at")>]
        CreatedAt: DateTime option
        [<JsonPropertyName("updated_at")>]
        UpdatedAt: DateTime option
        [<JsonPropertyName("value")>]
        Value: obj
    }

    and TypesFilteringPolicyConverter() =
        inherit JsonConverter<TypesFilteringPolicy>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFilteringPolicy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFilteringPolicy.Exclude -> "exclude"
                | TypesFilteringPolicy.Include -> "include"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "exclude" -> TypesFilteringPolicy.Exclude
            | "include" -> TypesFilteringPolicy.Include
            | s -> failwith $"Unknown TypesFilteringPolicy: {s}"

    and [<JsonConverter(typeof<TypesFilteringPolicyConverter>)>]
        TypesFilteringPolicy =
        | Exclude
        | Include
        with
        override this.ToString() =
            match this with
            | Exclude -> "exclude"
            | Include -> "include"

    and TypesFilteringRuleRuleConverter() =
        inherit JsonConverter<TypesFilteringRuleRule>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFilteringRuleRule, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFilteringRuleRule.Contains -> "contains"
                | TypesFilteringRuleRule.EndsWith -> "ends_with"
                | TypesFilteringRuleRule.Equals -> "equals"
                | TypesFilteringRuleRule.Regex -> "regex"
                | TypesFilteringRuleRule.StartsWith -> "starts_with"
                | TypesFilteringRuleRule.Gt -> ">"
                | TypesFilteringRuleRule.Lt -> "<"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "contains" -> TypesFilteringRuleRule.Contains
            | "ends_with" -> TypesFilteringRuleRule.EndsWith
            | "equals" -> TypesFilteringRuleRule.Equals
            | "regex" -> TypesFilteringRuleRule.Regex
            | "starts_with" -> TypesFilteringRuleRule.StartsWith
            | ">" -> TypesFilteringRuleRule.Gt
            | "<" -> TypesFilteringRuleRule.Lt
            | s -> failwith $"Unknown TypesFilteringRuleRule: {s}"

    and [<JsonConverter(typeof<TypesFilteringRuleRuleConverter>)>]
        TypesFilteringRuleRule =
        | Contains
        | EndsWith
        | Equals
        | Regex
        | StartsWith
        | Gt
        | Lt
        with
        override this.ToString() =
            match this with
            | Contains -> "contains"
            | EndsWith -> "ends_with"
            | Equals -> "equals"
            | Regex -> "regex"
            | StartsWith -> "starts_with"
            | Gt -> ">"
            | Lt -> "<"

    and TypesFilteringRule = {
        [<JsonPropertyName("created_at")>]
        CreatedAt: DateTime option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("order")>]
        Order: float
        [<JsonPropertyName("policy")>]
        Policy: TypesFilteringPolicy
        [<JsonPropertyName("rule")>]
        Rule: TypesFilteringRuleRule
        [<JsonPropertyName("updated_at")>]
        UpdatedAt: DateTime option
        [<JsonPropertyName("value")>]
        Value: string
    }

    and TypesFilteringValidation = {
        [<JsonPropertyName("ids")>]
        Ids: Id array
        [<JsonPropertyName("messages")>]
        Messages: string array
    }

    and TypesFilteringValidationStateConverter() =
        inherit JsonConverter<TypesFilteringValidationState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFilteringValidationState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFilteringValidationState.Edited -> "edited"
                | TypesFilteringValidationState.Invalid -> "invalid"
                | TypesFilteringValidationState.Valid -> "valid"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "edited" -> TypesFilteringValidationState.Edited
            | "invalid" -> TypesFilteringValidationState.Invalid
            | "valid" -> TypesFilteringValidationState.Valid
            | s -> failwith $"Unknown TypesFilteringValidationState: {s}"

    and [<JsonConverter(typeof<TypesFilteringValidationStateConverter>)>]
        TypesFilteringValidationState =
        | Edited
        | Invalid
        | Valid
        with
        override this.ToString() =
            match this with
            | Edited -> "edited"
            | Invalid -> "invalid"
            | Valid -> "valid"

    and TypesFilteringRulesValidation = {
        [<JsonPropertyName("errors")>]
        Errors: TypesFilteringValidation array
        [<JsonPropertyName("state")>]
        State: TypesFilteringValidationState
    }

    and TypesFilteringRules = {
        [<JsonPropertyName("advanced_snippet")>]
        AdvancedSnippet: TypesFilteringAdvancedSnippet
        [<JsonPropertyName("rules")>]
        Rules: TypesFilteringRule array
        [<JsonPropertyName("validation")>]
        Validation: TypesFilteringRulesValidation
    }

    and TypesFilteringConfig = {
        [<JsonPropertyName("active")>]
        Active: TypesFilteringRules
        [<JsonPropertyName("domain")>]
        Domain: string option
        [<JsonPropertyName("draft")>]
        Draft: TypesFilteringRules
    }

    and TypesIngestPipelineParams = {
        [<JsonPropertyName("extract_binary_content")>]
        ExtractBinaryContent: bool
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("reduce_whitespace")>]
        ReduceWhitespace: bool
        [<JsonPropertyName("run_ml_inference")>]
        RunMlInference: bool
    }

    and TypesConnectorScheduling = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("interval")>]
        Interval: string
    }

    and TypesSchedulingConfiguration = {
        [<JsonPropertyName("access_control")>]
        AccessControl: TypesConnectorScheduling option
        [<JsonPropertyName("full")>]
        Full: TypesConnectorScheduling option
        [<JsonPropertyName("incremental")>]
        Incremental: TypesConnectorScheduling option
    }

    and TypesSyncStatusConverter() =
        inherit JsonConverter<TypesSyncStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSyncStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSyncStatus.Canceling -> "canceling"
                | TypesSyncStatus.Canceled -> "canceled"
                | TypesSyncStatus.Completed -> "completed"
                | TypesSyncStatus.Error -> "error"
                | TypesSyncStatus.InProgress -> "in_progress"
                | TypesSyncStatus.Pending -> "pending"
                | TypesSyncStatus.Suspended -> "suspended"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "canceling" -> TypesSyncStatus.Canceling
            | "canceled" -> TypesSyncStatus.Canceled
            | "completed" -> TypesSyncStatus.Completed
            | "error" -> TypesSyncStatus.Error
            | "in_progress" -> TypesSyncStatus.InProgress
            | "pending" -> TypesSyncStatus.Pending
            | "suspended" -> TypesSyncStatus.Suspended
            | s -> failwith $"Unknown TypesSyncStatus: {s}"

    and [<JsonConverter(typeof<TypesSyncStatusConverter>)>]
        TypesSyncStatus =
        | Canceling
        | Canceled
        | Completed
        | Error
        | InProgress
        | Pending
        | Suspended
        with
        override this.ToString() =
            match this with
            | Canceling -> "canceling"
            | Canceled -> "canceled"
            | Completed -> "completed"
            | Error -> "error"
            | InProgress -> "in_progress"
            | Pending -> "pending"
            | Suspended -> "suspended"

    and TypesConnector = {
        [<JsonPropertyName("api_key_id")>]
        ApiKeyId: string option
        [<JsonPropertyName("api_key_secret_id")>]
        ApiKeySecretId: string option
        [<JsonPropertyName("configuration")>]
        Configuration: TypesConnectorConfiguration
        [<JsonPropertyName("custom_scheduling")>]
        CustomScheduling: TypesConnectorCustomScheduling
        [<JsonPropertyName("deleted")>]
        Deleted: bool
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("error")>]
        Error: System.Text.Json.JsonElement option
        [<JsonPropertyName("features")>]
        Features: TypesConnectorFeatures option
        [<JsonPropertyName("filtering")>]
        Filtering: TypesFilteringConfig array
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("index_name")>]
        IndexName: System.Text.Json.JsonElement option
        [<JsonPropertyName("is_native")>]
        IsNative: bool
        [<JsonPropertyName("language")>]
        Language: string option
        [<JsonPropertyName("last_access_control_sync_error")>]
        LastAccessControlSyncError: string option
        [<JsonPropertyName("last_access_control_sync_scheduled_at")>]
        LastAccessControlSyncScheduledAt: DateTime option
        [<JsonPropertyName("last_access_control_sync_status")>]
        LastAccessControlSyncStatus: TypesSyncStatus option
        [<JsonPropertyName("last_deleted_document_count")>]
        LastDeletedDocumentCount: float option
        [<JsonPropertyName("last_incremental_sync_scheduled_at")>]
        LastIncrementalSyncScheduledAt: DateTime option
        [<JsonPropertyName("last_indexed_document_count")>]
        LastIndexedDocumentCount: float option
        [<JsonPropertyName("last_seen")>]
        LastSeen: DateTime option
        [<JsonPropertyName("last_sync_error")>]
        LastSyncError: string option
        [<JsonPropertyName("last_sync_scheduled_at")>]
        LastSyncScheduledAt: DateTime option
        [<JsonPropertyName("last_sync_status")>]
        LastSyncStatus: TypesSyncStatus option
        [<JsonPropertyName("last_synced")>]
        LastSynced: DateTime option
        [<JsonPropertyName("name")>]
        Name: string option
        [<JsonPropertyName("pipeline")>]
        Pipeline: TypesIngestPipelineParams option
        [<JsonPropertyName("scheduling")>]
        Scheduling: TypesSchedulingConfiguration
        [<JsonPropertyName("service_type")>]
        ServiceType: string option
        [<JsonPropertyName("status")>]
        Status: TypesConnectorStatus
        [<JsonPropertyName("sync_cursor")>]
        SyncCursor: obj option
        [<JsonPropertyName("sync_now")>]
        SyncNow: bool
    }

    and TypesSyncJobConnectorReference = {
        [<JsonPropertyName("configuration")>]
        Configuration: TypesConnectorConfiguration
        [<JsonPropertyName("filtering")>]
        Filtering: TypesFilteringRules
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("index_name")>]
        IndexName: string
        [<JsonPropertyName("language")>]
        Language: string option
        [<JsonPropertyName("pipeline")>]
        Pipeline: TypesIngestPipelineParams option
        [<JsonPropertyName("service_type")>]
        ServiceType: string
        [<JsonPropertyName("sync_cursor")>]
        SyncCursor: obj option
    }

    and TypesSyncJobTriggerMethodConverter() =
        inherit JsonConverter<TypesSyncJobTriggerMethod>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSyncJobTriggerMethod, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSyncJobTriggerMethod.OnDemand -> "on_demand"
                | TypesSyncJobTriggerMethod.Scheduled -> "scheduled"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "on_demand" -> TypesSyncJobTriggerMethod.OnDemand
            | "scheduled" -> TypesSyncJobTriggerMethod.Scheduled
            | s -> failwith $"Unknown TypesSyncJobTriggerMethod: {s}"

    and [<JsonConverter(typeof<TypesSyncJobTriggerMethodConverter>)>]
        TypesSyncJobTriggerMethod =
        | OnDemand
        | Scheduled
        with
        override this.ToString() =
            match this with
            | OnDemand -> "on_demand"
            | Scheduled -> "scheduled"

    and TypesSyncJobTypeConverter() =
        inherit JsonConverter<TypesSyncJobType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSyncJobType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSyncJobType.Full -> "full"
                | TypesSyncJobType.Incremental -> "incremental"
                | TypesSyncJobType.AccessControl -> "access_control"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "full" -> TypesSyncJobType.Full
            | "incremental" -> TypesSyncJobType.Incremental
            | "access_control" -> TypesSyncJobType.AccessControl
            | s -> failwith $"Unknown TypesSyncJobType: {s}"

    and [<JsonConverter(typeof<TypesSyncJobTypeConverter>)>]
        TypesSyncJobType =
        | Full
        | Incremental
        | AccessControl
        with
        override this.ToString() =
            match this with
            | Full -> "full"
            | Incremental -> "incremental"
            | AccessControl -> "access_control"

    and TypesConnectorSyncJob = {
        [<JsonPropertyName("cancelation_requested_at")>]
        CancelationRequestedAt: DateTime option
        [<JsonPropertyName("canceled_at")>]
        CanceledAt: DateTime option
        [<JsonPropertyName("completed_at")>]
        CompletedAt: DateTime option
        [<JsonPropertyName("connector")>]
        Connector: TypesSyncJobConnectorReference
        [<JsonPropertyName("created_at")>]
        CreatedAt: DateTime
        [<JsonPropertyName("deleted_document_count")>]
        DeletedDocumentCount: float
        [<JsonPropertyName("error")>]
        Error: string option
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("indexed_document_count")>]
        IndexedDocumentCount: float
        [<JsonPropertyName("indexed_document_volume")>]
        IndexedDocumentVolume: float
        [<JsonPropertyName("job_type")>]
        JobType: TypesSyncJobType
        [<JsonPropertyName("last_seen")>]
        LastSeen: DateTime option
        [<JsonPropertyName("metadata")>]
        Metadata: Map<string, obj>
        [<JsonPropertyName("started_at")>]
        StartedAt: DateTime option
        [<JsonPropertyName("status")>]
        Status: TypesSyncStatus
        [<JsonPropertyName("total_document_count")>]
        TotalDocumentCount: float
        [<JsonPropertyName("trigger_method")>]
        TriggerMethod: TypesSyncJobTriggerMethod
        [<JsonPropertyName("worker_hostname")>]
        WorkerHostname: string option
    }

    and WriteResponseBase = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("result")>]
        Result: Result
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("_version")>]
        Version: VersionNumber
        [<JsonPropertyName("failure_store")>]
        FailureStore: BulkFailureStoreStatus option
        [<JsonPropertyName("forced_refresh")>]
        ForcedRefresh: bool option
    }

    and ListDanglingIndicesDanglingIndex = {
        [<JsonPropertyName("index_name")>]
        IndexName: string
        [<JsonPropertyName("index_uuid")>]
        IndexUuid: string
        [<JsonPropertyName("creation_date_millis")>]
        CreationDateMillis: EpochTimeUnitMillis
        [<JsonPropertyName("node_ids")>]
        NodeIds: Ids
    }

    and ConflictsConverter() =
        inherit JsonConverter<Conflicts>()

        override _.Write(writer: Utf8JsonWriter, value: Conflicts, _options: JsonSerializerOptions) =
            let str =
                match value with
                | Conflicts.Abort -> "abort"
                | Conflicts.Proceed -> "proceed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "abort" -> Conflicts.Abort
            | "proceed" -> Conflicts.Proceed
            | s -> failwith $"Unknown Conflicts: {s}"

    and [<JsonConverter(typeof<ConflictsConverter>)>]
        Conflicts =
        | Abort
        | Proceed
        with
        override this.ToString() =
            match this with
            | Abort -> "abort"
            | Proceed -> "proceed"

    and SlicesCalculationConverter() =
        inherit JsonConverter<SlicesCalculation>()

        override _.Write(writer: Utf8JsonWriter, value: SlicesCalculation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SlicesCalculation.Auto -> "auto"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "auto" -> SlicesCalculation.Auto
            | s -> failwith $"Unknown SlicesCalculation: {s}"

    and [<JsonConverter(typeof<SlicesCalculationConverter>)>]
        SlicesCalculation =
        | Auto
        with
        override this.ToString() =
            match this with
            | Auto -> "auto"

    /// <summary>
    /// Slices configuration used to parallelize a process.
    /// </summary>
    and Slices = obj

    and BulkIndexByScrollFailure = {
        [<JsonPropertyName("cause")>]
        Cause: ErrorCause
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("status")>]
        Status: float
    }

    and Retries = {
        [<JsonPropertyName("bulk")>]
        Bulk: float
        [<JsonPropertyName("search")>]
        Search: float
    }

    and TaskId = string

    and TaskFailure = {
        [<JsonPropertyName("task_id")>]
        TaskId: float
        [<JsonPropertyName("node_id")>]
        NodeId: NodeId
        [<JsonPropertyName("status")>]
        Status: string
        [<JsonPropertyName("reason")>]
        Reason: ErrorCause
    }

    and TypesTaskInfo = {
        [<JsonPropertyName("action")>]
        Action: string
        [<JsonPropertyName("cancelled")>]
        Cancelled: bool option
        [<JsonPropertyName("cancellable")>]
        Cancellable: bool
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string>
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("node")>]
        Node: NodeId
        [<JsonPropertyName("running_time")>]
        RunningTime: Duration option
        [<JsonPropertyName("running_time_in_nanos")>]
        RunningTimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("status")>]
        Status: obj option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("parent_task_id")>]
        ParentTaskId: TaskId option
    }

    and TypesNodeTasks = {
        [<JsonPropertyName("name")>]
        Name: NodeId option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("ip")>]
        Ip: Ip option
        [<JsonPropertyName("roles")>]
        Roles: string array option
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string> option
        [<JsonPropertyName("tasks")>]
        Tasks: Map<string, TypesTaskInfo>
    }

    and TypesParentTaskInfo = {
        [<JsonPropertyName("action")>]
        Action: string
        [<JsonPropertyName("cancelled")>]
        Cancelled: bool option
        [<JsonPropertyName("cancellable")>]
        Cancellable: bool
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string>
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("node")>]
        Node: NodeId
        [<JsonPropertyName("running_time")>]
        RunningTime: Duration option
        [<JsonPropertyName("running_time_in_nanos")>]
        RunningTimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("status")>]
        Status: obj option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("parent_task_id")>]
        ParentTaskId: TaskId option
        [<JsonPropertyName("children")>]
        Children: TypesTaskInfo array option
    }

    and TypesTaskInfos = obj

    and TypesTaskListResponseBase = {
        [<JsonPropertyName("node_failures")>]
        NodeFailures: ErrorCause array option
        [<JsonPropertyName("task_failures")>]
        TaskFailures: TaskFailure array option
        [<JsonPropertyName("nodes")>]
        Nodes: Map<string, TypesNodeTasks> option
        [<JsonPropertyName("tasks")>]
        Tasks: TypesTaskInfos option
    }

    and ExecutePolicyEnrichPolicyPhaseConverter() =
        inherit JsonConverter<ExecutePolicyEnrichPolicyPhase>()

        override _.Write(writer: Utf8JsonWriter, value: ExecutePolicyEnrichPolicyPhase, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ExecutePolicyEnrichPolicyPhase.SCHEDULED -> "SCHEDULED"
                | ExecutePolicyEnrichPolicyPhase.RUNNING -> "RUNNING"
                | ExecutePolicyEnrichPolicyPhase.COMPLETE -> "COMPLETE"
                | ExecutePolicyEnrichPolicyPhase.FAILED -> "FAILED"
                | ExecutePolicyEnrichPolicyPhase.CANCELLED -> "CANCELLED"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "SCHEDULED" -> ExecutePolicyEnrichPolicyPhase.SCHEDULED
            | "RUNNING" -> ExecutePolicyEnrichPolicyPhase.RUNNING
            | "COMPLETE" -> ExecutePolicyEnrichPolicyPhase.COMPLETE
            | "FAILED" -> ExecutePolicyEnrichPolicyPhase.FAILED
            | "CANCELLED" -> ExecutePolicyEnrichPolicyPhase.CANCELLED
            | s -> failwith $"Unknown ExecutePolicyEnrichPolicyPhase: {s}"

    and [<JsonConverter(typeof<ExecutePolicyEnrichPolicyPhaseConverter>)>]
        ExecutePolicyEnrichPolicyPhase =
        | SCHEDULED
        | RUNNING
        | COMPLETE
        | FAILED
        | CANCELLED
        with
        override this.ToString() =
            match this with
            | SCHEDULED -> "SCHEDULED"
            | RUNNING -> "RUNNING"
            | COMPLETE -> "COMPLETE"
            | FAILED -> "FAILED"
            | CANCELLED -> "CANCELLED"

    and ExecutePolicyExecuteEnrichPolicyStatus = {
        [<JsonPropertyName("phase")>]
        Phase: ExecutePolicyEnrichPolicyPhase
        [<JsonPropertyName("step")>]
        Step: string option
    }

    and TypesPolicy = {
        [<JsonPropertyName("enrich_fields")>]
        EnrichFields: Fields
        [<JsonPropertyName("indices")>]
        Indices: Indices
        [<JsonPropertyName("match_field")>]
        MatchField: Field
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("elasticsearch_version")>]
        ElasticsearchVersion: string option
    }

    and TypesSummary = {
        [<JsonPropertyName("config")>]
        Config: Map<string, TypesPolicy>
    }

    and StatsCoordinatorStats = {
        [<JsonPropertyName("executed_searches_total")>]
        ExecutedSearchesTotal: float
        [<JsonPropertyName("node_id")>]
        NodeId: Id
        [<JsonPropertyName("queue_size")>]
        QueueSize: float
        [<JsonPropertyName("remote_requests_current")>]
        RemoteRequestsCurrent: float
        [<JsonPropertyName("remote_requests_total")>]
        RemoteRequestsTotal: float
    }

    and StatsExecutingPolicy = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("task")>]
        Task: TypesTaskInfo
    }

    and StatsCacheStats = {
        [<JsonPropertyName("node_id")>]
        NodeId: Id
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("hits")>]
        Hits: float
        [<JsonPropertyName("hits_time_in_millis")>]
        HitsTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("misses")>]
        Misses: float
        [<JsonPropertyName("misses_time_in_millis")>]
        MissesTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
    }

    and TypesHitsEvent = {
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_source")>]
        Source: obj
        [<JsonPropertyName("missing")>]
        Missing: bool option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj array> option
    }

    and TypesHitsSequence = {
        [<JsonPropertyName("events")>]
        Events: TypesHitsEvent array
        [<JsonPropertyName("join_keys")>]
        JoinKeys: obj array option
    }

    and TypesEqlHits = {
        [<JsonPropertyName("total")>]
        Total: SearchTypesTotalHits option
        [<JsonPropertyName("events")>]
        Events: TypesHitsEvent array option
        [<JsonPropertyName("sequences")>]
        Sequences: TypesHitsSequence array option
    }

    and TypesEqlSearchResponseBase = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool option
        [<JsonPropertyName("is_running")>]
        IsRunning: bool option
        [<JsonPropertyName("took")>]
        Took: DurationValueUnitMillis option
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool option
        [<JsonPropertyName("hits")>]
        Hits: TypesEqlHits
        [<JsonPropertyName("shard_failures")>]
        ShardFailures: ShardFailure array option
    }

    and SearchResultPositionConverter() =
        inherit JsonConverter<SearchResultPosition>()

        override _.Write(writer: Utf8JsonWriter, value: SearchResultPosition, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchResultPosition.Tail -> "tail"
                | SearchResultPosition.Head -> "head"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "tail" -> SearchResultPosition.Tail
            | "head" -> SearchResultPosition.Head
            | s -> failwith $"Unknown SearchResultPosition: {s}"

    and [<JsonConverter(typeof<SearchResultPositionConverter>)>]
        SearchResultPosition =
        | Tail
        | Head
        with
        override this.ToString() =
            match this with
            | Tail -> "tail"
            | Head -> "head"

    and TypesEsqlFormatConverter() =
        inherit JsonConverter<TypesEsqlFormat>()

        override _.Write(writer: Utf8JsonWriter, value: TypesEsqlFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesEsqlFormat.Csv -> "csv"
                | TypesEsqlFormat.Json -> "json"
                | TypesEsqlFormat.Tsv -> "tsv"
                | TypesEsqlFormat.Txt -> "txt"
                | TypesEsqlFormat.Yaml -> "yaml"
                | TypesEsqlFormat.Cbor -> "cbor"
                | TypesEsqlFormat.Smile -> "smile"
                | TypesEsqlFormat.Arrow -> "arrow"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "csv" -> TypesEsqlFormat.Csv
            | "json" -> TypesEsqlFormat.Json
            | "tsv" -> TypesEsqlFormat.Tsv
            | "txt" -> TypesEsqlFormat.Txt
            | "yaml" -> TypesEsqlFormat.Yaml
            | "cbor" -> TypesEsqlFormat.Cbor
            | "smile" -> TypesEsqlFormat.Smile
            | "arrow" -> TypesEsqlFormat.Arrow
            | s -> failwith $"Unknown TypesEsqlFormat: {s}"

    and [<JsonConverter(typeof<TypesEsqlFormatConverter>)>]
        TypesEsqlFormat =
        | Csv
        | Json
        | Tsv
        | Txt
        | Yaml
        | Cbor
        | Smile
        | Arrow
        with
        override this.ToString() =
            match this with
            | Csv -> "csv"
            | Json -> "json"
            | Tsv -> "tsv"
            | Txt -> "txt"
            | Yaml -> "yaml"
            | Cbor -> "cbor"
            | Smile -> "smile"
            | Arrow -> "arrow"

    and TypesTableValuesIntegerValue = obj

    and TypesTableValuesKeywordValue = obj

    and TypesTableValuesLongDouble = obj

    and TypesTableValuesLongValue = obj

    and TypesTableValuesContainer = {
        [<JsonPropertyName("integer")>]
        Integer: TypesTableValuesIntegerValue array option
        [<JsonPropertyName("keyword")>]
        Keyword: TypesTableValuesKeywordValue array option
        [<JsonPropertyName("long")>]
        Long: TypesTableValuesLongValue array option
        [<JsonPropertyName("double")>]
        Double: TypesTableValuesLongDouble array option
    }

    and TypesEsqlClusterStatusConverter() =
        inherit JsonConverter<TypesEsqlClusterStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesEsqlClusterStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesEsqlClusterStatus.Running -> "running"
                | TypesEsqlClusterStatus.Successful -> "successful"
                | TypesEsqlClusterStatus.Partial -> "partial"
                | TypesEsqlClusterStatus.Skipped -> "skipped"
                | TypesEsqlClusterStatus.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "running" -> TypesEsqlClusterStatus.Running
            | "successful" -> TypesEsqlClusterStatus.Successful
            | "partial" -> TypesEsqlClusterStatus.Partial
            | "skipped" -> TypesEsqlClusterStatus.Skipped
            | "failed" -> TypesEsqlClusterStatus.Failed
            | s -> failwith $"Unknown TypesEsqlClusterStatus: {s}"

    and [<JsonConverter(typeof<TypesEsqlClusterStatusConverter>)>]
        TypesEsqlClusterStatus =
        | Running
        | Successful
        | Partial
        | Skipped
        | Failed
        with
        override this.ToString() =
            match this with
            | Running -> "running"
            | Successful -> "successful"
            | Partial -> "partial"
            | Skipped -> "skipped"
            | Failed -> "failed"

    and TypesEsqlShardFailure = {
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("index")>]
        Index: System.Text.Json.JsonElement
        [<JsonPropertyName("node")>]
        Node: NodeId option
        [<JsonPropertyName("reason")>]
        Reason: ErrorCause
    }

    and TypesEsqlShardInfo = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("successful")>]
        Successful: float option
        [<JsonPropertyName("skipped")>]
        Skipped: float option
        [<JsonPropertyName("failed")>]
        Failed: float option
    }

    and TypesEsqlClusterDetails = {
        [<JsonPropertyName("status")>]
        Status: TypesEsqlClusterStatus
        [<JsonPropertyName("indices")>]
        Indices: string
        [<JsonPropertyName("took")>]
        Took: DurationValueUnitMillis option
        [<JsonPropertyName("_shards")>]
        Shards: TypesEsqlShardInfo option
        [<JsonPropertyName("failures")>]
        Failures: TypesEsqlShardFailure array option
    }

    and TypesEsqlClusterInfo = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("successful")>]
        Successful: float
        [<JsonPropertyName("running")>]
        Running: float
        [<JsonPropertyName("skipped")>]
        Skipped: float
        [<JsonPropertyName("partial")>]
        Partial: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("details")>]
        Details: Map<string, TypesEsqlClusterDetails>
    }

    and TypesEsqlColumnInfo = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and TypesEsqlResult = {
        [<JsonPropertyName("took")>]
        Took: DurationValueUnitMillis option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool option
        [<JsonPropertyName("all_columns")>]
        AllColumns: TypesEsqlColumnInfo array option
        [<JsonPropertyName("columns")>]
        Columns: TypesEsqlColumnInfo array
        [<JsonPropertyName("values")>]
        Values: FieldValue array array
        [<JsonPropertyName("_clusters")>]
        Clusters: TypesEsqlClusterInfo option
        [<JsonPropertyName("profile")>]
        Profile: obj option
    }

    and TypesAsyncEsqlResult = {
        [<JsonPropertyName("took")>]
        Took: DurationValueUnitMillis option
        [<JsonPropertyName("is_partial")>]
        IsPartial: bool option
        [<JsonPropertyName("all_columns")>]
        AllColumns: TypesEsqlColumnInfo array option
        [<JsonPropertyName("columns")>]
        Columns: TypesEsqlColumnInfo array
        [<JsonPropertyName("values")>]
        Values: FieldValue array array
        [<JsonPropertyName("_clusters")>]
        Clusters: TypesEsqlClusterInfo option
        [<JsonPropertyName("profile")>]
        Profile: obj option
        [<JsonPropertyName("id")>]
        Id: string option
        [<JsonPropertyName("is_running")>]
        IsRunning: bool
    }

    and ListQueriesBody = {
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("node")>]
        Node: NodeId
        [<JsonPropertyName("start_time_millis")>]
        StartTimeMillis: float
        [<JsonPropertyName("running_time_nanos")>]
        RunningTimeNanos: float
        [<JsonPropertyName("query")>]
        Query: string
    }

    and TypesESQLParam = obj

    and InlineGet = {
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("found")>]
        Found: bool
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("_routing")>]
        Routing: Routing option
        [<JsonPropertyName("_source")>]
        Source: obj option
    }

    and TypesFeature = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("description")>]
        Description: string
    }

    and FieldCapsFieldCapability = {
        [<JsonPropertyName("aggregatable")>]
        Aggregatable: bool
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("non_aggregatable_indices")>]
        NonAggregatableIndices: Indices option
        [<JsonPropertyName("non_searchable_indices")>]
        NonSearchableIndices: Indices option
        [<JsonPropertyName("searchable")>]
        Searchable: bool
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("metadata_field")>]
        MetadataField: bool option
        [<JsonPropertyName("time_series_dimension")>]
        TimeSeriesDimension: bool option
        [<JsonPropertyName("time_series_metric")>]
        TimeSeriesMetric: MappingTimeSeriesMetricType option
        [<JsonPropertyName("non_dimension_indices")>]
        NonDimensionIndices: IndexName array option
        [<JsonPropertyName("metric_conflicts_indices")>]
        MetricConflictsIndices: IndexName array option
    }

    and IndexAlias = string

    and TypesCheckpoint = float

    and ProjectRouting = string

    /// <summary>
    /// Contains parameters used to limit or change the subsequent search body request.
    /// </summary>
    and MsearchMultisearchHeader = {
        [<JsonPropertyName("allow_no_indices")>]
        AllowNoIndices: bool option
        [<JsonPropertyName("expand_wildcards")>]
        ExpandWildcards: ExpandWildcards option
        [<JsonPropertyName("ignore_unavailable")>]
        IgnoreUnavailable: bool option
        [<JsonPropertyName("index")>]
        Index: Indices option
        [<JsonPropertyName("preference")>]
        Preference: string option
        [<JsonPropertyName("project_routing")>]
        ProjectRouting: ProjectRouting option
        [<JsonPropertyName("request_cache")>]
        RequestCache: bool option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("search_type")>]
        SearchType: SearchType option
        [<JsonPropertyName("ccs_minimize_roundtrips")>]
        CcsMinimizeRoundtrips: bool option
        [<JsonPropertyName("allow_partial_search_results")>]
        AllowPartialSearchResults: bool option
        [<JsonPropertyName("ignore_throttled")>]
        IgnoreThrottled: bool option
    }

    and MsearchRequestItem = obj

    and SearchResponseBody = {
        [<JsonPropertyName("took")>]
        Took: float
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHitsMetadata
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregate> option
        [<JsonPropertyName("_clusters")>]
        Clusters: ClusterStatistics option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("max_score")>]
        MaxScore: float option
        [<JsonPropertyName("num_reduce_phases")>]
        NumReducePhases: float option
        [<JsonPropertyName("profile")>]
        Profile: SearchTypesProfile option
        [<JsonPropertyName("pit_id")>]
        PitId: Id option
        [<JsonPropertyName("_scroll_id")>]
        ScrollId: ScrollId option
        [<JsonPropertyName("suggest")>]
        Suggest: Map<string, SearchTypesSuggest array> option
        [<JsonPropertyName("terminated_early")>]
        TerminatedEarly: bool option
    }

    and MsearchMultiSearchItem = {
        [<JsonPropertyName("took")>]
        Took: float
        [<JsonPropertyName("timed_out")>]
        TimedOut: bool
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("hits")>]
        Hits: SearchTypesHitsMetadata
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregate> option
        [<JsonPropertyName("_clusters")>]
        Clusters: ClusterStatistics option
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("max_score")>]
        MaxScore: float option
        [<JsonPropertyName("num_reduce_phases")>]
        NumReducePhases: float option
        [<JsonPropertyName("profile")>]
        Profile: SearchTypesProfile option
        [<JsonPropertyName("pit_id")>]
        PitId: Id option
        [<JsonPropertyName("_scroll_id")>]
        ScrollId: ScrollId option
        [<JsonPropertyName("suggest")>]
        Suggest: Map<string, SearchTypesSuggest array> option
        [<JsonPropertyName("terminated_early")>]
        TerminatedEarly: bool option
        [<JsonPropertyName("status")>]
        Status: float option
    }

    /// <summary>
    /// The response returned by Elasticsearch when request execution did not succeed.
    /// </summary>
    and ErrorResponseBase = {
        [<JsonPropertyName("error")>]
        Error: ErrorCause
        [<JsonPropertyName("status")>]
        Status: float
    }

    and MsearchResponseItem = obj

    and GetGetResult = {
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("fields")>]
        Fields: Map<string, obj> option
        [<JsonPropertyName("_ignored")>]
        Ignored: string array option
        [<JsonPropertyName("found")>]
        Found: bool
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("_routing")>]
        Routing: string option
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_source")>]
        Source: obj option
        [<JsonPropertyName("_version")>]
        Version: VersionNumber option
    }

    and StoredScript = {
        [<JsonPropertyName("lang")>]
        Lang: ScriptLanguage
        [<JsonPropertyName("options")>]
        Options: Map<string, string> option
        [<JsonPropertyName("source")>]
        Source: ScriptSource
    }

    and GetScriptContextContextMethodParam = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: string
    }

    and GetScriptContextContextMethod = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("return_type")>]
        ReturnType: string
        [<JsonPropertyName("params")>]
        Params: GetScriptContextContextMethodParam array
    }

    and GetScriptContextContext = {
        [<JsonPropertyName("methods")>]
        Methods: GetScriptContextContextMethod array
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and GetScriptLanguagesLanguageContext = {
        [<JsonPropertyName("contexts")>]
        Contexts: string array
        [<JsonPropertyName("language")>]
        Language: ScriptLanguage
    }

    and TypesVertexInclude = {
        [<JsonPropertyName("boost")>]
        Boost: float option
        [<JsonPropertyName("term")>]
        Term: string
    }

    and TypesVertexDefinition = {
        [<JsonPropertyName("exclude")>]
        Exclude: string array option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("include")>]
        Include: TypesVertexInclude array option
        [<JsonPropertyName("min_doc_count")>]
        MinDocCount: float option
        [<JsonPropertyName("shard_min_doc_count")>]
        ShardMinDocCount: float option
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and TypesHop = {
        [<JsonPropertyName("connections")>]
        Connections: TypesHop option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("vertices")>]
        Vertices: TypesVertexDefinition array
    }

    and TypesSampleDiversity = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("max_docs_per_value")>]
        MaxDocsPerValue: float
    }

    and TypesExploreControls = {
        [<JsonPropertyName("sample_diversity")>]
        SampleDiversity: TypesSampleDiversity option
        [<JsonPropertyName("sample_size")>]
        SampleSize: float option
        [<JsonPropertyName("timeout")>]
        Timeout: Duration option
        [<JsonPropertyName("use_significance")>]
        UseSignificance: bool
    }

    and TypesConnection = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("source")>]
        Source: float
        [<JsonPropertyName("target")>]
        Target: float
        [<JsonPropertyName("weight")>]
        Weight: float
    }

    and TypesVertex = {
        [<JsonPropertyName("depth")>]
        Depth: float
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("term")>]
        Term: string
        [<JsonPropertyName("weight")>]
        Weight: float
    }

    and HealthReportIndicatorNode = {
        [<JsonPropertyName("name")>]
        Name: System.Text.Json.JsonElement
        [<JsonPropertyName("node_id")>]
        NodeId: System.Text.Json.JsonElement
    }

    and HealthReportDiagnosisAffectedResources = {
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("nodes")>]
        Nodes: HealthReportIndicatorNode array option
        [<JsonPropertyName("slm_policies")>]
        SlmPolicies: string array option
        [<JsonPropertyName("feature_states")>]
        FeatureStates: string array option
        [<JsonPropertyName("snapshot_repositories")>]
        SnapshotRepositories: string array option
    }

    and HealthReportDiagnosis = {
        [<JsonPropertyName("id")>]
        Id: string
        [<JsonPropertyName("action")>]
        Action: string
        [<JsonPropertyName("affected_resources")>]
        AffectedResources: HealthReportDiagnosisAffectedResources
        [<JsonPropertyName("cause")>]
        Cause: string
        [<JsonPropertyName("help_url")>]
        HelpUrl: string
    }

    and HealthReportImpactAreaConverter() =
        inherit JsonConverter<HealthReportImpactArea>()

        override _.Write(writer: Utf8JsonWriter, value: HealthReportImpactArea, _options: JsonSerializerOptions) =
            let str =
                match value with
                | HealthReportImpactArea.Search -> "search"
                | HealthReportImpactArea.Ingest -> "ingest"
                | HealthReportImpactArea.Backup -> "backup"
                | HealthReportImpactArea.DeploymentManagement -> "deployment_management"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "search" -> HealthReportImpactArea.Search
            | "ingest" -> HealthReportImpactArea.Ingest
            | "backup" -> HealthReportImpactArea.Backup
            | "deployment_management" -> HealthReportImpactArea.DeploymentManagement
            | s -> failwith $"Unknown HealthReportImpactArea: {s}"

    and [<JsonConverter(typeof<HealthReportImpactAreaConverter>)>]
        HealthReportImpactArea =
        | Search
        | Ingest
        | Backup
        | DeploymentManagement
        with
        override this.ToString() =
            match this with
            | Search -> "search"
            | Ingest -> "ingest"
            | Backup -> "backup"
            | DeploymentManagement -> "deployment_management"

    and HealthReportImpact = {
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("id")>]
        Id: string
        [<JsonPropertyName("impact_areas")>]
        ImpactAreas: HealthReportImpactArea array
        [<JsonPropertyName("severity")>]
        Severity: float
    }

    and HealthReportIndicatorHealthStatusConverter() =
        inherit JsonConverter<HealthReportIndicatorHealthStatus>()

        override _.Write(writer: Utf8JsonWriter, value: HealthReportIndicatorHealthStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | HealthReportIndicatorHealthStatus.Green -> "green"
                | HealthReportIndicatorHealthStatus.Yellow -> "yellow"
                | HealthReportIndicatorHealthStatus.Red -> "red"
                | HealthReportIndicatorHealthStatus.Unknown -> "unknown"
                | HealthReportIndicatorHealthStatus.Unavailable -> "unavailable"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "green" -> HealthReportIndicatorHealthStatus.Green
            | "yellow" -> HealthReportIndicatorHealthStatus.Yellow
            | "red" -> HealthReportIndicatorHealthStatus.Red
            | "unknown" -> HealthReportIndicatorHealthStatus.Unknown
            | "unavailable" -> HealthReportIndicatorHealthStatus.Unavailable
            | s -> failwith $"Unknown HealthReportIndicatorHealthStatus: {s}"

    and [<JsonConverter(typeof<HealthReportIndicatorHealthStatusConverter>)>]
        HealthReportIndicatorHealthStatus =
        | Green
        | Yellow
        | Red
        | Unknown
        | Unavailable
        with
        override this.ToString() =
            match this with
            | Green -> "green"
            | Yellow -> "yellow"
            | Red -> "red"
            | Unknown -> "unknown"
            | Unavailable -> "unavailable"

    and HealthReportBaseIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
    }

    and HealthReportStagnatingBackingIndices = {
        [<JsonPropertyName("index_name")>]
        IndexName: IndexName
        [<JsonPropertyName("first_occurrence_timestamp")>]
        FirstOccurrenceTimestamp: float
        [<JsonPropertyName("retry_count")>]
        RetryCount: float
    }

    and HealthReportDataStreamLifecycleDetails = {
        [<JsonPropertyName("stagnating_backing_indices_count")>]
        StagnatingBackingIndicesCount: float
        [<JsonPropertyName("total_backing_indices_in_error")>]
        TotalBackingIndicesInError: float
        [<JsonPropertyName("stagnating_backing_indices")>]
        StagnatingBackingIndices: HealthReportStagnatingBackingIndices array option
    }

    /// <summary>
    /// DATA_STREAM_LIFECYCLE
    /// </summary>
    and HealthReportDataStreamLifecycleIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportDataStreamLifecycleDetails option
    }

    and HealthReportDiskIndicatorDetails = {
        [<JsonPropertyName("indices_with_readonly_block")>]
        IndicesWithReadonlyBlock: float
        [<JsonPropertyName("nodes_with_enough_disk_space")>]
        NodesWithEnoughDiskSpace: float
        [<JsonPropertyName("nodes_over_high_watermark")>]
        NodesOverHighWatermark: float
        [<JsonPropertyName("nodes_over_flood_stage_watermark")>]
        NodesOverFloodStageWatermark: float
        [<JsonPropertyName("nodes_with_unknown_disk_status")>]
        NodesWithUnknownDiskStatus: float
    }

    /// <summary>
    /// DISK
    /// </summary>
    and HealthReportDiskIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportDiskIndicatorDetails option
    }

    and HealthReportFileSettingsIndicatorDetails = {
        [<JsonPropertyName("failure_streak")>]
        FailureStreak: float
        [<JsonPropertyName("most_recent_failure")>]
        MostRecentFailure: string
    }

    /// <summary>
    /// FILE_SETTINGS
    /// </summary>
    and HealthReportFileSettingsIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportFileSettingsIndicatorDetails option
    }

    and LifecycleOperationModeConverter() =
        inherit JsonConverter<LifecycleOperationMode>()

        override _.Write(writer: Utf8JsonWriter, value: LifecycleOperationMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | LifecycleOperationMode.RUNNING -> "RUNNING"
                | LifecycleOperationMode.STOPPING -> "STOPPING"
                | LifecycleOperationMode.STOPPED -> "STOPPED"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "RUNNING" -> LifecycleOperationMode.RUNNING
            | "STOPPING" -> LifecycleOperationMode.STOPPING
            | "STOPPED" -> LifecycleOperationMode.STOPPED
            | s -> failwith $"Unknown LifecycleOperationMode: {s}"

    and [<JsonConverter(typeof<LifecycleOperationModeConverter>)>]
        LifecycleOperationMode =
        | RUNNING
        | STOPPING
        | STOPPED
        with
        override this.ToString() =
            match this with
            | RUNNING -> "RUNNING"
            | STOPPING -> "STOPPING"
            | STOPPED -> "STOPPED"

    and HealthReportIlmIndicatorDetails = {
        [<JsonPropertyName("ilm_status")>]
        IlmStatus: LifecycleOperationMode
        [<JsonPropertyName("policies")>]
        Policies: float
        [<JsonPropertyName("stagnating_indices")>]
        StagnatingIndices: float
    }

    /// <summary>
    /// ILM
    /// </summary>
    and HealthReportIlmIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportIlmIndicatorDetails option
    }

    and HealthReportMasterIsStableIndicatorClusterFormationNode = {
        [<JsonPropertyName("name")>]
        Name: string option
        [<JsonPropertyName("node_id")>]
        NodeId: string
        [<JsonPropertyName("cluster_formation_message")>]
        ClusterFormationMessage: string
    }

    and HealthReportMasterIsStableIndicatorExceptionFetchingHistory = {
        [<JsonPropertyName("message")>]
        Message: string
        [<JsonPropertyName("stack_trace")>]
        StackTrace: string
    }

    and HealthReportMasterIsStableIndicatorDetails = {
        [<JsonPropertyName("current_master")>]
        CurrentMaster: HealthReportIndicatorNode
        [<JsonPropertyName("recent_masters")>]
        RecentMasters: HealthReportIndicatorNode array
        [<JsonPropertyName("exception_fetching_history")>]
        ExceptionFetchingHistory: HealthReportMasterIsStableIndicatorExceptionFetchingHistory option
        [<JsonPropertyName("cluster_formation")>]
        ClusterFormation: HealthReportMasterIsStableIndicatorClusterFormationNode array option
    }

    /// <summary>
    /// MASTER_IS_STABLE
    /// </summary>
    and HealthReportMasterIsStableIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportMasterIsStableIndicatorDetails option
    }

    and HealthReportRepositoryIntegrityIndicatorDetails = {
        [<JsonPropertyName("total_repositories")>]
        TotalRepositories: float option
        [<JsonPropertyName("corrupted_repositories")>]
        CorruptedRepositories: float option
        [<JsonPropertyName("corrupted")>]
        Corrupted: string array option
    }

    /// <summary>
    /// REPOSITORY_INTEGRITY
    /// </summary>
    and HealthReportRepositoryIntegrityIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportRepositoryIntegrityIndicatorDetails option
    }

    and HealthReportShardsAvailabilityIndicatorDetails = {
        [<JsonPropertyName("creating_primaries")>]
        CreatingPrimaries: float
        [<JsonPropertyName("creating_replicas")>]
        CreatingReplicas: float
        [<JsonPropertyName("initializing_primaries")>]
        InitializingPrimaries: float
        [<JsonPropertyName("initializing_replicas")>]
        InitializingReplicas: float
        [<JsonPropertyName("restarting_primaries")>]
        RestartingPrimaries: float
        [<JsonPropertyName("restarting_replicas")>]
        RestartingReplicas: float
        [<JsonPropertyName("started_primaries")>]
        StartedPrimaries: float
        [<JsonPropertyName("started_replicas")>]
        StartedReplicas: float
        [<JsonPropertyName("unassigned_primaries")>]
        UnassignedPrimaries: float
        [<JsonPropertyName("unassigned_replicas")>]
        UnassignedReplicas: float
    }

    /// <summary>
    /// SHARDS_AVAILABILITY
    /// </summary>
    and HealthReportShardsAvailabilityIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportShardsAvailabilityIndicatorDetails option
    }

    and HealthReportShardsCapacityIndicatorTierDetail = {
        [<JsonPropertyName("max_shards_in_cluster")>]
        MaxShardsInCluster: float
        [<JsonPropertyName("current_used_shards")>]
        CurrentUsedShards: float option
    }

    and HealthReportShardsCapacityIndicatorDetails = {
        [<JsonPropertyName("data")>]
        Data: HealthReportShardsCapacityIndicatorTierDetail
        [<JsonPropertyName("frozen")>]
        Frozen: HealthReportShardsCapacityIndicatorTierDetail
    }

    /// <summary>
    /// SHARDS_CAPACITY
    /// </summary>
    and HealthReportShardsCapacityIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportShardsCapacityIndicatorDetails option
    }

    and HealthReportSlmIndicatorUnhealthyPolicies = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("invocations_since_last_success")>]
        InvocationsSinceLastSuccess: Map<string, float> option
    }

    and HealthReportSlmIndicatorDetails = {
        [<JsonPropertyName("slm_status")>]
        SlmStatus: LifecycleOperationMode
        [<JsonPropertyName("policies")>]
        Policies: float
        [<JsonPropertyName("unhealthy_policies")>]
        UnhealthyPolicies: HealthReportSlmIndicatorUnhealthyPolicies option
    }

    /// <summary>
    /// SLM
    /// </summary>
    and HealthReportSlmIndicator = {
        [<JsonPropertyName("status")>]
        Status: HealthReportIndicatorHealthStatus
        [<JsonPropertyName("symptom")>]
        Symptom: string
        [<JsonPropertyName("impacts")>]
        Impacts: HealthReportImpact array option
        [<JsonPropertyName("diagnosis")>]
        Diagnosis: HealthReportDiagnosis array option
        [<JsonPropertyName("details")>]
        Details: HealthReportSlmIndicatorDetails option
    }

    and HealthReportIndicators = {
        [<JsonPropertyName("master_is_stable")>]
        MasterIsStable: HealthReportMasterIsStableIndicator option
        [<JsonPropertyName("shards_availability")>]
        ShardsAvailability: HealthReportShardsAvailabilityIndicator option
        [<JsonPropertyName("disk")>]
        Disk: HealthReportDiskIndicator option
        [<JsonPropertyName("repository_integrity")>]
        RepositoryIntegrity: HealthReportRepositoryIntegrityIndicator option
        [<JsonPropertyName("data_stream_lifecycle")>]
        DataStreamLifecycle: HealthReportDataStreamLifecycleIndicator option
        [<JsonPropertyName("ilm")>]
        Ilm: HealthReportIlmIndicator option
        [<JsonPropertyName("slm")>]
        Slm: HealthReportSlmIndicator option
        [<JsonPropertyName("shards_capacity")>]
        ShardsCapacity: HealthReportShardsCapacityIndicator option
        [<JsonPropertyName("file_settings")>]
        FileSettings: HealthReportFileSettingsIndicator option
    }

    and TypesAllocateAction = {
        [<JsonPropertyName("number_of_replicas")>]
        NumberOfReplicas: float option
        [<JsonPropertyName("total_shards_per_node")>]
        TotalShardsPerNode: float option
        [<JsonPropertyName("include")>]
        Include: Map<string, string> option
        [<JsonPropertyName("exclude")>]
        Exclude: Map<string, string> option
        [<JsonPropertyName("require")>]
        Require: Map<string, string> option
    }

    and TypesDeleteAction = {
        [<JsonPropertyName("delete_searchable_snapshot")>]
        DeleteSearchableSnapshot: bool option
    }

    and TypesDownsampleAction = {
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: DurationLarge
        [<JsonPropertyName("wait_timeout")>]
        WaitTimeout: Duration option
    }

    and TypesForceMergeAction = {
        [<JsonPropertyName("max_num_segments")>]
        MaxNumSegments: float
        [<JsonPropertyName("index_codec")>]
        IndexCodec: string option
    }

    and TypesMigrateAction = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
    }

    and TypesRolloverAction = {
        [<JsonPropertyName("max_size")>]
        MaxSize: ByteSize option
        [<JsonPropertyName("max_primary_shard_size")>]
        MaxPrimaryShardSize: ByteSize option
        [<JsonPropertyName("max_age")>]
        MaxAge: Duration option
        [<JsonPropertyName("max_docs")>]
        MaxDocs: float option
        [<JsonPropertyName("max_primary_shard_docs")>]
        MaxPrimaryShardDocs: float option
        [<JsonPropertyName("min_size")>]
        MinSize: ByteSize option
        [<JsonPropertyName("min_primary_shard_size")>]
        MinPrimaryShardSize: ByteSize option
        [<JsonPropertyName("min_age")>]
        MinAge: Duration option
        [<JsonPropertyName("min_docs")>]
        MinDocs: float option
        [<JsonPropertyName("min_primary_shard_docs")>]
        MinPrimaryShardDocs: float option
    }

    and TypesSearchableSnapshotAction = {
        [<JsonPropertyName("snapshot_repository")>]
        SnapshotRepository: string
        [<JsonPropertyName("force_merge_index")>]
        ForceMergeIndex: bool option
    }

    and TypesSetPriorityAction = {
        [<JsonPropertyName("priority")>]
        Priority: float option
    }

    and TypesShrinkAction = {
        [<JsonPropertyName("number_of_shards")>]
        NumberOfShards: float option
        [<JsonPropertyName("max_primary_shard_size")>]
        MaxPrimaryShardSize: ByteSize option
        [<JsonPropertyName("allow_write_after_shrink")>]
        AllowWriteAfterShrink: bool option
    }

    and TypesWaitForSnapshotAction = {
        [<JsonPropertyName("policy")>]
        Policy: string
    }

    and TypesActions = {
        [<JsonPropertyName("allocate")>]
        Allocate: TypesAllocateAction option
        [<JsonPropertyName("delete")>]
        Delete: TypesDeleteAction option
        [<JsonPropertyName("downsample")>]
        Downsample: TypesDownsampleAction option
        [<JsonPropertyName("freeze")>]
        Freeze: EmptyObject option
        [<JsonPropertyName("forcemerge")>]
        Forcemerge: TypesForceMergeAction option
        [<JsonPropertyName("migrate")>]
        Migrate: TypesMigrateAction option
        [<JsonPropertyName("readonly")>]
        Readonly: EmptyObject option
        [<JsonPropertyName("rollover")>]
        Rollover: TypesRolloverAction option
        [<JsonPropertyName("set_priority")>]
        SetPriority: TypesSetPriorityAction option
        [<JsonPropertyName("searchable_snapshot")>]
        SearchableSnapshot: TypesSearchableSnapshotAction option
        [<JsonPropertyName("shrink")>]
        Shrink: TypesShrinkAction option
        [<JsonPropertyName("unfollow")>]
        Unfollow: EmptyObject option
        [<JsonPropertyName("wait_for_snapshot")>]
        WaitForSnapshot: TypesWaitForSnapshotAction option
    }

    and TypesPhase = {
        [<JsonPropertyName("actions")>]
        Actions: TypesActions option
        [<JsonPropertyName("min_age")>]
        MinAge: Duration option
    }

    and ExplainLifecycleLifecycleExplainPhaseExecution = {
        [<JsonPropertyName("phase_definition")>]
        PhaseDefinition: TypesPhase option
        [<JsonPropertyName("policy")>]
        Policy: Name
        [<JsonPropertyName("version")>]
        Version: VersionNumber
        [<JsonPropertyName("modified_date_in_millis")>]
        ModifiedDateInMillis: EpochTimeUnitMillis
    }

    and ExplainLifecycleLifecycleExplainManaged = {
        [<JsonPropertyName("action")>]
        Action: Name option
        [<JsonPropertyName("action_time")>]
        ActionTime: DateTime option
        [<JsonPropertyName("action_time_millis")>]
        ActionTimeMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("age")>]
        Age: Duration option
        [<JsonPropertyName("age_in_millis")>]
        AgeInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("failed_step")>]
        FailedStep: Name option
        [<JsonPropertyName("failed_step_retry_count")>]
        FailedStepRetryCount: float option
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("index_creation_date")>]
        IndexCreationDate: DateTime option
        [<JsonPropertyName("index_creation_date_millis")>]
        IndexCreationDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("is_auto_retryable_error")>]
        IsAutoRetryableError: bool option
        [<JsonPropertyName("lifecycle_date")>]
        LifecycleDate: DateTime option
        [<JsonPropertyName("lifecycle_date_millis")>]
        LifecycleDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("managed")>]
        Managed: string
        [<JsonPropertyName("phase")>]
        Phase: Name option
        [<JsonPropertyName("phase_time")>]
        PhaseTime: DateTime option
        [<JsonPropertyName("phase_time_millis")>]
        PhaseTimeMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("policy")>]
        Policy: Name option
        [<JsonPropertyName("previous_step_info")>]
        PreviousStepInfo: Map<string, obj> option
        [<JsonPropertyName("repository_name")>]
        RepositoryName: string option
        [<JsonPropertyName("snapshot_name")>]
        SnapshotName: string option
        [<JsonPropertyName("shrink_index_name")>]
        ShrinkIndexName: string option
        [<JsonPropertyName("step")>]
        Step: Name option
        [<JsonPropertyName("step_info")>]
        StepInfo: Map<string, obj> option
        [<JsonPropertyName("step_time")>]
        StepTime: DateTime option
        [<JsonPropertyName("step_time_millis")>]
        StepTimeMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("phase_execution")>]
        PhaseExecution: ExplainLifecycleLifecycleExplainPhaseExecution option
        [<JsonPropertyName("time_since_index_creation")>]
        TimeSinceIndexCreation: Duration option
        [<JsonPropertyName("skip")>]
        Skip: bool
    }

    and ExplainLifecycleLifecycleExplainUnmanaged = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("managed")>]
        Managed: string
    }

    and ExplainLifecycleLifecycleExplainConverter() =
        inherit JsonConverter<ExplainLifecycleLifecycleExplain>()

        override _.Write(writer: Utf8JsonWriter, value: ExplainLifecycleLifecycleExplain, options: JsonSerializerOptions) =
            match value with
            | ExplainLifecycleLifecycleExplain.False v -> JsonSerializer.Serialize(writer, v, options)
            | ExplainLifecycleLifecycleExplain.True v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("managed") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "false" -> ExplainLifecycleLifecycleExplain.False (JsonSerializer.Deserialize<ExplainLifecycleLifecycleExplainUnmanaged>(json, options))
            | "true" -> ExplainLifecycleLifecycleExplain.True (JsonSerializer.Deserialize<ExplainLifecycleLifecycleExplainManaged>(json, options))
            | s -> failwith $"Unknown ExplainLifecycleLifecycleExplain type: {s}"

    and [<JsonConverter(typeof<ExplainLifecycleLifecycleExplainConverter>)>]
        ExplainLifecycleLifecycleExplain =
        | False of ExplainLifecycleLifecycleExplainUnmanaged
        | True of ExplainLifecycleLifecycleExplainManaged

    and ExplainLifecycleLifecycleExplainTypeConverter() =
        inherit JsonConverter<ExplainLifecycleLifecycleExplainType>()

        override _.Write(writer: Utf8JsonWriter, value: ExplainLifecycleLifecycleExplainType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ExplainLifecycleLifecycleExplainType.False -> "false"
                | ExplainLifecycleLifecycleExplainType.True -> "true"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "false" -> ExplainLifecycleLifecycleExplainType.False
            | "true" -> ExplainLifecycleLifecycleExplainType.True
            | s -> failwith $"Unknown ExplainLifecycleLifecycleExplainType: {s}"

    and [<JsonConverter(typeof<ExplainLifecycleLifecycleExplainTypeConverter>)>]
        ExplainLifecycleLifecycleExplainType =
        | False
        | True
        with
        override this.ToString() =
            match this with
            | False -> "false"
            | True -> "true"

    and GetLifecycleLifecycle = {
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: DateTime
        [<JsonPropertyName("policy")>]
        Policy: System.Text.Json.JsonElement
        [<JsonPropertyName("version")>]
        Version: VersionNumber
    }

    and TypesPhases = {
        [<JsonPropertyName("cold")>]
        Cold: TypesPhase option
        [<JsonPropertyName("delete")>]
        Delete: TypesPhase option
        [<JsonPropertyName("frozen")>]
        Frozen: TypesPhase option
        [<JsonPropertyName("hot")>]
        Hot: TypesPhase option
        [<JsonPropertyName("warm")>]
        Warm: TypesPhase option
    }

    and MoveToStepStepKey = {
        [<JsonPropertyName("action")>]
        Action: string option
        [<JsonPropertyName("name")>]
        Name: string option
        [<JsonPropertyName("phase")>]
        Phase: string
    }

    and OpTypeConverter() =
        inherit JsonConverter<OpType>()

        override _.Write(writer: Utf8JsonWriter, value: OpType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | OpType.Index -> "index"
                | OpType.Create -> "create"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "index" -> OpType.Index
            | "create" -> OpType.Create
            | s -> failwith $"Unknown OpType: {s}"

    and [<JsonConverter(typeof<OpTypeConverter>)>]
        OpType =
        | Index
        | Create
        with
        override this.ToString() =
            match this with
            | Index -> "index"
            | Create -> "create"

    and TypesIndicesBlockOptionsConverter() =
        inherit JsonConverter<TypesIndicesBlockOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesIndicesBlockOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesIndicesBlockOptions.Metadata -> "metadata"
                | TypesIndicesBlockOptions.Read -> "read"
                | TypesIndicesBlockOptions.ReadOnly -> "read_only"
                | TypesIndicesBlockOptions.Write -> "write"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "metadata" -> TypesIndicesBlockOptions.Metadata
            | "read" -> TypesIndicesBlockOptions.Read
            | "read_only" -> TypesIndicesBlockOptions.ReadOnly
            | "write" -> TypesIndicesBlockOptions.Write
            | s -> failwith $"Unknown TypesIndicesBlockOptions: {s}"

    and [<JsonConverter(typeof<TypesIndicesBlockOptionsConverter>)>]
        TypesIndicesBlockOptions =
        | Metadata
        | Read
        | ReadOnly
        | Write
        with
        override this.ToString() =
            match this with
            | Metadata -> "metadata"
            | Read -> "read"
            | ReadOnly -> "read_only"
            | Write -> "write"

    and AddBlockAddIndicesBlockStatus = {
        [<JsonPropertyName("name")>]
        Name: IndexName
        [<JsonPropertyName("blocked")>]
        Blocked: bool
    }

    and AnalyzeTextToAnalyze = obj

    and AnalyzeExplainAnalyzeToken = {
        [<JsonPropertyName("bytes")>]
        Bytes: string
        [<JsonPropertyName("end_offset")>]
        EndOffset: float
        [<JsonPropertyName("keyword")>]
        Keyword: bool option
        [<JsonPropertyName("position")>]
        Position: float
        [<JsonPropertyName("positionLength")>]
        PositionLength: float
        [<JsonPropertyName("start_offset")>]
        StartOffset: float
        [<JsonPropertyName("termFrequency")>]
        TermFrequency: float
        [<JsonPropertyName("token")>]
        Token: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AnalyzeAnalyzerDetail = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("tokens")>]
        Tokens: AnalyzeExplainAnalyzeToken array
    }

    and AnalyzeCharFilterDetail = {
        [<JsonPropertyName("filtered_text")>]
        FilteredText: string array
        [<JsonPropertyName("name")>]
        Name: string
    }

    and AnalyzeTokenDetail = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("tokens")>]
        Tokens: AnalyzeExplainAnalyzeToken array
    }

    and AnalyzeAnalyzeDetail = {
        [<JsonPropertyName("analyzer")>]
        Analyzer: AnalyzeAnalyzerDetail option
        [<JsonPropertyName("charfilters")>]
        Charfilters: AnalyzeCharFilterDetail array option
        [<JsonPropertyName("custom_analyzer")>]
        CustomAnalyzer: bool
        [<JsonPropertyName("tokenfilters")>]
        Tokenfilters: AnalyzeTokenDetail array option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: AnalyzeTokenDetail option
    }

    and AnalyzeAnalyzeToken = {
        [<JsonPropertyName("end_offset")>]
        EndOffset: float
        [<JsonPropertyName("position")>]
        Position: float
        [<JsonPropertyName("positionLength")>]
        PositionLength: float option
        [<JsonPropertyName("start_offset")>]
        StartOffset: float
        [<JsonPropertyName("token")>]
        Token: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and ShardsOperationResponseBase = {
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics option
    }

    and CloseCloseShardResult = {
        [<JsonPropertyName("failures")>]
        Failures: ShardFailure array
    }

    and CloseCloseIndexResult = {
        [<JsonPropertyName("closed")>]
        Closed: bool
        [<JsonPropertyName("shards")>]
        Shards: Map<string, CloseCloseShardResult> option
    }

    and DataStreamName = string

    and CreateFromCreateFrom = {
        [<JsonPropertyName("mappings_override")>]
        MappingsOverride: MappingTypeMapping option
        [<JsonPropertyName("settings_override")>]
        SettingsOverride: TypesIndexSettings option
        [<JsonPropertyName("remove_index_blocks")>]
        RemoveIndexBlocks: bool option
    }

    and DataStreamsStatsDataStreamsStatsItem = {
        [<JsonPropertyName("backing_indices")>]
        BackingIndices: float
        [<JsonPropertyName("data_stream")>]
        DataStream: Name
        [<JsonPropertyName("maximum_timestamp")>]
        MaximumTimestamp: EpochTimeUnitMillis
        [<JsonPropertyName("store_size")>]
        StoreSize: ByteSize option
        [<JsonPropertyName("store_size_bytes")>]
        StoreSizeBytes: float
    }

    and IndicesResponseBase = {
        [<JsonPropertyName("acknowledged")>]
        Acknowledged: bool
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics option
    }

    and DeleteAliasIndicesAliasesResponseBody = {
        [<JsonPropertyName("acknowledged")>]
        Acknowledged: bool
        [<JsonPropertyName("errors")>]
        Errors: bool option
    }

    and DataStreamNames = obj

    and TypesDownsampleConfig = {
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: DurationLarge
        [<JsonPropertyName("sampling_method")>]
        SamplingMethod: TypesSamplingMethod option
    }

    and ExplainDataLifecycleDataStreamLifecycleExplain = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("managed_by_lifecycle")>]
        ManagedByLifecycle: bool
        [<JsonPropertyName("index_creation_date_millis")>]
        IndexCreationDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("time_since_index_creation")>]
        TimeSinceIndexCreation: Duration option
        [<JsonPropertyName("rollover_date_millis")>]
        RolloverDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("time_since_rollover")>]
        TimeSinceRollover: Duration option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycleWithRollover option
        [<JsonPropertyName("generation_time")>]
        GenerationTime: Duration option
        [<JsonPropertyName("error")>]
        Error: string option
    }

    and FieldUsageStatsFieldsUsageBody = {
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
    }

    and ForcemergeTypesForceMergeResponseBody = {
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics option
        [<JsonPropertyName("task")>]
        Task: string option
    }

    and GetFeatureConverter() =
        inherit JsonConverter<GetFeature>()

        override _.Write(writer: Utf8JsonWriter, value: GetFeature, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GetFeature.Aliases -> "aliases"
                | GetFeature.Mappings -> "mappings"
                | GetFeature.Settings -> "settings"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "aliases" -> GetFeature.Aliases
            | "mappings" -> GetFeature.Mappings
            | "settings" -> GetFeature.Settings
            | s -> failwith $"Unknown GetFeature: {s}"

    and [<JsonConverter(typeof<GetFeatureConverter>)>]
        GetFeature =
        | Aliases
        | Mappings
        | Settings
        with
        override this.ToString() =
            match this with
            | Aliases -> "aliases"
            | Mappings -> "mappings"
            | Settings -> "settings"

    and GetFeatures = obj

    and TypesIndexState = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAlias> option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings option
        [<JsonPropertyName("defaults")>]
        Defaults: TypesIndexSettings option
        [<JsonPropertyName("data_stream")>]
        DataStream: DataStreamName option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycle option
    }

    and GetAliasTypesIndexAliases = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAliasDefinition>
    }

    and GetDataLifecycleDataStreamWithLifecycle = {
        [<JsonPropertyName("name")>]
        Name: DataStreamName
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycleWithRollover option
    }

    and GetDataLifecycleStatsDataStreamStats = {
        [<JsonPropertyName("backing_indices_in_error")>]
        BackingIndicesInError: float
        [<JsonPropertyName("backing_indices_in_total")>]
        BackingIndicesInTotal: float
        [<JsonPropertyName("name")>]
        Name: DataStreamName
    }

    and TypesIndexModeConverter() =
        inherit JsonConverter<TypesIndexMode>()

        override _.Write(writer: Utf8JsonWriter, value: TypesIndexMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesIndexMode.Standard -> "standard"
                | TypesIndexMode.TimeSeries -> "time_series"
                | TypesIndexMode.Logsdb -> "logsdb"
                | TypesIndexMode.Lookup -> "lookup"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "standard" -> TypesIndexMode.Standard
            | "time_series" -> TypesIndexMode.TimeSeries
            | "logsdb" -> TypesIndexMode.Logsdb
            | "lookup" -> TypesIndexMode.Lookup
            | s -> failwith $"Unknown TypesIndexMode: {s}"

    and [<JsonConverter(typeof<TypesIndexModeConverter>)>]
        TypesIndexMode =
        | Standard
        | TimeSeries
        | Logsdb
        | Lookup
        with
        override this.ToString() =
            match this with
            | Standard -> "standard"
            | TimeSeries -> "time_series"
            | Logsdb -> "logsdb"
            | Lookup -> "lookup"

    and TypesManagedByConverter() =
        inherit JsonConverter<TypesManagedBy>()

        override _.Write(writer: Utf8JsonWriter, value: TypesManagedBy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesManagedBy.IndexLifecycleManagement -> "Index Lifecycle Management"
                | TypesManagedBy.DataStreamLifecycle -> "Data stream lifecycle"
                | TypesManagedBy.Unmanaged -> "Unmanaged"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "Index Lifecycle Management" -> TypesManagedBy.IndexLifecycleManagement
            | "Data stream lifecycle" -> TypesManagedBy.DataStreamLifecycle
            | "Unmanaged" -> TypesManagedBy.Unmanaged
            | s -> failwith $"Unknown TypesManagedBy: {s}"

    and [<JsonConverter(typeof<TypesManagedByConverter>)>]
        TypesManagedBy =
        | IndexLifecycleManagement
        | DataStreamLifecycle
        | Unmanaged
        with
        override this.ToString() =
            match this with
            | IndexLifecycleManagement -> "Index Lifecycle Management"
            | DataStreamLifecycle -> "Data stream lifecycle"
            | Unmanaged -> "Unmanaged"

    and TypesDataStreamIndex = {
        [<JsonPropertyName("index_name")>]
        IndexName: IndexName
        [<JsonPropertyName("index_uuid")>]
        IndexUuid: Uuid
        [<JsonPropertyName("ilm_policy")>]
        IlmPolicy: Name option
        [<JsonPropertyName("managed_by")>]
        ManagedBy: TypesManagedBy option
        [<JsonPropertyName("prefer_ilm")>]
        PreferIlm: bool option
        [<JsonPropertyName("index_mode")>]
        IndexMode: TypesIndexMode option
    }

    and TypesDataStreamTimestampField = {
        [<JsonPropertyName("name")>]
        Name: Field
    }

    and TypesFailureStore = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("indices")>]
        Indices: TypesDataStreamIndex array
        [<JsonPropertyName("rollover_on_write")>]
        RolloverOnWrite: bool
    }

    and TypesDataStream = {
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("allow_custom_routing")>]
        AllowCustomRouting: bool option
        [<JsonPropertyName("failure_store")>]
        FailureStore: TypesFailureStore option
        [<JsonPropertyName("generation")>]
        Generation: float
        [<JsonPropertyName("hidden")>]
        Hidden: bool
        [<JsonPropertyName("ilm_policy")>]
        IlmPolicy: Name option
        [<JsonPropertyName("next_generation_managed_by")>]
        NextGenerationManagedBy: TypesManagedBy
        [<JsonPropertyName("prefer_ilm")>]
        PreferIlm: bool
        [<JsonPropertyName("indices")>]
        Indices: TypesDataStreamIndex array
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycleWithRollover option
        [<JsonPropertyName("name")>]
        Name: DataStreamName
        [<JsonPropertyName("replicated")>]
        Replicated: bool option
        [<JsonPropertyName("rollover_on_write")>]
        RolloverOnWrite: bool
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("system")>]
        System: bool option
        [<JsonPropertyName("template")>]
        Template: Name
        [<JsonPropertyName("timestamp_field")>]
        TimestampField: TypesDataStreamTimestampField
        [<JsonPropertyName("index_mode")>]
        IndexMode: TypesIndexMode option
    }

    and GetDataStreamMappingsDataStreamMappings = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping
        [<JsonPropertyName("effective_mappings")>]
        EffectiveMappings: MappingTypeMapping
    }

    and GetDataStreamOptionsDataStreamWithOptions = {
        [<JsonPropertyName("name")>]
        Name: DataStreamName
        [<JsonPropertyName("options")>]
        Options: TypesDataStreamOptions option
    }

    and GetDataStreamSettingsDataStreamSettings = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings
        [<JsonPropertyName("effective_settings")>]
        EffectiveSettings: TypesIndexSettings
    }

    and MappingFieldMapping = {
        [<JsonPropertyName("full_name")>]
        FullName: string
        [<JsonPropertyName("mapping")>]
        Mapping: Map<string, MappingProperty>
    }

    and GetFieldMappingTypeFieldMappings = {
        [<JsonPropertyName("mappings")>]
        Mappings: Map<string, MappingFieldMapping>
    }

    and TypesIndexTemplateDataStreamConfiguration = {
        [<JsonPropertyName("hidden")>]
        Hidden: bool option
        [<JsonPropertyName("allow_custom_routing")>]
        AllowCustomRouting: bool option
    }

    and TypesIndexTemplateSummary = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAlias> option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings option
        [<JsonPropertyName("lifecycle")>]
        Lifecycle: TypesDataStreamLifecycleWithRollover option
        [<JsonPropertyName("data_stream_options")>]
        DataStreamOptions: TypesDataStreamOptions option
    }

    and TypesIndexTemplate = {
        [<JsonPropertyName("index_patterns")>]
        IndexPatterns: Names
        [<JsonPropertyName("composed_of")>]
        ComposedOf: Name array
        [<JsonPropertyName("template")>]
        Template: TypesIndexTemplateSummary option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("priority")>]
        Priority: float option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("allow_auto_create")>]
        AllowAutoCreate: bool option
        [<JsonPropertyName("data_stream")>]
        DataStream: TypesIndexTemplateDataStreamConfiguration option
        [<JsonPropertyName("deprecated")>]
        Deprecated: bool option
        [<JsonPropertyName("ignore_missing_component_templates")>]
        IgnoreMissingComponentTemplates: Names option
        [<JsonPropertyName("created_date")>]
        CreatedDate: DateTime option
        [<JsonPropertyName("created_date_millis")>]
        CreatedDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: DateTime option
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis option
    }

    and GetIndexTemplateIndexTemplateItem = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("index_template")>]
        IndexTemplate: TypesIndexTemplate
    }

    and GetMappingIndexMappingRecord = {
        [<JsonPropertyName("item")>]
        Item: MappingTypeMapping option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping
    }

    and GetMigrateReindexStatusStatusInProgress = {
        [<JsonPropertyName("index")>]
        Index: string
        [<JsonPropertyName("total_doc_count")>]
        TotalDocCount: float
        [<JsonPropertyName("reindexed_doc_count")>]
        ReindexedDocCount: float
    }

    and GetMigrateReindexStatusStatusError = {
        [<JsonPropertyName("index")>]
        Index: string
        [<JsonPropertyName("message")>]
        Message: string
    }

    and TypesTemplateMapping = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAlias>
        [<JsonPropertyName("index_patterns")>]
        IndexPatterns: Name array
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping
        [<JsonPropertyName("order")>]
        Order: float
        [<JsonPropertyName("settings")>]
        Settings: Map<string, obj>
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
    }

    and MigrateReindexModeEnumConverter() =
        inherit JsonConverter<MigrateReindexModeEnum>()

        override _.Write(writer: Utf8JsonWriter, value: MigrateReindexModeEnum, _options: JsonSerializerOptions) =
            let str =
                match value with
                | MigrateReindexModeEnum.Upgrade -> "upgrade"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "upgrade" -> MigrateReindexModeEnum.Upgrade
            | s -> failwith $"Unknown MigrateReindexModeEnum: {s}"

    and [<JsonConverter(typeof<MigrateReindexModeEnumConverter>)>]
        MigrateReindexModeEnum =
        | Upgrade
        with
        override this.ToString() =
            match this with
            | Upgrade -> "upgrade"

    and MigrateReindexSourceIndex = {
        [<JsonPropertyName("index")>]
        Index: IndexName
    }

    and MigrateReindexMigrateReindex = {
        [<JsonPropertyName("mode")>]
        Mode: MigrateReindexModeEnum
        [<JsonPropertyName("source")>]
        Source: MigrateReindexSourceIndex
    }

    and ModifyDataStreamIndexAndDataStreamAction = {
        [<JsonPropertyName("data_stream")>]
        DataStream: DataStreamName
        [<JsonPropertyName("index")>]
        Index: IndexName
    }

    and ModifyDataStreamAction = {
        [<JsonPropertyName("add_backing_index")>]
        AddBackingIndex: ModifyDataStreamIndexAndDataStreamAction option
        [<JsonPropertyName("remove_backing_index")>]
        RemoveBackingIndex: ModifyDataStreamIndexAndDataStreamAction option
    }

    and PutDataStreamMappingsUpdatedDataStreamMappings = {
        [<JsonPropertyName("name")>]
        Name: IndexName
        [<JsonPropertyName("applied_to_data_stream")>]
        AppliedToDataStream: bool
        [<JsonPropertyName("error")>]
        Error: string option
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping option
        [<JsonPropertyName("effective_mappings")>]
        EffectiveMappings: MappingTypeMapping option
    }

    and PutDataStreamSettingsDataStreamSettingsError = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("error")>]
        Error: string
    }

    and PutDataStreamSettingsIndexSettingResults = {
        [<JsonPropertyName("applied_to_data_stream_only")>]
        AppliedToDataStreamOnly: string array
        [<JsonPropertyName("applied_to_data_stream_and_backing_indices")>]
        AppliedToDataStreamAndBackingIndices: string array
        [<JsonPropertyName("errors")>]
        Errors: PutDataStreamSettingsDataStreamSettingsError array option
    }

    and PutDataStreamSettingsUpdatedDataStreamSettings = {
        [<JsonPropertyName("name")>]
        Name: IndexName
        [<JsonPropertyName("applied_to_data_stream")>]
        AppliedToDataStream: bool
        [<JsonPropertyName("error")>]
        Error: string option
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings
        [<JsonPropertyName("effective_settings")>]
        EffectiveSettings: TypesIndexSettings
        [<JsonPropertyName("index_settings_results")>]
        IndexSettingsResults: PutDataStreamSettingsIndexSettingResults
    }

    and TypesDataStreamVisibility = {
        [<JsonPropertyName("hidden")>]
        Hidden: bool option
        [<JsonPropertyName("allow_custom_routing")>]
        AllowCustomRouting: bool option
    }

    and RecoveryRecoveryBytes = {
        [<JsonPropertyName("percent")>]
        Percent: Percentage
        [<JsonPropertyName("recovered")>]
        Recovered: ByteSize option
        [<JsonPropertyName("recovered_in_bytes")>]
        RecoveredInBytes: ByteSize
        [<JsonPropertyName("recovered_from_snapshot")>]
        RecoveredFromSnapshot: ByteSize option
        [<JsonPropertyName("recovered_from_snapshot_in_bytes")>]
        RecoveredFromSnapshotInBytes: ByteSize option
        [<JsonPropertyName("reused")>]
        Reused: ByteSize option
        [<JsonPropertyName("reused_in_bytes")>]
        ReusedInBytes: ByteSize
        [<JsonPropertyName("total")>]
        Total: ByteSize option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: ByteSize
    }

    and RecoveryFileDetails = {
        [<JsonPropertyName("length")>]
        Length: float
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("recovered")>]
        Recovered: float
    }

    and RecoveryRecoveryFiles = {
        [<JsonPropertyName("details")>]
        Details: RecoveryFileDetails array option
        [<JsonPropertyName("percent")>]
        Percent: Percentage
        [<JsonPropertyName("recovered")>]
        Recovered: float
        [<JsonPropertyName("reused")>]
        Reused: float
        [<JsonPropertyName("total")>]
        Total: float
    }

    and RecoveryRecoveryIndexStatus = {
        [<JsonPropertyName("bytes")>]
        Bytes: RecoveryRecoveryBytes option
        [<JsonPropertyName("files")>]
        Files: RecoveryRecoveryFiles
        [<JsonPropertyName("size")>]
        Size: RecoveryRecoveryBytes
        [<JsonPropertyName("source_throttle_time")>]
        SourceThrottleTime: Duration option
        [<JsonPropertyName("source_throttle_time_in_millis")>]
        SourceThrottleTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("target_throttle_time")>]
        TargetThrottleTime: Duration option
        [<JsonPropertyName("target_throttle_time_in_millis")>]
        TargetThrottleTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RecoveryRecoveryOrigin = {
        [<JsonPropertyName("hostname")>]
        Hostname: string option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("ip")>]
        Ip: Ip option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("bootstrap_new_history_uuid")>]
        BootstrapNewHistoryUuid: bool option
        [<JsonPropertyName("repository")>]
        Repository: Name option
        [<JsonPropertyName("snapshot")>]
        Snapshot: Name option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("restoreUUID")>]
        RestoreUUID: Uuid option
        [<JsonPropertyName("index")>]
        Index: IndexName option
    }

    and RecoveryRecoveryStartStatus = {
        [<JsonPropertyName("check_index_time")>]
        CheckIndexTime: Duration option
        [<JsonPropertyName("check_index_time_in_millis")>]
        CheckIndexTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RecoveryTranslogStatus = {
        [<JsonPropertyName("percent")>]
        Percent: Percentage
        [<JsonPropertyName("recovered")>]
        Recovered: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("total_on_start")>]
        TotalOnStart: float
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RecoveryVerifyIndex = {
        [<JsonPropertyName("check_index_time")>]
        CheckIndexTime: Duration option
        [<JsonPropertyName("check_index_time_in_millis")>]
        CheckIndexTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RecoveryShardRecovery = {
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("index")>]
        Index: RecoveryRecoveryIndexStatus
        [<JsonPropertyName("primary")>]
        Primary: bool
        [<JsonPropertyName("source")>]
        Source: RecoveryRecoveryOrigin
        [<JsonPropertyName("stage")>]
        Stage: string
        [<JsonPropertyName("start")>]
        Start: RecoveryRecoveryStartStatus option
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("stop_time")>]
        StopTime: DateTime option
        [<JsonPropertyName("stop_time_in_millis")>]
        StopTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("target")>]
        Target: RecoveryRecoveryOrigin
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("translog")>]
        Translog: RecoveryTranslogStatus
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("verify_index")>]
        VerifyIndex: RecoveryVerifyIndex
    }

    and RecoveryRecoveryStatus = {
        [<JsonPropertyName("shards")>]
        Shards: RecoveryShardRecovery array
    }

    and ReloadSearchAnalyzersReloadDetails = {
        [<JsonPropertyName("index")>]
        Index: string
        [<JsonPropertyName("reloaded_analyzers")>]
        ReloadedAnalyzers: string array
        [<JsonPropertyName("reloaded_node_ids")>]
        ReloadedNodeIds: string array
    }

    and ReloadSearchAnalyzersReloadResult = {
        [<JsonPropertyName("reload_details")>]
        ReloadDetails: ReloadSearchAnalyzersReloadDetails array
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
    }

    and RemoveBlockRemoveIndicesBlockStatus = {
        [<JsonPropertyName("name")>]
        Name: IndexName
        [<JsonPropertyName("unblocked")>]
        Unblocked: bool option
        [<JsonPropertyName("exception")>]
        Exception: ErrorCause option
    }

    /// <summary>
    /// Reduced (minimal) info ElasticsearchVersion
    /// </summary>
    and ElasticsearchVersionMinInfo = {
        [<JsonPropertyName("build_flavor")>]
        BuildFlavor: string
        [<JsonPropertyName("minimum_index_compatibility_version")>]
        MinimumIndexCompatibilityVersion: VersionString
        [<JsonPropertyName("minimum_wire_compatibility_version")>]
        MinimumWireCompatibilityVersion: VersionString
        [<JsonPropertyName("number")>]
        Number: string
    }

    /// <summary>
    /// Provides information about each cluster request relevant to doing a cross-cluster search.
    /// </summary>
    and ResolveClusterResolveClusterInfo = {
        [<JsonPropertyName("connected")>]
        Connected: bool
        [<JsonPropertyName("skip_unavailable")>]
        SkipUnavailable: bool
        [<JsonPropertyName("matching_indices")>]
        MatchingIndices: bool option
        [<JsonPropertyName("error")>]
        Error: string option
        [<JsonPropertyName("version")>]
        Version: ElasticsearchVersionMinInfo option
    }

    and ResolveIndexResolveIndexItem = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("aliases")>]
        Aliases: string array option
        [<JsonPropertyName("attributes")>]
        Attributes: string array
        [<JsonPropertyName("data_stream")>]
        DataStream: DataStreamName option
        [<JsonPropertyName("mode")>]
        Mode: TypesIndexMode option
    }

    and ResolveIndexResolveIndexAliasItem = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("indices")>]
        Indices: Indices
    }

    and ResolveIndexResolveIndexDataStreamsItem = {
        [<JsonPropertyName("name")>]
        Name: DataStreamName
        [<JsonPropertyName("timestamp_field")>]
        TimestampField: Field
        [<JsonPropertyName("backing_indices")>]
        BackingIndices: Indices
    }

    and RolloverRolloverConditions = {
        [<JsonPropertyName("min_age")>]
        MinAge: Duration option
        [<JsonPropertyName("max_age")>]
        MaxAge: Duration option
        [<JsonPropertyName("max_age_millis")>]
        MaxAgeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("min_docs")>]
        MinDocs: float option
        [<JsonPropertyName("max_docs")>]
        MaxDocs: float option
        [<JsonPropertyName("max_size")>]
        MaxSize: ByteSize option
        [<JsonPropertyName("max_size_bytes")>]
        MaxSizeBytes: float option
        [<JsonPropertyName("min_size")>]
        MinSize: ByteSize option
        [<JsonPropertyName("min_size_bytes")>]
        MinSizeBytes: float option
        [<JsonPropertyName("max_primary_shard_size")>]
        MaxPrimaryShardSize: ByteSize option
        [<JsonPropertyName("max_primary_shard_size_bytes")>]
        MaxPrimaryShardSizeBytes: float option
        [<JsonPropertyName("min_primary_shard_size")>]
        MinPrimaryShardSize: ByteSize option
        [<JsonPropertyName("min_primary_shard_size_bytes")>]
        MinPrimaryShardSizeBytes: float option
        [<JsonPropertyName("max_primary_shard_docs")>]
        MaxPrimaryShardDocs: float option
        [<JsonPropertyName("min_primary_shard_docs")>]
        MinPrimaryShardDocs: float option
    }

    and SegmentsSegment = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("committed")>]
        Committed: bool
        [<JsonPropertyName("compound")>]
        Compound: bool
        [<JsonPropertyName("deleted_docs")>]
        DeletedDocs: float
        [<JsonPropertyName("generation")>]
        Generation: float
        [<JsonPropertyName("search")>]
        Search: bool
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("num_docs")>]
        NumDocs: float
        [<JsonPropertyName("version")>]
        Version: VersionString
    }

    and SegmentsShardSegmentRouting = {
        [<JsonPropertyName("node")>]
        Node: string
        [<JsonPropertyName("primary")>]
        Primary: bool
        [<JsonPropertyName("state")>]
        State: string
    }

    and SegmentsShardsSegment = {
        [<JsonPropertyName("num_committed_segments")>]
        NumCommittedSegments: float
        [<JsonPropertyName("routing")>]
        Routing: SegmentsShardSegmentRouting
        [<JsonPropertyName("num_search_segments")>]
        NumSearchSegments: float
        [<JsonPropertyName("segments")>]
        Segments: Map<string, SegmentsSegment>
    }

    and SegmentsIndexSegment = {
        [<JsonPropertyName("shards")>]
        Shards: Map<string, System.Text.Json.JsonElement>
    }

    and ShardStoresShardStoreStatusConverter() =
        inherit JsonConverter<ShardStoresShardStoreStatus>()

        override _.Write(writer: Utf8JsonWriter, value: ShardStoresShardStoreStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ShardStoresShardStoreStatus.Green -> "green"
                | ShardStoresShardStoreStatus.Yellow -> "yellow"
                | ShardStoresShardStoreStatus.Red -> "red"
                | ShardStoresShardStoreStatus.All -> "all"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "green" -> ShardStoresShardStoreStatus.Green
            | "yellow" -> ShardStoresShardStoreStatus.Yellow
            | "red" -> ShardStoresShardStoreStatus.Red
            | "all" -> ShardStoresShardStoreStatus.All
            | s -> failwith $"Unknown ShardStoresShardStoreStatus: {s}"

    and [<JsonConverter(typeof<ShardStoresShardStoreStatusConverter>)>]
        ShardStoresShardStoreStatus =
        | Green
        | Yellow
        | Red
        | All
        with
        override this.ToString() =
            match this with
            | Green -> "green"
            | Yellow -> "yellow"
            | Red -> "red"
            | All -> "all"

    and ShardStoresShardStoreAllocationConverter() =
        inherit JsonConverter<ShardStoresShardStoreAllocation>()

        override _.Write(writer: Utf8JsonWriter, value: ShardStoresShardStoreAllocation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ShardStoresShardStoreAllocation.Primary -> "primary"
                | ShardStoresShardStoreAllocation.Replica -> "replica"
                | ShardStoresShardStoreAllocation.Unused -> "unused"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "primary" -> ShardStoresShardStoreAllocation.Primary
            | "replica" -> ShardStoresShardStoreAllocation.Replica
            | "unused" -> ShardStoresShardStoreAllocation.Unused
            | s -> failwith $"Unknown ShardStoresShardStoreAllocation: {s}"

    and [<JsonConverter(typeof<ShardStoresShardStoreAllocationConverter>)>]
        ShardStoresShardStoreAllocation =
        | Primary
        | Replica
        | Unused
        with
        override this.ToString() =
            match this with
            | Primary -> "primary"
            | Replica -> "replica"
            | Unused -> "unused"

    and ShardStoresShardStoreException = {
        [<JsonPropertyName("reason")>]
        Reason: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and ShardStoresShardStore = {
        [<JsonPropertyName("allocation")>]
        Allocation: ShardStoresShardStoreAllocation
        [<JsonPropertyName("allocation_id")>]
        AllocationId: Id option
        [<JsonPropertyName("store_exception")>]
        StoreException: ShardStoresShardStoreException option
    }

    and ShardStoresShardStoreWrapper = {
        [<JsonPropertyName("stores")>]
        Stores: ShardStoresShardStore array
    }

    and ShardStoresIndicesShardStores = {
        [<JsonPropertyName("shards")>]
        Shards: Map<string, ShardStoresShardStoreWrapper>
    }

    and SimulateTemplateOverlapping = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("index_patterns")>]
        IndexPatterns: string array
    }

    and SimulateTemplateTemplate = {
        [<JsonPropertyName("aliases")>]
        Aliases: Map<string, TypesAlias>
        [<JsonPropertyName("mappings")>]
        Mappings: MappingTypeMapping
        [<JsonPropertyName("settings")>]
        Settings: TypesIndexSettings
    }

    and CommonStatsFlagConverter() =
        inherit JsonConverter<CommonStatsFlag>()

        override _.Write(writer: Utf8JsonWriter, value: CommonStatsFlag, _options: JsonSerializerOptions) =
            let str =
                match value with
                | CommonStatsFlag.All -> "_all"
                | CommonStatsFlag.Store -> "store"
                | CommonStatsFlag.Indexing -> "indexing"
                | CommonStatsFlag.Get -> "get"
                | CommonStatsFlag.Search -> "search"
                | CommonStatsFlag.Merge -> "merge"
                | CommonStatsFlag.Flush -> "flush"
                | CommonStatsFlag.Refresh -> "refresh"
                | CommonStatsFlag.QueryCache -> "query_cache"
                | CommonStatsFlag.Fielddata -> "fielddata"
                | CommonStatsFlag.Docs -> "docs"
                | CommonStatsFlag.Warmer -> "warmer"
                | CommonStatsFlag.Completion -> "completion"
                | CommonStatsFlag.Segments -> "segments"
                | CommonStatsFlag.Translog -> "translog"
                | CommonStatsFlag.RequestCache -> "request_cache"
                | CommonStatsFlag.Recovery -> "recovery"
                | CommonStatsFlag.Bulk -> "bulk"
                | CommonStatsFlag.ShardStats -> "shard_stats"
                | CommonStatsFlag.Mappings -> "mappings"
                | CommonStatsFlag.DenseVector -> "dense_vector"
                | CommonStatsFlag.SparseVector -> "sparse_vector"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> CommonStatsFlag.All
            | "store" -> CommonStatsFlag.Store
            | "indexing" -> CommonStatsFlag.Indexing
            | "get" -> CommonStatsFlag.Get
            | "search" -> CommonStatsFlag.Search
            | "merge" -> CommonStatsFlag.Merge
            | "flush" -> CommonStatsFlag.Flush
            | "refresh" -> CommonStatsFlag.Refresh
            | "query_cache" -> CommonStatsFlag.QueryCache
            | "fielddata" -> CommonStatsFlag.Fielddata
            | "docs" -> CommonStatsFlag.Docs
            | "warmer" -> CommonStatsFlag.Warmer
            | "completion" -> CommonStatsFlag.Completion
            | "segments" -> CommonStatsFlag.Segments
            | "translog" -> CommonStatsFlag.Translog
            | "request_cache" -> CommonStatsFlag.RequestCache
            | "recovery" -> CommonStatsFlag.Recovery
            | "bulk" -> CommonStatsFlag.Bulk
            | "shard_stats" -> CommonStatsFlag.ShardStats
            | "mappings" -> CommonStatsFlag.Mappings
            | "dense_vector" -> CommonStatsFlag.DenseVector
            | "sparse_vector" -> CommonStatsFlag.SparseVector
            | s -> failwith $"Unknown CommonStatsFlag: {s}"

    and [<JsonConverter(typeof<CommonStatsFlagConverter>)>]
        CommonStatsFlag =
        | All
        | Store
        | Indexing
        | Get
        | Search
        | Merge
        | Flush
        | Refresh
        | QueryCache
        | Fielddata
        | Docs
        | Warmer
        | Completion
        | Segments
        | Translog
        | RequestCache
        | Recovery
        | Bulk
        | ShardStats
        | Mappings
        | DenseVector
        | SparseVector
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | Store -> "store"
            | Indexing -> "indexing"
            | Get -> "get"
            | Search -> "search"
            | Merge -> "merge"
            | Flush -> "flush"
            | Refresh -> "refresh"
            | QueryCache -> "query_cache"
            | Fielddata -> "fielddata"
            | Docs -> "docs"
            | Warmer -> "warmer"
            | Completion -> "completion"
            | Segments -> "segments"
            | Translog -> "translog"
            | RequestCache -> "request_cache"
            | Recovery -> "recovery"
            | Bulk -> "bulk"
            | ShardStats -> "shard_stats"
            | Mappings -> "mappings"
            | DenseVector -> "dense_vector"
            | SparseVector -> "sparse_vector"

    and CommonStatsFlags = obj

    and StatsIndexMetadataStateConverter() =
        inherit JsonConverter<StatsIndexMetadataState>()

        override _.Write(writer: Utf8JsonWriter, value: StatsIndexMetadataState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StatsIndexMetadataState.Open -> "open"
                | StatsIndexMetadataState.Close -> "close"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "open" -> StatsIndexMetadataState.Open
            | "close" -> StatsIndexMetadataState.Close
            | s -> failwith $"Unknown StatsIndexMetadataState: {s}"

    and [<JsonConverter(typeof<StatsIndexMetadataStateConverter>)>]
        StatsIndexMetadataState =
        | Open
        | Close
        with
        override this.ToString() =
            match this with
            | Open -> "open"
            | Close -> "close"

    and BulkStats = {
        [<JsonPropertyName("total_operations")>]
        TotalOperations: float
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_size")>]
        TotalSize: ByteSize option
        [<JsonPropertyName("total_size_in_bytes")>]
        TotalSizeInBytes: float
        [<JsonPropertyName("avg_time")>]
        AvgTime: Duration option
        [<JsonPropertyName("avg_time_in_millis")>]
        AvgTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("avg_size")>]
        AvgSize: ByteSize option
        [<JsonPropertyName("avg_size_in_bytes")>]
        AvgSizeInBytes: float
    }

    and FlushStats = {
        [<JsonPropertyName("periodic")>]
        Periodic: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and GetStats = {
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("exists_time")>]
        ExistsTime: Duration option
        [<JsonPropertyName("exists_time_in_millis")>]
        ExistsTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("exists_total")>]
        ExistsTotal: float
        [<JsonPropertyName("missing_time")>]
        MissingTime: Duration option
        [<JsonPropertyName("missing_time_in_millis")>]
        MissingTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("missing_total")>]
        MissingTotal: float
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total")>]
        Total: float
    }

    and IndexingStats = {
        [<JsonPropertyName("index_current")>]
        IndexCurrent: float
        [<JsonPropertyName("delete_current")>]
        DeleteCurrent: float
        [<JsonPropertyName("delete_time")>]
        DeleteTime: Duration option
        [<JsonPropertyName("delete_time_in_millis")>]
        DeleteTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("delete_total")>]
        DeleteTotal: float
        [<JsonPropertyName("is_throttled")>]
        IsThrottled: bool
        [<JsonPropertyName("noop_update_total")>]
        NoopUpdateTotal: float
        [<JsonPropertyName("throttle_time")>]
        ThrottleTime: Duration option
        [<JsonPropertyName("throttle_time_in_millis")>]
        ThrottleTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("index_time")>]
        IndexTime: Duration option
        [<JsonPropertyName("index_time_in_millis")>]
        IndexTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("index_total")>]
        IndexTotal: float
        [<JsonPropertyName("index_failed")>]
        IndexFailed: float
        [<JsonPropertyName("types")>]
        Types: Map<string, IndexingStats> option
        [<JsonPropertyName("write_load")>]
        WriteLoad: float option
        [<JsonPropertyName("recent_write_load")>]
        RecentWriteLoad: float option
        [<JsonPropertyName("peak_write_load")>]
        PeakWriteLoad: float option
    }

    and MergesStats = {
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("current_docs")>]
        CurrentDocs: float
        [<JsonPropertyName("current_size")>]
        CurrentSize: string option
        [<JsonPropertyName("current_size_in_bytes")>]
        CurrentSizeInBytes: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("total_auto_throttle")>]
        TotalAutoThrottle: string option
        [<JsonPropertyName("total_auto_throttle_in_bytes")>]
        TotalAutoThrottleInBytes: float
        [<JsonPropertyName("total_docs")>]
        TotalDocs: float
        [<JsonPropertyName("total_size")>]
        TotalSize: string option
        [<JsonPropertyName("total_size_in_bytes")>]
        TotalSizeInBytes: float
        [<JsonPropertyName("total_stopped_time")>]
        TotalStoppedTime: Duration option
        [<JsonPropertyName("total_stopped_time_in_millis")>]
        TotalStoppedTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_throttled_time")>]
        TotalThrottledTime: Duration option
        [<JsonPropertyName("total_throttled_time_in_millis")>]
        TotalThrottledTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RecoveryStats = {
        [<JsonPropertyName("current_as_source")>]
        CurrentAsSource: float
        [<JsonPropertyName("current_as_target")>]
        CurrentAsTarget: float
        [<JsonPropertyName("throttle_time")>]
        ThrottleTime: Duration option
        [<JsonPropertyName("throttle_time_in_millis")>]
        ThrottleTimeInMillis: DurationValueUnitMillis
    }

    and RefreshStats = {
        [<JsonPropertyName("external_total")>]
        ExternalTotal: float
        [<JsonPropertyName("external_total_time_in_millis")>]
        ExternalTotalTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("listeners")>]
        Listeners: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and RequestCacheStats = {
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("hit_count")>]
        HitCount: float
        [<JsonPropertyName("memory_size")>]
        MemorySize: string option
        [<JsonPropertyName("memory_size_in_bytes")>]
        MemorySizeInBytes: float
        [<JsonPropertyName("miss_count")>]
        MissCount: float
    }

    and SearchStats = {
        [<JsonPropertyName("fetch_current")>]
        FetchCurrent: float
        [<JsonPropertyName("fetch_time")>]
        FetchTime: Duration option
        [<JsonPropertyName("fetch_time_in_millis")>]
        FetchTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("fetch_total")>]
        FetchTotal: float
        [<JsonPropertyName("open_contexts")>]
        OpenContexts: float option
        [<JsonPropertyName("query_current")>]
        QueryCurrent: float
        [<JsonPropertyName("query_time")>]
        QueryTime: Duration option
        [<JsonPropertyName("query_time_in_millis")>]
        QueryTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("query_total")>]
        QueryTotal: float
        [<JsonPropertyName("scroll_current")>]
        ScrollCurrent: float
        [<JsonPropertyName("scroll_time")>]
        ScrollTime: Duration option
        [<JsonPropertyName("scroll_time_in_millis")>]
        ScrollTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("scroll_total")>]
        ScrollTotal: float
        [<JsonPropertyName("suggest_current")>]
        SuggestCurrent: float
        [<JsonPropertyName("suggest_time")>]
        SuggestTime: Duration option
        [<JsonPropertyName("suggest_time_in_millis")>]
        SuggestTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("suggest_total")>]
        SuggestTotal: float
        [<JsonPropertyName("recent_search_load")>]
        RecentSearchLoad: float option
        [<JsonPropertyName("groups")>]
        Groups: Map<string, SearchStats> option
    }

    and TranslogStats = {
        [<JsonPropertyName("earliest_last_modified_age")>]
        EarliestLastModifiedAge: float
        [<JsonPropertyName("operations")>]
        Operations: float
        [<JsonPropertyName("size")>]
        Size: string option
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("uncommitted_operations")>]
        UncommittedOperations: float
        [<JsonPropertyName("uncommitted_size")>]
        UncommittedSize: string option
        [<JsonPropertyName("uncommitted_size_in_bytes")>]
        UncommittedSizeInBytes: float
    }

    and WarmerStats = {
        [<JsonPropertyName("current")>]
        Current: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("total_time")>]
        TotalTime: Duration option
        [<JsonPropertyName("total_time_in_millis")>]
        TotalTimeInMillis: DurationValueUnitMillis
    }

    and StatsShardsTotalStats = {
        [<JsonPropertyName("total_count")>]
        TotalCount: float
    }

    and StatsIndexStats = {
        [<JsonPropertyName("completion")>]
        Completion: CompletionStats option
        [<JsonPropertyName("docs")>]
        Docs: DocStats option
        [<JsonPropertyName("fielddata")>]
        Fielddata: FielddataStats option
        [<JsonPropertyName("flush")>]
        Flush: FlushStats option
        [<JsonPropertyName("get")>]
        Get: GetStats option
        [<JsonPropertyName("indexing")>]
        Indexing: IndexingStats option
        [<JsonPropertyName("indices")>]
        Indices: StatsIndicesStats option
        [<JsonPropertyName("merges")>]
        Merges: MergesStats option
        [<JsonPropertyName("query_cache")>]
        QueryCache: QueryCacheStats option
        [<JsonPropertyName("recovery")>]
        Recovery: RecoveryStats option
        [<JsonPropertyName("refresh")>]
        Refresh: RefreshStats option
        [<JsonPropertyName("request_cache")>]
        RequestCache: RequestCacheStats option
        [<JsonPropertyName("search")>]
        Search: SearchStats option
        [<JsonPropertyName("segments")>]
        Segments: SegmentsStats option
        [<JsonPropertyName("store")>]
        Store: StoreStats option
        [<JsonPropertyName("translog")>]
        Translog: TranslogStats option
        [<JsonPropertyName("warmer")>]
        Warmer: WarmerStats option
        [<JsonPropertyName("bulk")>]
        Bulk: BulkStats option
        [<JsonPropertyName("shard_stats")>]
        ShardStats: StatsShardsTotalStats option
    }

    and StatsMappingStats = {
        [<JsonPropertyName("total_count")>]
        TotalCount: float
        [<JsonPropertyName("total_estimated_overhead")>]
        TotalEstimatedOverhead: ByteSize option
        [<JsonPropertyName("total_estimated_overhead_in_bytes")>]
        TotalEstimatedOverheadInBytes: float
    }

    and StatsShardCommit = {
        [<JsonPropertyName("generation")>]
        Generation: float
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("num_docs")>]
        NumDocs: float
        [<JsonPropertyName("user_data")>]
        UserData: Map<string, string>
    }

    and StatsShardPath = {
        [<JsonPropertyName("data_path")>]
        DataPath: string
        [<JsonPropertyName("is_custom_data_path")>]
        IsCustomDataPath: bool
        [<JsonPropertyName("state_path")>]
        StatePath: string
    }

    and StatsShardQueryCache = {
        [<JsonPropertyName("cache_count")>]
        CacheCount: float
        [<JsonPropertyName("cache_size")>]
        CacheSize: float
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("hit_count")>]
        HitCount: float
        [<JsonPropertyName("memory_size_in_bytes")>]
        MemorySizeInBytes: float
        [<JsonPropertyName("miss_count")>]
        MissCount: float
        [<JsonPropertyName("total_count")>]
        TotalCount: float
    }

    and StatsShardLease = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("retaining_seq_no")>]
        RetainingSeqNo: SequenceNumber
        [<JsonPropertyName("timestamp")>]
        Timestamp: float
        [<JsonPropertyName("source")>]
        Source: string
    }

    and StatsShardRetentionLeases = {
        [<JsonPropertyName("primary_term")>]
        PrimaryTerm: float
        [<JsonPropertyName("version")>]
        Version: VersionNumber
        [<JsonPropertyName("leases")>]
        Leases: StatsShardLease array
    }

    and StatsShardRoutingStateConverter() =
        inherit JsonConverter<StatsShardRoutingState>()

        override _.Write(writer: Utf8JsonWriter, value: StatsShardRoutingState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StatsShardRoutingState.UNASSIGNED -> "UNASSIGNED"
                | StatsShardRoutingState.INITIALIZING -> "INITIALIZING"
                | StatsShardRoutingState.STARTED -> "STARTED"
                | StatsShardRoutingState.RELOCATING -> "RELOCATING"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "UNASSIGNED" -> StatsShardRoutingState.UNASSIGNED
            | "INITIALIZING" -> StatsShardRoutingState.INITIALIZING
            | "STARTED" -> StatsShardRoutingState.STARTED
            | "RELOCATING" -> StatsShardRoutingState.RELOCATING
            | s -> failwith $"Unknown StatsShardRoutingState: {s}"

    and [<JsonConverter(typeof<StatsShardRoutingStateConverter>)>]
        StatsShardRoutingState =
        | UNASSIGNED
        | INITIALIZING
        | STARTED
        | RELOCATING
        with
        override this.ToString() =
            match this with
            | UNASSIGNED -> "UNASSIGNED"
            | INITIALIZING -> "INITIALIZING"
            | STARTED -> "STARTED"
            | RELOCATING -> "RELOCATING"

    and StatsShardRouting = {
        [<JsonPropertyName("node")>]
        Node: string
        [<JsonPropertyName("primary")>]
        Primary: bool
        [<JsonPropertyName("relocating_node")>]
        RelocatingNode: System.Text.Json.JsonElement option
        [<JsonPropertyName("state")>]
        State: StatsShardRoutingState
    }

    and StatsShardSequenceNumber = {
        [<JsonPropertyName("global_checkpoint")>]
        GlobalCheckpoint: float
        [<JsonPropertyName("local_checkpoint")>]
        LocalCheckpoint: float
        [<JsonPropertyName("max_seq_no")>]
        MaxSeqNo: SequenceNumber
    }

    and StatsShardStats = {
        [<JsonPropertyName("commit")>]
        Commit: StatsShardCommit option
        [<JsonPropertyName("completion")>]
        Completion: CompletionStats option
        [<JsonPropertyName("docs")>]
        Docs: DocStats option
        [<JsonPropertyName("fielddata")>]
        Fielddata: FielddataStats option
        [<JsonPropertyName("flush")>]
        Flush: FlushStats option
        [<JsonPropertyName("get")>]
        Get: GetStats option
        [<JsonPropertyName("indexing")>]
        Indexing: IndexingStats option
        [<JsonPropertyName("mappings")>]
        Mappings: StatsMappingStats option
        [<JsonPropertyName("merges")>]
        Merges: MergesStats option
        [<JsonPropertyName("shard_path")>]
        ShardPath: StatsShardPath option
        [<JsonPropertyName("query_cache")>]
        QueryCache: StatsShardQueryCache option
        [<JsonPropertyName("recovery")>]
        Recovery: RecoveryStats option
        [<JsonPropertyName("refresh")>]
        Refresh: RefreshStats option
        [<JsonPropertyName("request_cache")>]
        RequestCache: RequestCacheStats option
        [<JsonPropertyName("retention_leases")>]
        RetentionLeases: StatsShardRetentionLeases option
        [<JsonPropertyName("routing")>]
        Routing: StatsShardRouting option
        [<JsonPropertyName("search")>]
        Search: SearchStats option
        [<JsonPropertyName("segments")>]
        Segments: SegmentsStats option
        [<JsonPropertyName("seq_no")>]
        SeqNo: StatsShardSequenceNumber option
        [<JsonPropertyName("store")>]
        Store: StoreStats option
        [<JsonPropertyName("translog")>]
        Translog: TranslogStats option
        [<JsonPropertyName("warmer")>]
        Warmer: WarmerStats option
        [<JsonPropertyName("bulk")>]
        Bulk: BulkStats option
        [<JsonPropertyName("shards")>]
        Shards: Map<string, obj> option
        [<JsonPropertyName("shard_stats")>]
        ShardStats: StatsShardsTotalStats option
        [<JsonPropertyName("indices")>]
        Indices: StatsIndicesStats option
    }

    and StatsIndicesStats = {
        [<JsonPropertyName("primaries")>]
        Primaries: StatsIndexStats option
        [<JsonPropertyName("shards")>]
        Shards: Map<string, StatsShardStats array> option
        [<JsonPropertyName("total")>]
        Total: StatsIndexStats option
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("health")>]
        Health: HealthStatus option
        [<JsonPropertyName("status")>]
        Status: StatsIndexMetadataState option
    }

    and UpdateAliasesAddAction = {
        [<JsonPropertyName("alias")>]
        Alias: IndexAlias option
        [<JsonPropertyName("aliases")>]
        Aliases: System.Text.Json.JsonElement option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("index_routing")>]
        IndexRouting: Routing option
        [<JsonPropertyName("is_hidden")>]
        IsHidden: bool option
        [<JsonPropertyName("is_write_index")>]
        IsWriteIndex: bool option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("search_routing")>]
        SearchRouting: Routing option
        [<JsonPropertyName("must_exist")>]
        MustExist: bool option
    }

    and UpdateAliasesRemoveAction = {
        [<JsonPropertyName("alias")>]
        Alias: IndexAlias option
        [<JsonPropertyName("aliases")>]
        Aliases: System.Text.Json.JsonElement option
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("must_exist")>]
        MustExist: bool option
    }

    and UpdateAliasesRemoveIndexAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("must_exist")>]
        MustExist: bool option
    }

    and UpdateAliasesAction = {
        [<JsonPropertyName("add")>]
        Add: UpdateAliasesAddAction option
        [<JsonPropertyName("remove")>]
        Remove: UpdateAliasesRemoveAction option
        [<JsonPropertyName("remove_index")>]
        RemoveIndex: UpdateAliasesRemoveIndexAction option
    }

    and ValidateQueryIndicesValidationExplanation = {
        [<JsonPropertyName("error")>]
        Error: string option
        [<JsonPropertyName("explanation")>]
        Explanation: string option
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("valid")>]
        Valid: bool
    }

    /// <summary>
    /// The completion tool function definition.
    /// </summary>
    and TypesCompletionToolFunction = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("parameters")>]
        Parameters: obj option
        [<JsonPropertyName("strict")>]
        Strict: bool option
    }

    /// <summary>
    /// A list of tools that the model can call.
    /// </summary>
    and TypesCompletionTool = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("function")>]
        Function: TypesCompletionToolFunction
    }

    /// <summary>
    /// The tool choice function.
    /// </summary>
    and TypesCompletionToolChoiceFunction = {
        [<JsonPropertyName("name")>]
        Name: string
    }

    /// <summary>
    /// Controls which tool is called by the model.
    /// </summary>
    and TypesCompletionToolChoice = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("function")>]
        Function: TypesCompletionToolChoiceFunction
    }

    and TypesCompletionToolType = obj

    /// <summary>
    /// An object style representation of a single portion of a conversation.
    /// </summary>
    and TypesContentObject = {
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("type")>]
        Type: string
    }

    and TypesMessageContent = obj

    /// <summary>
    /// The function that the model called.
    /// </summary>
    and TypesToolCallFunction = {
        [<JsonPropertyName("arguments")>]
        Arguments: string
        [<JsonPropertyName("name")>]
        Name: string
    }

    /// <summary>
    /// A tool call generated by the model.
    /// </summary>
    and TypesToolCall = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("function")>]
        Function: TypesToolCallFunction
        [<JsonPropertyName("type")>]
        Type: string
    }

    /// <summary>
    /// An object representing part of the conversation.
    /// </summary>
    and TypesMessage = {
        [<JsonPropertyName("content")>]
        Content: TypesMessageContent option
        [<JsonPropertyName("role")>]
        Role: string
        [<JsonPropertyName("tool_call_id")>]
        ToolCallId: Id option
        [<JsonPropertyName("tool_calls")>]
        ToolCalls: TypesToolCall array option
    }

    and TypesRequestChatCompletion = {
        [<JsonPropertyName("messages")>]
        Messages: TypesMessage array
        [<JsonPropertyName("model")>]
        Model: string option
        [<JsonPropertyName("max_completion_tokens")>]
        MaxCompletionTokens: float option
        [<JsonPropertyName("stop")>]
        Stop: string array option
        [<JsonPropertyName("temperature")>]
        Temperature: float option
        [<JsonPropertyName("tool_choice")>]
        ToolChoice: TypesCompletionToolType option
        [<JsonPropertyName("tools")>]
        Tools: TypesCompletionTool array option
        [<JsonPropertyName("top_p")>]
        TopP: float option
    }

    and StreamResult = obj

    and TypesTaskSettings = obj

    /// <summary>
    /// The completion result object
    /// </summary>
    and TypesCompletionResult = {
        [<JsonPropertyName("result")>]
        Result: string
    }

    /// <summary>
    /// Defines the completion result.
    /// </summary>
    and TypesCompletionInferenceResult = {
        [<JsonPropertyName("completion")>]
        Completion: TypesCompletionResult array
    }

    and TypesTaskTypeConverter() =
        inherit JsonConverter<TypesTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskType.SparseEmbedding -> "sparse_embedding"
                | TypesTaskType.TextEmbedding -> "text_embedding"
                | TypesTaskType.Rerank -> "rerank"
                | TypesTaskType.Completion -> "completion"
                | TypesTaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sparse_embedding" -> TypesTaskType.SparseEmbedding
            | "text_embedding" -> TypesTaskType.TextEmbedding
            | "rerank" -> TypesTaskType.Rerank
            | "completion" -> TypesTaskType.Completion
            | "chat_completion" -> TypesTaskType.ChatCompletion
            | s -> failwith $"Unknown TypesTaskType: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeConverter>)>]
        TypesTaskType =
        | SparseEmbedding
        | TextEmbedding
        | Rerank
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | SparseEmbedding -> "sparse_embedding"
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    /// <summary>
    /// Acknowledged response. For dry_run, contains the list of pipelines which reference the inference endpoint
    /// </summary>
    and TypesDeleteInferenceEndpointResult = {
        [<JsonPropertyName("acknowledged")>]
        Acknowledged: bool
        [<JsonPropertyName("pipelines")>]
        Pipelines: string array
    }

    /// <summary>
    /// Chunking configuration object
    /// </summary>
    and TypesInferenceChunkingSettings = {
        [<JsonPropertyName("max_chunk_size")>]
        MaxChunkSize: float option
        [<JsonPropertyName("overlap")>]
        Overlap: float option
        [<JsonPropertyName("sentence_overlap")>]
        SentenceOverlap: float option
        [<JsonPropertyName("separator_group")>]
        SeparatorGroup: string option
        [<JsonPropertyName("separators")>]
        Separators: string array option
        [<JsonPropertyName("strategy")>]
        Strategy: string option
    }

    and TypesServiceSettings = obj

    /// <summary>
    /// Configuration options when storing the inference endpoint
    /// </summary>
    and TypesInferenceEndpoint = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
    }

    /// <summary>
    /// Represents an inference endpoint as returned by the GET API
    /// </summary>
    and TypesInferenceEndpointInfo = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskType
    }

    /// <summary>
    /// The rerank result object representing a single ranked document
    /// id: the original index of the document in the request
    /// relevance_score: the relevance_score of the document relative to the query
    /// </summary>
    and TypesRankedDocument = {
        [<JsonPropertyName("index")>]
        Index: float
        [<JsonPropertyName("relevance_score")>]
        RelevanceScore: float
        [<JsonPropertyName("text")>]
        Text: string option
    }

    /// <summary>
    /// Sparse Embedding tokens are represented as a dictionary
    /// of string to double.
    /// </summary>
    and TypesSparseVector = Map<string, float>

    and TypesSparseEmbeddingResult = {
        [<JsonPropertyName("embedding")>]
        Embedding: TypesSparseVector
    }

    /// <summary>
    /// Text Embedding results containing bytes are represented as Dense
    /// Vectors of bytes.
    /// </summary>
    and TypesDenseByteVector = Byte array

    /// <summary>
    /// The text embedding result object for byte representation
    /// </summary>
    and TypesTextEmbeddingByteResult = {
        [<JsonPropertyName("embedding")>]
        Embedding: TypesDenseByteVector
    }

    /// <summary>
    /// Text Embedding results are represented as Dense Vectors
    /// of floats.
    /// </summary>
    and TypesDenseVector = float array

    /// <summary>
    /// The text embedding result object
    /// </summary>
    and TypesTextEmbeddingResult = {
        [<JsonPropertyName("embedding")>]
        Embedding: TypesDenseVector
    }

    /// <summary>
    /// InferenceResult is an aggregation of mutually exclusive variants
    /// </summary>
    and TypesInferenceResult = {
        [<JsonPropertyName("text_embedding_bytes")>]
        TextEmbeddingBytes: TypesTextEmbeddingByteResult array option
        [<JsonPropertyName("text_embedding_bits")>]
        TextEmbeddingBits: TypesTextEmbeddingByteResult array option
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: TypesTextEmbeddingResult array option
        [<JsonPropertyName("sparse_embedding")>]
        SparseEmbedding: TypesSparseEmbeddingResult array option
        [<JsonPropertyName("completion")>]
        Completion: TypesCompletionResult array option
        [<JsonPropertyName("rerank")>]
        Rerank: TypesRankedDocument array option
    }

    and TypesAi21TaskTypeConverter() =
        inherit JsonConverter<TypesAi21TaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAi21TaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAi21TaskType.Completion -> "completion"
                | TypesAi21TaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAi21TaskType.Completion
            | "chat_completion" -> TypesAi21TaskType.ChatCompletion
            | s -> failwith $"Unknown TypesAi21TaskType: {s}"

    and [<JsonConverter(typeof<TypesAi21TaskTypeConverter>)>]
        TypesAi21TaskType =
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesAi21ServiceTypeConverter() =
        inherit JsonConverter<TypesAi21ServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAi21ServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAi21ServiceType.Ai21 -> "ai21"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ai21" -> TypesAi21ServiceType.Ai21
            | s -> failwith $"Unknown TypesAi21ServiceType: {s}"

    and [<JsonConverter(typeof<TypesAi21ServiceTypeConverter>)>]
        TypesAi21ServiceType =
        | Ai21
        with
        override this.ToString() =
            match this with
            | Ai21 -> "ai21"

    /// <summary>
    /// This setting helps to minimize the number of rate limit errors returned from the service.
    /// </summary>
    and TypesRateLimitSetting = {
        [<JsonPropertyName("requests_per_minute")>]
        RequestsPerMinute: float option
    }

    and TypesAi21ServiceSettings = {
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("api_key")>]
        ApiKey: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesTaskTypeAi21Converter() =
        inherit JsonConverter<TypesTaskTypeAi21>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAi21, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAi21.Completion -> "completion"
                | TypesTaskTypeAi21.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesTaskTypeAi21.Completion
            | "chat_completion" -> TypesTaskTypeAi21.ChatCompletion
            | s -> failwith $"Unknown TypesTaskTypeAi21: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAi21Converter>)>]
        TypesTaskTypeAi21 =
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesInferenceEndpointInfoAi21 = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAi21
    }

    and TypesAlibabaCloudTaskTypeConverter() =
        inherit JsonConverter<TypesAlibabaCloudTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAlibabaCloudTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAlibabaCloudTaskType.Completion -> "completion"
                | TypesAlibabaCloudTaskType.Rerank -> "rerank"
                | TypesAlibabaCloudTaskType.SparseEmbedding -> "sparse_embedding"
                | TypesAlibabaCloudTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAlibabaCloudTaskType.Completion
            | "rerank" -> TypesAlibabaCloudTaskType.Rerank
            | "sparse_embedding" -> TypesAlibabaCloudTaskType.SparseEmbedding
            | "text_embedding" -> TypesAlibabaCloudTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesAlibabaCloudTaskType: {s}"

    and [<JsonConverter(typeof<TypesAlibabaCloudTaskTypeConverter>)>]
        TypesAlibabaCloudTaskType =
        | Completion
        | Rerank
        | SparseEmbedding
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | Rerank -> "rerank"
            | SparseEmbedding -> "sparse_embedding"
            | TextEmbedding -> "text_embedding"

    and TypesAlibabaCloudServiceTypeConverter() =
        inherit JsonConverter<TypesAlibabaCloudServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAlibabaCloudServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAlibabaCloudServiceType.AlibabacloudAiSearch -> "alibabacloud_ai_search"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "alibabacloud_ai_search" -> TypesAlibabaCloudServiceType.AlibabacloudAiSearch
            | s -> failwith $"Unknown TypesAlibabaCloudServiceType: {s}"

    and [<JsonConverter(typeof<TypesAlibabaCloudServiceTypeConverter>)>]
        TypesAlibabaCloudServiceType =
        | AlibabacloudAiSearch
        with
        override this.ToString() =
            match this with
            | AlibabacloudAiSearch -> "alibabacloud_ai_search"

    and TypesAlibabaCloudServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("host")>]
        Host: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("service_id")>]
        ServiceId: string
        [<JsonPropertyName("workspace")>]
        Workspace: string
    }

    and TypesAlibabaCloudTaskSettings = {
        [<JsonPropertyName("input_type")>]
        InputType: string option
        [<JsonPropertyName("return_token")>]
        ReturnToken: bool option
    }

    and TypesTaskTypeAlibabaCloudAIConverter() =
        inherit JsonConverter<TypesTaskTypeAlibabaCloudAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAlibabaCloudAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAlibabaCloudAI.TextEmbedding -> "text_embedding"
                | TypesTaskTypeAlibabaCloudAI.Rerank -> "rerank"
                | TypesTaskTypeAlibabaCloudAI.Completion -> "completion"
                | TypesTaskTypeAlibabaCloudAI.SparseEmbedding -> "sparse_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeAlibabaCloudAI.TextEmbedding
            | "rerank" -> TypesTaskTypeAlibabaCloudAI.Rerank
            | "completion" -> TypesTaskTypeAlibabaCloudAI.Completion
            | "sparse_embedding" -> TypesTaskTypeAlibabaCloudAI.SparseEmbedding
            | s -> failwith $"Unknown TypesTaskTypeAlibabaCloudAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAlibabaCloudAIConverter>)>]
        TypesTaskTypeAlibabaCloudAI =
        | TextEmbedding
        | Rerank
        | Completion
        | SparseEmbedding
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"
            | Completion -> "completion"
            | SparseEmbedding -> "sparse_embedding"

    and TypesInferenceEndpointInfoAlibabaCloudAI = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAlibabaCloudAI
    }

    and TypesAmazonBedrockTaskTypeConverter() =
        inherit JsonConverter<TypesAmazonBedrockTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAmazonBedrockTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAmazonBedrockTaskType.Completion -> "completion"
                | TypesAmazonBedrockTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAmazonBedrockTaskType.Completion
            | "text_embedding" -> TypesAmazonBedrockTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesAmazonBedrockTaskType: {s}"

    and [<JsonConverter(typeof<TypesAmazonBedrockTaskTypeConverter>)>]
        TypesAmazonBedrockTaskType =
        | Completion
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | TextEmbedding -> "text_embedding"

    and TypesAmazonBedrockServiceTypeConverter() =
        inherit JsonConverter<TypesAmazonBedrockServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAmazonBedrockServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAmazonBedrockServiceType.Amazonbedrock -> "amazonbedrock"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "amazonbedrock" -> TypesAmazonBedrockServiceType.Amazonbedrock
            | s -> failwith $"Unknown TypesAmazonBedrockServiceType: {s}"

    and [<JsonConverter(typeof<TypesAmazonBedrockServiceTypeConverter>)>]
        TypesAmazonBedrockServiceType =
        | Amazonbedrock
        with
        override this.ToString() =
            match this with
            | Amazonbedrock -> "amazonbedrock"

    and TypesAmazonBedrockServiceSettings = {
        [<JsonPropertyName("access_key")>]
        AccessKey: string
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("provider")>]
        Provider: string option
        [<JsonPropertyName("region")>]
        Region: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("secret_key")>]
        SecretKey: string
    }

    and TypesAmazonBedrockTaskSettings = {
        [<JsonPropertyName("max_new_tokens")>]
        MaxNewTokens: float option
        [<JsonPropertyName("temperature")>]
        Temperature: float option
        [<JsonPropertyName("top_k")>]
        TopK: float option
        [<JsonPropertyName("top_p")>]
        TopP: float option
    }

    and TypesTaskTypeAmazonBedrockConverter() =
        inherit JsonConverter<TypesTaskTypeAmazonBedrock>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAmazonBedrock, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAmazonBedrock.TextEmbedding -> "text_embedding"
                | TypesTaskTypeAmazonBedrock.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeAmazonBedrock.TextEmbedding
            | "completion" -> TypesTaskTypeAmazonBedrock.Completion
            | s -> failwith $"Unknown TypesTaskTypeAmazonBedrock: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAmazonBedrockConverter>)>]
        TypesTaskTypeAmazonBedrock =
        | TextEmbedding
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoAmazonBedrock = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAmazonBedrock
    }

    and TypesTaskTypeAmazonSageMakerConverter() =
        inherit JsonConverter<TypesTaskTypeAmazonSageMaker>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAmazonSageMaker, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAmazonSageMaker.TextEmbedding -> "text_embedding"
                | TypesTaskTypeAmazonSageMaker.Completion -> "completion"
                | TypesTaskTypeAmazonSageMaker.ChatCompletion -> "chat_completion"
                | TypesTaskTypeAmazonSageMaker.SparseEmbedding -> "sparse_embedding"
                | TypesTaskTypeAmazonSageMaker.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeAmazonSageMaker.TextEmbedding
            | "completion" -> TypesTaskTypeAmazonSageMaker.Completion
            | "chat_completion" -> TypesTaskTypeAmazonSageMaker.ChatCompletion
            | "sparse_embedding" -> TypesTaskTypeAmazonSageMaker.SparseEmbedding
            | "rerank" -> TypesTaskTypeAmazonSageMaker.Rerank
            | s -> failwith $"Unknown TypesTaskTypeAmazonSageMaker: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAmazonSageMakerConverter>)>]
        TypesTaskTypeAmazonSageMaker =
        | TextEmbedding
        | Completion
        | ChatCompletion
        | SparseEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"
            | SparseEmbedding -> "sparse_embedding"
            | Rerank -> "rerank"

    and TypesAmazonSageMakerServiceTypeConverter() =
        inherit JsonConverter<TypesAmazonSageMakerServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAmazonSageMakerServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAmazonSageMakerServiceType.AmazonSagemaker -> "amazon_sagemaker"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "amazon_sagemaker" -> TypesAmazonSageMakerServiceType.AmazonSagemaker
            | s -> failwith $"Unknown TypesAmazonSageMakerServiceType: {s}"

    and [<JsonConverter(typeof<TypesAmazonSageMakerServiceTypeConverter>)>]
        TypesAmazonSageMakerServiceType =
        | AmazonSagemaker
        with
        override this.ToString() =
            match this with
            | AmazonSagemaker -> "amazon_sagemaker"

    and TypesAmazonSageMakerApiConverter() =
        inherit JsonConverter<TypesAmazonSageMakerApi>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAmazonSageMakerApi, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAmazonSageMakerApi.Openai -> "openai"
                | TypesAmazonSageMakerApi.Elastic -> "elastic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "openai" -> TypesAmazonSageMakerApi.Openai
            | "elastic" -> TypesAmazonSageMakerApi.Elastic
            | s -> failwith $"Unknown TypesAmazonSageMakerApi: {s}"

    and [<JsonConverter(typeof<TypesAmazonSageMakerApiConverter>)>]
        TypesAmazonSageMakerApi =
        | Openai
        | Elastic
        with
        override this.ToString() =
            match this with
            | Openai -> "openai"
            | Elastic -> "elastic"

    and TypesAmazonSageMakerServiceSettings = {
        [<JsonPropertyName("access_key")>]
        AccessKey: string
        [<JsonPropertyName("endpoint_name")>]
        EndpointName: string
        [<JsonPropertyName("api")>]
        Api: TypesAmazonSageMakerApi
        [<JsonPropertyName("region")>]
        Region: string
        [<JsonPropertyName("secret_key")>]
        SecretKey: string
        [<JsonPropertyName("target_model")>]
        TargetModel: string option
        [<JsonPropertyName("target_container_hostname")>]
        TargetContainerHostname: string option
        [<JsonPropertyName("inference_component_name")>]
        InferenceComponentName: string option
        [<JsonPropertyName("batch_size")>]
        BatchSize: float option
        [<JsonPropertyName("dimensions")>]
        Dimensions: float option
    }

    and TypesAmazonSageMakerTaskSettings = {
        [<JsonPropertyName("custom_attributes")>]
        CustomAttributes: string option
        [<JsonPropertyName("enable_explanations")>]
        EnableExplanations: string option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string option
        [<JsonPropertyName("session_id")>]
        SessionId: string option
        [<JsonPropertyName("target_variant")>]
        TargetVariant: string option
    }

    and TypesInferenceEndpointInfoAmazonSageMaker = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAmazonSageMaker
    }

    and TypesAnthropicTaskTypeConverter() =
        inherit JsonConverter<TypesAnthropicTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAnthropicTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAnthropicTaskType.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAnthropicTaskType.Completion
            | s -> failwith $"Unknown TypesAnthropicTaskType: {s}"

    and [<JsonConverter(typeof<TypesAnthropicTaskTypeConverter>)>]
        TypesAnthropicTaskType =
        | Completion
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"

    and TypesAnthropicServiceTypeConverter() =
        inherit JsonConverter<TypesAnthropicServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAnthropicServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAnthropicServiceType.Anthropic -> "anthropic"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "anthropic" -> TypesAnthropicServiceType.Anthropic
            | s -> failwith $"Unknown TypesAnthropicServiceType: {s}"

    and [<JsonConverter(typeof<TypesAnthropicServiceTypeConverter>)>]
        TypesAnthropicServiceType =
        | Anthropic
        with
        override this.ToString() =
            match this with
            | Anthropic -> "anthropic"

    and TypesAnthropicServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesAnthropicTaskSettings = {
        [<JsonPropertyName("max_tokens")>]
        MaxTokens: float
        [<JsonPropertyName("temperature")>]
        Temperature: float option
        [<JsonPropertyName("top_k")>]
        TopK: float option
        [<JsonPropertyName("top_p")>]
        TopP: float option
    }

    and TypesTaskTypeAnthropicConverter() =
        inherit JsonConverter<TypesTaskTypeAnthropic>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAnthropic, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAnthropic.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesTaskTypeAnthropic.Completion
            | s -> failwith $"Unknown TypesTaskTypeAnthropic: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAnthropicConverter>)>]
        TypesTaskTypeAnthropic =
        | Completion
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"

    and TypesInferenceEndpointInfoAnthropic = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAnthropic
    }

    and TypesAzureAiStudioTaskTypeConverter() =
        inherit JsonConverter<TypesAzureAiStudioTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAzureAiStudioTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAzureAiStudioTaskType.Completion -> "completion"
                | TypesAzureAiStudioTaskType.Rerank -> "rerank"
                | TypesAzureAiStudioTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAzureAiStudioTaskType.Completion
            | "rerank" -> TypesAzureAiStudioTaskType.Rerank
            | "text_embedding" -> TypesAzureAiStudioTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesAzureAiStudioTaskType: {s}"

    and [<JsonConverter(typeof<TypesAzureAiStudioTaskTypeConverter>)>]
        TypesAzureAiStudioTaskType =
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesAzureAiStudioServiceTypeConverter() =
        inherit JsonConverter<TypesAzureAiStudioServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAzureAiStudioServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAzureAiStudioServiceType.Azureaistudio -> "azureaistudio"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "azureaistudio" -> TypesAzureAiStudioServiceType.Azureaistudio
            | s -> failwith $"Unknown TypesAzureAiStudioServiceType: {s}"

    and [<JsonConverter(typeof<TypesAzureAiStudioServiceTypeConverter>)>]
        TypesAzureAiStudioServiceType =
        | Azureaistudio
        with
        override this.ToString() =
            match this with
            | Azureaistudio -> "azureaistudio"

    and TypesAzureAiStudioServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("endpoint_type")>]
        EndpointType: string
        [<JsonPropertyName("target")>]
        Target: string
        [<JsonPropertyName("provider")>]
        Provider: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesAzureAiStudioTaskSettings = {
        [<JsonPropertyName("do_sample")>]
        DoSample: float option
        [<JsonPropertyName("max_new_tokens")>]
        MaxNewTokens: float option
        [<JsonPropertyName("temperature")>]
        Temperature: float option
        [<JsonPropertyName("top_p")>]
        TopP: float option
        [<JsonPropertyName("user")>]
        User: string option
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_n")>]
        TopN: float option
    }

    and TypesTaskTypeAzureAIStudioConverter() =
        inherit JsonConverter<TypesTaskTypeAzureAIStudio>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAzureAIStudio, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAzureAIStudio.TextEmbedding -> "text_embedding"
                | TypesTaskTypeAzureAIStudio.Completion -> "completion"
                | TypesTaskTypeAzureAIStudio.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeAzureAIStudio.TextEmbedding
            | "completion" -> TypesTaskTypeAzureAIStudio.Completion
            | "rerank" -> TypesTaskTypeAzureAIStudio.Rerank
            | s -> failwith $"Unknown TypesTaskTypeAzureAIStudio: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAzureAIStudioConverter>)>]
        TypesTaskTypeAzureAIStudio =
        | TextEmbedding
        | Completion
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoAzureAIStudio = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAzureAIStudio
    }

    and TypesAzureOpenAITaskTypeConverter() =
        inherit JsonConverter<TypesAzureOpenAITaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAzureOpenAITaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAzureOpenAITaskType.Completion -> "completion"
                | TypesAzureOpenAITaskType.ChatCompletion -> "chat_completion"
                | TypesAzureOpenAITaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesAzureOpenAITaskType.Completion
            | "chat_completion" -> TypesAzureOpenAITaskType.ChatCompletion
            | "text_embedding" -> TypesAzureOpenAITaskType.TextEmbedding
            | s -> failwith $"Unknown TypesAzureOpenAITaskType: {s}"

    and [<JsonConverter(typeof<TypesAzureOpenAITaskTypeConverter>)>]
        TypesAzureOpenAITaskType =
        | Completion
        | ChatCompletion
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"
            | TextEmbedding -> "text_embedding"

    and TypesAzureOpenAIServiceTypeConverter() =
        inherit JsonConverter<TypesAzureOpenAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAzureOpenAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAzureOpenAIServiceType.Azureopenai -> "azureopenai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "azureopenai" -> TypesAzureOpenAIServiceType.Azureopenai
            | s -> failwith $"Unknown TypesAzureOpenAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesAzureOpenAIServiceTypeConverter>)>]
        TypesAzureOpenAIServiceType =
        | Azureopenai
        with
        override this.ToString() =
            match this with
            | Azureopenai -> "azureopenai"

    and TypesAzureOpenAIServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string option
        [<JsonPropertyName("api_version")>]
        ApiVersion: string
        [<JsonPropertyName("deployment_id")>]
        DeploymentId: string
        [<JsonPropertyName("entra_id")>]
        EntraId: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("resource_name")>]
        ResourceName: string
    }

    and TypesAzureOpenAITaskSettings = {
        [<JsonPropertyName("user")>]
        User: string option
    }

    and TypesTaskTypeAzureOpenAIConverter() =
        inherit JsonConverter<TypesTaskTypeAzureOpenAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeAzureOpenAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeAzureOpenAI.TextEmbedding -> "text_embedding"
                | TypesTaskTypeAzureOpenAI.Completion -> "completion"
                | TypesTaskTypeAzureOpenAI.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeAzureOpenAI.TextEmbedding
            | "completion" -> TypesTaskTypeAzureOpenAI.Completion
            | "chat_completion" -> TypesTaskTypeAzureOpenAI.ChatCompletion
            | s -> failwith $"Unknown TypesTaskTypeAzureOpenAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeAzureOpenAIConverter>)>]
        TypesTaskTypeAzureOpenAI =
        | TextEmbedding
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesInferenceEndpointInfoAzureOpenAI = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeAzureOpenAI
    }

    and TypesCohereTaskTypeConverter() =
        inherit JsonConverter<TypesCohereTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereTaskType.Completion -> "completion"
                | TypesCohereTaskType.Rerank -> "rerank"
                | TypesCohereTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesCohereTaskType.Completion
            | "rerank" -> TypesCohereTaskType.Rerank
            | "text_embedding" -> TypesCohereTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesCohereTaskType: {s}"

    and [<JsonConverter(typeof<TypesCohereTaskTypeConverter>)>]
        TypesCohereTaskType =
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesCohereServiceTypeConverter() =
        inherit JsonConverter<TypesCohereServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereServiceType.Cohere -> "cohere"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cohere" -> TypesCohereServiceType.Cohere
            | s -> failwith $"Unknown TypesCohereServiceType: {s}"

    and [<JsonConverter(typeof<TypesCohereServiceTypeConverter>)>]
        TypesCohereServiceType =
        | Cohere
        with
        override this.ToString() =
            match this with
            | Cohere -> "cohere"

    and TypesCohereEmbeddingTypeConverter() =
        inherit JsonConverter<TypesCohereEmbeddingType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereEmbeddingType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereEmbeddingType.Binary -> "binary"
                | TypesCohereEmbeddingType.Bit -> "bit"
                | TypesCohereEmbeddingType.Byte -> "byte"
                | TypesCohereEmbeddingType.Float -> "float"
                | TypesCohereEmbeddingType.Int8 -> "int8"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "binary" -> TypesCohereEmbeddingType.Binary
            | "bit" -> TypesCohereEmbeddingType.Bit
            | "byte" -> TypesCohereEmbeddingType.Byte
            | "float" -> TypesCohereEmbeddingType.Float
            | "int8" -> TypesCohereEmbeddingType.Int8
            | s -> failwith $"Unknown TypesCohereEmbeddingType: {s}"

    and [<JsonConverter(typeof<TypesCohereEmbeddingTypeConverter>)>]
        TypesCohereEmbeddingType =
        | Binary
        | Bit
        | Byte
        | Float
        | Int8
        with
        override this.ToString() =
            match this with
            | Binary -> "binary"
            | Bit -> "bit"
            | Byte -> "byte"
            | Float -> "float"
            | Int8 -> "int8"

    and TypesCohereSimilarityTypeConverter() =
        inherit JsonConverter<TypesCohereSimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereSimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereSimilarityType.Cosine -> "cosine"
                | TypesCohereSimilarityType.DotProduct -> "dot_product"
                | TypesCohereSimilarityType.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> TypesCohereSimilarityType.Cosine
            | "dot_product" -> TypesCohereSimilarityType.DotProduct
            | "l2_norm" -> TypesCohereSimilarityType.L2Norm
            | s -> failwith $"Unknown TypesCohereSimilarityType: {s}"

    and [<JsonConverter(typeof<TypesCohereSimilarityTypeConverter>)>]
        TypesCohereSimilarityType =
        | Cosine
        | DotProduct
        | L2Norm
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"

    and TypesCohereServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("embedding_type")>]
        EmbeddingType: TypesCohereEmbeddingType option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("similarity")>]
        Similarity: TypesCohereSimilarityType option
    }

    and TypesCohereInputTypeConverter() =
        inherit JsonConverter<TypesCohereInputType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereInputType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereInputType.Classification -> "classification"
                | TypesCohereInputType.Clustering -> "clustering"
                | TypesCohereInputType.Ingest -> "ingest"
                | TypesCohereInputType.Search -> "search"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "classification" -> TypesCohereInputType.Classification
            | "clustering" -> TypesCohereInputType.Clustering
            | "ingest" -> TypesCohereInputType.Ingest
            | "search" -> TypesCohereInputType.Search
            | s -> failwith $"Unknown TypesCohereInputType: {s}"

    and [<JsonConverter(typeof<TypesCohereInputTypeConverter>)>]
        TypesCohereInputType =
        | Classification
        | Clustering
        | Ingest
        | Search
        with
        override this.ToString() =
            match this with
            | Classification -> "classification"
            | Clustering -> "clustering"
            | Ingest -> "ingest"
            | Search -> "search"

    and TypesCohereTruncateTypeConverter() =
        inherit JsonConverter<TypesCohereTruncateType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCohereTruncateType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCohereTruncateType.END -> "END"
                | TypesCohereTruncateType.NONE -> "NONE"
                | TypesCohereTruncateType.START -> "START"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "END" -> TypesCohereTruncateType.END
            | "NONE" -> TypesCohereTruncateType.NONE
            | "START" -> TypesCohereTruncateType.START
            | s -> failwith $"Unknown TypesCohereTruncateType: {s}"

    and [<JsonConverter(typeof<TypesCohereTruncateTypeConverter>)>]
        TypesCohereTruncateType =
        | END
        | NONE
        | START
        with
        override this.ToString() =
            match this with
            | END -> "END"
            | NONE -> "NONE"
            | START -> "START"

    and TypesCohereTaskSettings = {
        [<JsonPropertyName("input_type")>]
        InputType: TypesCohereInputType
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_n")>]
        TopN: float option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesCohereTruncateType option
    }

    and TypesTaskTypeCohereConverter() =
        inherit JsonConverter<TypesTaskTypeCohere>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeCohere, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeCohere.TextEmbedding -> "text_embedding"
                | TypesTaskTypeCohere.Rerank -> "rerank"
                | TypesTaskTypeCohere.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeCohere.TextEmbedding
            | "rerank" -> TypesTaskTypeCohere.Rerank
            | "completion" -> TypesTaskTypeCohere.Completion
            | s -> failwith $"Unknown TypesTaskTypeCohere: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeCohereConverter>)>]
        TypesTaskTypeCohere =
        | TextEmbedding
        | Rerank
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoCohere = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeCohere
    }

    and TypesTaskTypeContextualAIConverter() =
        inherit JsonConverter<TypesTaskTypeContextualAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeContextualAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeContextualAI.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rerank" -> TypesTaskTypeContextualAI.Rerank
            | s -> failwith $"Unknown TypesTaskTypeContextualAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeContextualAIConverter>)>]
        TypesTaskTypeContextualAI =
        | Rerank
        with
        override this.ToString() =
            match this with
            | Rerank -> "rerank"

    and TypesContextualAIServiceTypeConverter() =
        inherit JsonConverter<TypesContextualAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesContextualAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesContextualAIServiceType.Contextualai -> "contextualai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "contextualai" -> TypesContextualAIServiceType.Contextualai
            | s -> failwith $"Unknown TypesContextualAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesContextualAIServiceTypeConverter>)>]
        TypesContextualAIServiceType =
        | Contextualai
        with
        override this.ToString() =
            match this with
            | Contextualai -> "contextualai"

    and TypesContextualAIServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesContextualAITaskSettings = {
        [<JsonPropertyName("instruction")>]
        Instruction: string option
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_k")>]
        TopK: float option
    }

    and TypesInferenceEndpointInfoContextualAi = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeContextualAI
    }

    and TypesCustomTaskTypeConverter() =
        inherit JsonConverter<TypesCustomTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCustomTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCustomTaskType.TextEmbedding -> "text_embedding"
                | TypesCustomTaskType.SparseEmbedding -> "sparse_embedding"
                | TypesCustomTaskType.Rerank -> "rerank"
                | TypesCustomTaskType.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesCustomTaskType.TextEmbedding
            | "sparse_embedding" -> TypesCustomTaskType.SparseEmbedding
            | "rerank" -> TypesCustomTaskType.Rerank
            | "completion" -> TypesCustomTaskType.Completion
            | s -> failwith $"Unknown TypesCustomTaskType: {s}"

    and [<JsonConverter(typeof<TypesCustomTaskTypeConverter>)>]
        TypesCustomTaskType =
        | TextEmbedding
        | SparseEmbedding
        | Rerank
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | SparseEmbedding -> "sparse_embedding"
            | Rerank -> "rerank"
            | Completion -> "completion"

    and TypesCustomServiceTypeConverter() =
        inherit JsonConverter<TypesCustomServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesCustomServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesCustomServiceType.Custom -> "custom"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "custom" -> TypesCustomServiceType.Custom
            | s -> failwith $"Unknown TypesCustomServiceType: {s}"

    and [<JsonConverter(typeof<TypesCustomServiceTypeConverter>)>]
        TypesCustomServiceType =
        | Custom
        with
        override this.ToString() =
            match this with
            | Custom -> "custom"

    and TypesCustomRequestParams = {
        [<JsonPropertyName("content")>]
        Content: string
    }

    and TypesCustomResponseParams = {
        [<JsonPropertyName("json_parser")>]
        JsonParser: obj
    }

    and TypesCustomServiceSettings = {
        [<JsonPropertyName("batch_size")>]
        BatchSize: float option
        [<JsonPropertyName("headers")>]
        Headers: obj option
        [<JsonPropertyName("input_type")>]
        InputType: obj option
        [<JsonPropertyName("query_parameters")>]
        QueryParameters: obj option
        [<JsonPropertyName("request")>]
        Request: TypesCustomRequestParams
        [<JsonPropertyName("response")>]
        Response: TypesCustomResponseParams
        [<JsonPropertyName("secret_parameters")>]
        SecretParameters: obj
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesCustomTaskSettings = {
        [<JsonPropertyName("parameters")>]
        Parameters: obj option
    }

    and TypesTaskTypeCustomConverter() =
        inherit JsonConverter<TypesTaskTypeCustom>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeCustom, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeCustom.TextEmbedding -> "text_embedding"
                | TypesTaskTypeCustom.SparseEmbedding -> "sparse_embedding"
                | TypesTaskTypeCustom.Rerank -> "rerank"
                | TypesTaskTypeCustom.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeCustom.TextEmbedding
            | "sparse_embedding" -> TypesTaskTypeCustom.SparseEmbedding
            | "rerank" -> TypesTaskTypeCustom.Rerank
            | "completion" -> TypesTaskTypeCustom.Completion
            | s -> failwith $"Unknown TypesTaskTypeCustom: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeCustomConverter>)>]
        TypesTaskTypeCustom =
        | TextEmbedding
        | SparseEmbedding
        | Rerank
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | SparseEmbedding -> "sparse_embedding"
            | Rerank -> "rerank"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoCustom = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeCustom
    }

    and TypesTaskTypeDeepSeekConverter() =
        inherit JsonConverter<TypesTaskTypeDeepSeek>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeDeepSeek, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeDeepSeek.Completion -> "completion"
                | TypesTaskTypeDeepSeek.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesTaskTypeDeepSeek.Completion
            | "chat_completion" -> TypesTaskTypeDeepSeek.ChatCompletion
            | s -> failwith $"Unknown TypesTaskTypeDeepSeek: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeDeepSeekConverter>)>]
        TypesTaskTypeDeepSeek =
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesDeepSeekServiceTypeConverter() =
        inherit JsonConverter<TypesDeepSeekServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDeepSeekServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDeepSeekServiceType.Deepseek -> "deepseek"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "deepseek" -> TypesDeepSeekServiceType.Deepseek
            | s -> failwith $"Unknown TypesDeepSeekServiceType: {s}"

    and [<JsonConverter(typeof<TypesDeepSeekServiceTypeConverter>)>]
        TypesDeepSeekServiceType =
        | Deepseek
        with
        override this.ToString() =
            match this with
            | Deepseek -> "deepseek"

    and TypesDeepSeekServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesInferenceEndpointInfoDeepSeek = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeDeepSeek
    }

    and TypesElasticsearchTaskTypeConverter() =
        inherit JsonConverter<TypesElasticsearchTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesElasticsearchTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesElasticsearchTaskType.Rerank -> "rerank"
                | TypesElasticsearchTaskType.SparseEmbedding -> "sparse_embedding"
                | TypesElasticsearchTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rerank" -> TypesElasticsearchTaskType.Rerank
            | "sparse_embedding" -> TypesElasticsearchTaskType.SparseEmbedding
            | "text_embedding" -> TypesElasticsearchTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesElasticsearchTaskType: {s}"

    and [<JsonConverter(typeof<TypesElasticsearchTaskTypeConverter>)>]
        TypesElasticsearchTaskType =
        | Rerank
        | SparseEmbedding
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Rerank -> "rerank"
            | SparseEmbedding -> "sparse_embedding"
            | TextEmbedding -> "text_embedding"

    and TypesElasticsearchServiceTypeConverter() =
        inherit JsonConverter<TypesElasticsearchServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesElasticsearchServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesElasticsearchServiceType.Elasticsearch -> "elasticsearch"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "elasticsearch" -> TypesElasticsearchServiceType.Elasticsearch
            | s -> failwith $"Unknown TypesElasticsearchServiceType: {s}"

    and [<JsonConverter(typeof<TypesElasticsearchServiceTypeConverter>)>]
        TypesElasticsearchServiceType =
        | Elasticsearch
        with
        override this.ToString() =
            match this with
            | Elasticsearch -> "elasticsearch"

    and TypesAdaptiveAllocations = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("max_number_of_allocations")>]
        MaxNumberOfAllocations: float option
        [<JsonPropertyName("min_number_of_allocations")>]
        MinNumberOfAllocations: float option
    }

    and TypesElasticsearchServiceSettings = {
        [<JsonPropertyName("adaptive_allocations")>]
        AdaptiveAllocations: TypesAdaptiveAllocations option
        [<JsonPropertyName("deployment_id")>]
        DeploymentId: string option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("num_allocations")>]
        NumAllocations: float option
        [<JsonPropertyName("num_threads")>]
        NumThreads: float
        [<JsonPropertyName("long_document_strategy")>]
        LongDocumentStrategy: string option
        [<JsonPropertyName("max_chunks_per_doc")>]
        MaxChunksPerDoc: float option
    }

    and TypesElasticsearchTaskSettings = {
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
    }

    and TypesTaskTypeElasticsearchConverter() =
        inherit JsonConverter<TypesTaskTypeElasticsearch>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeElasticsearch, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeElasticsearch.SparseEmbedding -> "sparse_embedding"
                | TypesTaskTypeElasticsearch.TextEmbedding -> "text_embedding"
                | TypesTaskTypeElasticsearch.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sparse_embedding" -> TypesTaskTypeElasticsearch.SparseEmbedding
            | "text_embedding" -> TypesTaskTypeElasticsearch.TextEmbedding
            | "rerank" -> TypesTaskTypeElasticsearch.Rerank
            | s -> failwith $"Unknown TypesTaskTypeElasticsearch: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeElasticsearchConverter>)>]
        TypesTaskTypeElasticsearch =
        | SparseEmbedding
        | TextEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | SparseEmbedding -> "sparse_embedding"
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoElasticsearch = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeElasticsearch
    }

    and TypesElserTaskTypeConverter() =
        inherit JsonConverter<TypesElserTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesElserTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesElserTaskType.SparseEmbedding -> "sparse_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sparse_embedding" -> TypesElserTaskType.SparseEmbedding
            | s -> failwith $"Unknown TypesElserTaskType: {s}"

    and [<JsonConverter(typeof<TypesElserTaskTypeConverter>)>]
        TypesElserTaskType =
        | SparseEmbedding
        with
        override this.ToString() =
            match this with
            | SparseEmbedding -> "sparse_embedding"

    and TypesElserServiceTypeConverter() =
        inherit JsonConverter<TypesElserServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesElserServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesElserServiceType.Elser -> "elser"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "elser" -> TypesElserServiceType.Elser
            | s -> failwith $"Unknown TypesElserServiceType: {s}"

    and [<JsonConverter(typeof<TypesElserServiceTypeConverter>)>]
        TypesElserServiceType =
        | Elser
        with
        override this.ToString() =
            match this with
            | Elser -> "elser"

    and TypesElserServiceSettings = {
        [<JsonPropertyName("adaptive_allocations")>]
        AdaptiveAllocations: TypesAdaptiveAllocations option
        [<JsonPropertyName("num_allocations")>]
        NumAllocations: float
        [<JsonPropertyName("num_threads")>]
        NumThreads: float
    }

    and TypesTaskTypeELSERConverter() =
        inherit JsonConverter<TypesTaskTypeELSER>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeELSER, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeELSER.SparseEmbedding -> "sparse_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sparse_embedding" -> TypesTaskTypeELSER.SparseEmbedding
            | s -> failwith $"Unknown TypesTaskTypeELSER: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeELSERConverter>)>]
        TypesTaskTypeELSER =
        | SparseEmbedding
        with
        override this.ToString() =
            match this with
            | SparseEmbedding -> "sparse_embedding"

    and TypesInferenceEndpointInfoELSER = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeELSER
    }

    and TypesGoogleAiStudioTaskTypeConverter() =
        inherit JsonConverter<TypesGoogleAiStudioTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGoogleAiStudioTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGoogleAiStudioTaskType.Completion -> "completion"
                | TypesGoogleAiStudioTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "completion" -> TypesGoogleAiStudioTaskType.Completion
            | "text_embedding" -> TypesGoogleAiStudioTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesGoogleAiStudioTaskType: {s}"

    and [<JsonConverter(typeof<TypesGoogleAiStudioTaskTypeConverter>)>]
        TypesGoogleAiStudioTaskType =
        | Completion
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Completion -> "completion"
            | TextEmbedding -> "text_embedding"

    and TypesGoogleAiServiceTypeConverter() =
        inherit JsonConverter<TypesGoogleAiServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGoogleAiServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGoogleAiServiceType.Googleaistudio -> "googleaistudio"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "googleaistudio" -> TypesGoogleAiServiceType.Googleaistudio
            | s -> failwith $"Unknown TypesGoogleAiServiceType: {s}"

    and [<JsonConverter(typeof<TypesGoogleAiServiceTypeConverter>)>]
        TypesGoogleAiServiceType =
        | Googleaistudio
        with
        override this.ToString() =
            match this with
            | Googleaistudio -> "googleaistudio"

    and TypesGoogleAiStudioServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesTaskTypeGoogleAIStudioConverter() =
        inherit JsonConverter<TypesTaskTypeGoogleAIStudio>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeGoogleAIStudio, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeGoogleAIStudio.TextEmbedding -> "text_embedding"
                | TypesTaskTypeGoogleAIStudio.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeGoogleAIStudio.TextEmbedding
            | "completion" -> TypesTaskTypeGoogleAIStudio.Completion
            | s -> failwith $"Unknown TypesTaskTypeGoogleAIStudio: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeGoogleAIStudioConverter>)>]
        TypesTaskTypeGoogleAIStudio =
        | TextEmbedding
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoGoogleAIStudio = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeGoogleAIStudio
    }

    and TypesGoogleVertexAITaskTypeConverter() =
        inherit JsonConverter<TypesGoogleVertexAITaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGoogleVertexAITaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGoogleVertexAITaskType.Rerank -> "rerank"
                | TypesGoogleVertexAITaskType.TextEmbedding -> "text_embedding"
                | TypesGoogleVertexAITaskType.Completion -> "completion"
                | TypesGoogleVertexAITaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rerank" -> TypesGoogleVertexAITaskType.Rerank
            | "text_embedding" -> TypesGoogleVertexAITaskType.TextEmbedding
            | "completion" -> TypesGoogleVertexAITaskType.Completion
            | "chat_completion" -> TypesGoogleVertexAITaskType.ChatCompletion
            | s -> failwith $"Unknown TypesGoogleVertexAITaskType: {s}"

    and [<JsonConverter(typeof<TypesGoogleVertexAITaskTypeConverter>)>]
        TypesGoogleVertexAITaskType =
        | Rerank
        | TextEmbedding
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesGoogleVertexAIServiceTypeConverter() =
        inherit JsonConverter<TypesGoogleVertexAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGoogleVertexAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGoogleVertexAIServiceType.Googlevertexai -> "googlevertexai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "googlevertexai" -> TypesGoogleVertexAIServiceType.Googlevertexai
            | s -> failwith $"Unknown TypesGoogleVertexAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesGoogleVertexAIServiceTypeConverter>)>]
        TypesGoogleVertexAIServiceType =
        | Googlevertexai
        with
        override this.ToString() =
            match this with
            | Googlevertexai -> "googlevertexai"

    and TypesGoogleModelGardenProviderConverter() =
        inherit JsonConverter<TypesGoogleModelGardenProvider>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGoogleModelGardenProvider, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGoogleModelGardenProvider.Google -> "google"
                | TypesGoogleModelGardenProvider.Anthropic -> "anthropic"
                | TypesGoogleModelGardenProvider.Meta -> "meta"
                | TypesGoogleModelGardenProvider.HuggingFace -> "hugging_face"
                | TypesGoogleModelGardenProvider.Mistral -> "mistral"
                | TypesGoogleModelGardenProvider.Ai21 -> "ai21"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "google" -> TypesGoogleModelGardenProvider.Google
            | "anthropic" -> TypesGoogleModelGardenProvider.Anthropic
            | "meta" -> TypesGoogleModelGardenProvider.Meta
            | "hugging_face" -> TypesGoogleModelGardenProvider.HuggingFace
            | "mistral" -> TypesGoogleModelGardenProvider.Mistral
            | "ai21" -> TypesGoogleModelGardenProvider.Ai21
            | s -> failwith $"Unknown TypesGoogleModelGardenProvider: {s}"

    and [<JsonConverter(typeof<TypesGoogleModelGardenProviderConverter>)>]
        TypesGoogleModelGardenProvider =
        | Google
        | Anthropic
        | Meta
        | HuggingFace
        | Mistral
        | Ai21
        with
        override this.ToString() =
            match this with
            | Google -> "google"
            | Anthropic -> "anthropic"
            | Meta -> "meta"
            | HuggingFace -> "hugging_face"
            | Mistral -> "mistral"
            | Ai21 -> "ai21"

    and TypesGoogleVertexAIServiceSettings = {
        [<JsonPropertyName("provider")>]
        Provider: TypesGoogleModelGardenProvider option
        [<JsonPropertyName("url")>]
        Url: string option
        [<JsonPropertyName("streaming_url")>]
        StreamingUrl: string option
        [<JsonPropertyName("location")>]
        Location: string option
        [<JsonPropertyName("model_id")>]
        ModelId: string option
        [<JsonPropertyName("project_id")>]
        ProjectId: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("service_account_json")>]
        ServiceAccountJson: string
        [<JsonPropertyName("dimensions")>]
        Dimensions: float option
    }

    and TypesThinkingConfig = {
        [<JsonPropertyName("thinking_budget")>]
        ThinkingBudget: float option
    }

    and TypesGoogleVertexAITaskSettings = {
        [<JsonPropertyName("auto_truncate")>]
        AutoTruncate: bool option
        [<JsonPropertyName("top_n")>]
        TopN: float option
        [<JsonPropertyName("thinking_config")>]
        ThinkingConfig: TypesThinkingConfig option
        [<JsonPropertyName("max_tokens")>]
        MaxTokens: float option
    }

    and TypesTaskTypeGoogleVertexAIConverter() =
        inherit JsonConverter<TypesTaskTypeGoogleVertexAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeGoogleVertexAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeGoogleVertexAI.ChatCompletion -> "chat_completion"
                | TypesTaskTypeGoogleVertexAI.Completion -> "completion"
                | TypesTaskTypeGoogleVertexAI.TextEmbedding -> "text_embedding"
                | TypesTaskTypeGoogleVertexAI.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesTaskTypeGoogleVertexAI.ChatCompletion
            | "completion" -> TypesTaskTypeGoogleVertexAI.Completion
            | "text_embedding" -> TypesTaskTypeGoogleVertexAI.TextEmbedding
            | "rerank" -> TypesTaskTypeGoogleVertexAI.Rerank
            | s -> failwith $"Unknown TypesTaskTypeGoogleVertexAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeGoogleVertexAIConverter>)>]
        TypesTaskTypeGoogleVertexAI =
        | ChatCompletion
        | Completion
        | TextEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoGoogleVertexAI = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeGoogleVertexAI
    }

    and TypesGroqTaskTypeConverter() =
        inherit JsonConverter<TypesGroqTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGroqTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGroqTaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesGroqTaskType.ChatCompletion
            | s -> failwith $"Unknown TypesGroqTaskType: {s}"

    and [<JsonConverter(typeof<TypesGroqTaskTypeConverter>)>]
        TypesGroqTaskType =
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"

    and TypesGroqServiceTypeConverter() =
        inherit JsonConverter<TypesGroqServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGroqServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGroqServiceType.Groq -> "groq"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "groq" -> TypesGroqServiceType.Groq
            | s -> failwith $"Unknown TypesGroqServiceType: {s}"

    and [<JsonConverter(typeof<TypesGroqServiceTypeConverter>)>]
        TypesGroqServiceType =
        | Groq
        with
        override this.ToString() =
            match this with
            | Groq -> "groq"

    and TypesGroqServiceSettings = {
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("api_key")>]
        ApiKey: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesTaskTypeGroqConverter() =
        inherit JsonConverter<TypesTaskTypeGroq>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeGroq, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeGroq.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesTaskTypeGroq.ChatCompletion
            | s -> failwith $"Unknown TypesTaskTypeGroq: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeGroqConverter>)>]
        TypesTaskTypeGroq =
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"

    and TypesInferenceEndpointInfoGroq = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeGroq
    }

    and TypesHuggingFaceTaskTypeConverter() =
        inherit JsonConverter<TypesHuggingFaceTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesHuggingFaceTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesHuggingFaceTaskType.ChatCompletion -> "chat_completion"
                | TypesHuggingFaceTaskType.Completion -> "completion"
                | TypesHuggingFaceTaskType.Rerank -> "rerank"
                | TypesHuggingFaceTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesHuggingFaceTaskType.ChatCompletion
            | "completion" -> TypesHuggingFaceTaskType.Completion
            | "rerank" -> TypesHuggingFaceTaskType.Rerank
            | "text_embedding" -> TypesHuggingFaceTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesHuggingFaceTaskType: {s}"

    and [<JsonConverter(typeof<TypesHuggingFaceTaskTypeConverter>)>]
        TypesHuggingFaceTaskType =
        | ChatCompletion
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesHuggingFaceServiceTypeConverter() =
        inherit JsonConverter<TypesHuggingFaceServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesHuggingFaceServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesHuggingFaceServiceType.HuggingFace -> "hugging_face"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "hugging_face" -> TypesHuggingFaceServiceType.HuggingFace
            | s -> failwith $"Unknown TypesHuggingFaceServiceType: {s}"

    and [<JsonConverter(typeof<TypesHuggingFaceServiceTypeConverter>)>]
        TypesHuggingFaceServiceType =
        | HuggingFace
        with
        override this.ToString() =
            match this with
            | HuggingFace -> "hugging_face"

    and TypesHuggingFaceServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("url")>]
        Url: string
        [<JsonPropertyName("model_id")>]
        ModelId: string option
    }

    and TypesHuggingFaceTaskSettings = {
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_n")>]
        TopN: float option
    }

    and TypesTaskTypeHuggingFaceConverter() =
        inherit JsonConverter<TypesTaskTypeHuggingFace>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeHuggingFace, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeHuggingFace.ChatCompletion -> "chat_completion"
                | TypesTaskTypeHuggingFace.Completion -> "completion"
                | TypesTaskTypeHuggingFace.Rerank -> "rerank"
                | TypesTaskTypeHuggingFace.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesTaskTypeHuggingFace.ChatCompletion
            | "completion" -> TypesTaskTypeHuggingFace.Completion
            | "rerank" -> TypesTaskTypeHuggingFace.Rerank
            | "text_embedding" -> TypesTaskTypeHuggingFace.TextEmbedding
            | s -> failwith $"Unknown TypesTaskTypeHuggingFace: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeHuggingFaceConverter>)>]
        TypesTaskTypeHuggingFace =
        | ChatCompletion
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesInferenceEndpointInfoHuggingFace = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeHuggingFace
    }

    and TypesJinaAITaskTypeConverter() =
        inherit JsonConverter<TypesJinaAITaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJinaAITaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJinaAITaskType.Rerank -> "rerank"
                | TypesJinaAITaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rerank" -> TypesJinaAITaskType.Rerank
            | "text_embedding" -> TypesJinaAITaskType.TextEmbedding
            | s -> failwith $"Unknown TypesJinaAITaskType: {s}"

    and [<JsonConverter(typeof<TypesJinaAITaskTypeConverter>)>]
        TypesJinaAITaskType =
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesJinaAIServiceTypeConverter() =
        inherit JsonConverter<TypesJinaAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJinaAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJinaAIServiceType.Jinaai -> "jinaai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "jinaai" -> TypesJinaAIServiceType.Jinaai
            | s -> failwith $"Unknown TypesJinaAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesJinaAIServiceTypeConverter>)>]
        TypesJinaAIServiceType =
        | Jinaai
        with
        override this.ToString() =
            match this with
            | Jinaai -> "jinaai"

    and TypesJinaAISimilarityTypeConverter() =
        inherit JsonConverter<TypesJinaAISimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJinaAISimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJinaAISimilarityType.Cosine -> "cosine"
                | TypesJinaAISimilarityType.DotProduct -> "dot_product"
                | TypesJinaAISimilarityType.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> TypesJinaAISimilarityType.Cosine
            | "dot_product" -> TypesJinaAISimilarityType.DotProduct
            | "l2_norm" -> TypesJinaAISimilarityType.L2Norm
            | s -> failwith $"Unknown TypesJinaAISimilarityType: {s}"

    and [<JsonConverter(typeof<TypesJinaAISimilarityTypeConverter>)>]
        TypesJinaAISimilarityType =
        | Cosine
        | DotProduct
        | L2Norm
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"

    and TypesJinaAIServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("model_id")>]
        ModelId: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("similarity")>]
        Similarity: TypesJinaAISimilarityType option
    }

    and TypesJinaAITextEmbeddingTaskConverter() =
        inherit JsonConverter<TypesJinaAITextEmbeddingTask>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJinaAITextEmbeddingTask, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJinaAITextEmbeddingTask.Classification -> "classification"
                | TypesJinaAITextEmbeddingTask.Clustering -> "clustering"
                | TypesJinaAITextEmbeddingTask.Ingest -> "ingest"
                | TypesJinaAITextEmbeddingTask.Search -> "search"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "classification" -> TypesJinaAITextEmbeddingTask.Classification
            | "clustering" -> TypesJinaAITextEmbeddingTask.Clustering
            | "ingest" -> TypesJinaAITextEmbeddingTask.Ingest
            | "search" -> TypesJinaAITextEmbeddingTask.Search
            | s -> failwith $"Unknown TypesJinaAITextEmbeddingTask: {s}"

    and [<JsonConverter(typeof<TypesJinaAITextEmbeddingTaskConverter>)>]
        TypesJinaAITextEmbeddingTask =
        | Classification
        | Clustering
        | Ingest
        | Search
        with
        override this.ToString() =
            match this with
            | Classification -> "classification"
            | Clustering -> "clustering"
            | Ingest -> "ingest"
            | Search -> "search"

    and TypesJinaAITaskSettings = {
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("task")>]
        Task: TypesJinaAITextEmbeddingTask option
        [<JsonPropertyName("top_n")>]
        TopN: float option
    }

    and TypesTaskTypeJinaAiConverter() =
        inherit JsonConverter<TypesTaskTypeJinaAi>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeJinaAi, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeJinaAi.TextEmbedding -> "text_embedding"
                | TypesTaskTypeJinaAi.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeJinaAi.TextEmbedding
            | "rerank" -> TypesTaskTypeJinaAi.Rerank
            | s -> failwith $"Unknown TypesTaskTypeJinaAi: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeJinaAiConverter>)>]
        TypesTaskTypeJinaAi =
        | TextEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoJinaAi = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeJinaAi
    }

    and TypesLlamaTaskTypeConverter() =
        inherit JsonConverter<TypesLlamaTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesLlamaTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesLlamaTaskType.TextEmbedding -> "text_embedding"
                | TypesLlamaTaskType.Completion -> "completion"
                | TypesLlamaTaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesLlamaTaskType.TextEmbedding
            | "completion" -> TypesLlamaTaskType.Completion
            | "chat_completion" -> TypesLlamaTaskType.ChatCompletion
            | s -> failwith $"Unknown TypesLlamaTaskType: {s}"

    and [<JsonConverter(typeof<TypesLlamaTaskTypeConverter>)>]
        TypesLlamaTaskType =
        | TextEmbedding
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesLlamaServiceTypeConverter() =
        inherit JsonConverter<TypesLlamaServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesLlamaServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesLlamaServiceType.Llama -> "llama"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "llama" -> TypesLlamaServiceType.Llama
            | s -> failwith $"Unknown TypesLlamaServiceType: {s}"

    and [<JsonConverter(typeof<TypesLlamaServiceTypeConverter>)>]
        TypesLlamaServiceType =
        | Llama
        with
        override this.ToString() =
            match this with
            | Llama -> "llama"

    and TypesLlamaSimilarityTypeConverter() =
        inherit JsonConverter<TypesLlamaSimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesLlamaSimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesLlamaSimilarityType.Cosine -> "cosine"
                | TypesLlamaSimilarityType.DotProduct -> "dot_product"
                | TypesLlamaSimilarityType.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> TypesLlamaSimilarityType.Cosine
            | "dot_product" -> TypesLlamaSimilarityType.DotProduct
            | "l2_norm" -> TypesLlamaSimilarityType.L2Norm
            | s -> failwith $"Unknown TypesLlamaSimilarityType: {s}"

    and [<JsonConverter(typeof<TypesLlamaSimilarityTypeConverter>)>]
        TypesLlamaSimilarityType =
        | Cosine
        | DotProduct
        | L2Norm
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"

    and TypesLlamaServiceSettings = {
        [<JsonPropertyName("url")>]
        Url: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("max_input_tokens")>]
        MaxInputTokens: float option
        [<JsonPropertyName("similarity")>]
        Similarity: TypesLlamaSimilarityType option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesTaskTypeLlamaConverter() =
        inherit JsonConverter<TypesTaskTypeLlama>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeLlama, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeLlama.TextEmbedding -> "text_embedding"
                | TypesTaskTypeLlama.ChatCompletion -> "chat_completion"
                | TypesTaskTypeLlama.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeLlama.TextEmbedding
            | "chat_completion" -> TypesTaskTypeLlama.ChatCompletion
            | "completion" -> TypesTaskTypeLlama.Completion
            | s -> failwith $"Unknown TypesTaskTypeLlama: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeLlamaConverter>)>]
        TypesTaskTypeLlama =
        | TextEmbedding
        | ChatCompletion
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoLlama = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeLlama
    }

    and TypesMistralTaskTypeConverter() =
        inherit JsonConverter<TypesMistralTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesMistralTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesMistralTaskType.TextEmbedding -> "text_embedding"
                | TypesMistralTaskType.Completion -> "completion"
                | TypesMistralTaskType.ChatCompletion -> "chat_completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesMistralTaskType.TextEmbedding
            | "completion" -> TypesMistralTaskType.Completion
            | "chat_completion" -> TypesMistralTaskType.ChatCompletion
            | s -> failwith $"Unknown TypesMistralTaskType: {s}"

    and [<JsonConverter(typeof<TypesMistralTaskTypeConverter>)>]
        TypesMistralTaskType =
        | TextEmbedding
        | Completion
        | ChatCompletion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"

    and TypesMistralServiceTypeConverter() =
        inherit JsonConverter<TypesMistralServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesMistralServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesMistralServiceType.Mistral -> "mistral"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "mistral" -> TypesMistralServiceType.Mistral
            | s -> failwith $"Unknown TypesMistralServiceType: {s}"

    and [<JsonConverter(typeof<TypesMistralServiceTypeConverter>)>]
        TypesMistralServiceType =
        | Mistral
        with
        override this.ToString() =
            match this with
            | Mistral -> "mistral"

    and TypesMistralServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("max_input_tokens")>]
        MaxInputTokens: float option
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesTaskTypeMistralConverter() =
        inherit JsonConverter<TypesTaskTypeMistral>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeMistral, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeMistral.TextEmbedding -> "text_embedding"
                | TypesTaskTypeMistral.ChatCompletion -> "chat_completion"
                | TypesTaskTypeMistral.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeMistral.TextEmbedding
            | "chat_completion" -> TypesTaskTypeMistral.ChatCompletion
            | "completion" -> TypesTaskTypeMistral.Completion
            | s -> failwith $"Unknown TypesTaskTypeMistral: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeMistralConverter>)>]
        TypesTaskTypeMistral =
        | TextEmbedding
        | ChatCompletion
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoMistral = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeMistral
    }

    and TypesNvidiaTaskTypeConverter() =
        inherit JsonConverter<TypesNvidiaTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesNvidiaTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesNvidiaTaskType.ChatCompletion -> "chat_completion"
                | TypesNvidiaTaskType.Completion -> "completion"
                | TypesNvidiaTaskType.Rerank -> "rerank"
                | TypesNvidiaTaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesNvidiaTaskType.ChatCompletion
            | "completion" -> TypesNvidiaTaskType.Completion
            | "rerank" -> TypesNvidiaTaskType.Rerank
            | "text_embedding" -> TypesNvidiaTaskType.TextEmbedding
            | s -> failwith $"Unknown TypesNvidiaTaskType: {s}"

    and [<JsonConverter(typeof<TypesNvidiaTaskTypeConverter>)>]
        TypesNvidiaTaskType =
        | ChatCompletion
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesNvidiaServiceTypeConverter() =
        inherit JsonConverter<TypesNvidiaServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesNvidiaServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesNvidiaServiceType.Nvidia -> "nvidia"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "nvidia" -> TypesNvidiaServiceType.Nvidia
            | s -> failwith $"Unknown TypesNvidiaServiceType: {s}"

    and [<JsonConverter(typeof<TypesNvidiaServiceTypeConverter>)>]
        TypesNvidiaServiceType =
        | Nvidia
        with
        override this.ToString() =
            match this with
            | Nvidia -> "nvidia"

    and TypesNvidiaSimilarityTypeConverter() =
        inherit JsonConverter<TypesNvidiaSimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesNvidiaSimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesNvidiaSimilarityType.Cosine -> "cosine"
                | TypesNvidiaSimilarityType.DotProduct -> "dot_product"
                | TypesNvidiaSimilarityType.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> TypesNvidiaSimilarityType.Cosine
            | "dot_product" -> TypesNvidiaSimilarityType.DotProduct
            | "l2_norm" -> TypesNvidiaSimilarityType.L2Norm
            | s -> failwith $"Unknown TypesNvidiaSimilarityType: {s}"

    and [<JsonConverter(typeof<TypesNvidiaSimilarityTypeConverter>)>]
        TypesNvidiaSimilarityType =
        | Cosine
        | DotProduct
        | L2Norm
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"

    and TypesNvidiaServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("url")>]
        Url: string option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("max_input_tokens")>]
        MaxInputTokens: float option
        [<JsonPropertyName("similarity")>]
        Similarity: TypesNvidiaSimilarityType option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesNvidiaInputTypeConverter() =
        inherit JsonConverter<TypesNvidiaInputType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesNvidiaInputType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesNvidiaInputType.Ingest -> "ingest"
                | TypesNvidiaInputType.Search -> "search"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ingest" -> TypesNvidiaInputType.Ingest
            | "search" -> TypesNvidiaInputType.Search
            | s -> failwith $"Unknown TypesNvidiaInputType: {s}"

    and [<JsonConverter(typeof<TypesNvidiaInputTypeConverter>)>]
        TypesNvidiaInputType =
        | Ingest
        | Search
        with
        override this.ToString() =
            match this with
            | Ingest -> "ingest"
            | Search -> "search"

    and TypesNvidiaTaskSettings = {
        [<JsonPropertyName("input_type")>]
        InputType: TypesNvidiaInputType option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesCohereTruncateType option
    }

    and TypesTaskTypeNvidiaConverter() =
        inherit JsonConverter<TypesTaskTypeNvidia>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeNvidia, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeNvidia.ChatCompletion -> "chat_completion"
                | TypesTaskTypeNvidia.Completion -> "completion"
                | TypesTaskTypeNvidia.Rerank -> "rerank"
                | TypesTaskTypeNvidia.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesTaskTypeNvidia.ChatCompletion
            | "completion" -> TypesTaskTypeNvidia.Completion
            | "rerank" -> TypesTaskTypeNvidia.Rerank
            | "text_embedding" -> TypesTaskTypeNvidia.TextEmbedding
            | s -> failwith $"Unknown TypesTaskTypeNvidia: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeNvidiaConverter>)>]
        TypesTaskTypeNvidia =
        | ChatCompletion
        | Completion
        | Rerank
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | Rerank -> "rerank"
            | TextEmbedding -> "text_embedding"

    and TypesInferenceEndpointInfoNvidia = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeNvidia
    }

    and TypesOpenAITaskTypeConverter() =
        inherit JsonConverter<TypesOpenAITaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesOpenAITaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesOpenAITaskType.ChatCompletion -> "chat_completion"
                | TypesOpenAITaskType.Completion -> "completion"
                | TypesOpenAITaskType.TextEmbedding -> "text_embedding"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "chat_completion" -> TypesOpenAITaskType.ChatCompletion
            | "completion" -> TypesOpenAITaskType.Completion
            | "text_embedding" -> TypesOpenAITaskType.TextEmbedding
            | s -> failwith $"Unknown TypesOpenAITaskType: {s}"

    and [<JsonConverter(typeof<TypesOpenAITaskTypeConverter>)>]
        TypesOpenAITaskType =
        | ChatCompletion
        | Completion
        | TextEmbedding
        with
        override this.ToString() =
            match this with
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | TextEmbedding -> "text_embedding"

    and TypesOpenAIServiceTypeConverter() =
        inherit JsonConverter<TypesOpenAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesOpenAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesOpenAIServiceType.Openai -> "openai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "openai" -> TypesOpenAIServiceType.Openai
            | s -> failwith $"Unknown TypesOpenAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesOpenAIServiceTypeConverter>)>]
        TypesOpenAIServiceType =
        | Openai
        with
        override this.ToString() =
            match this with
            | Openai -> "openai"

    and TypesOpenAIServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("dimensions")>]
        Dimensions: float option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("organization_id")>]
        OrganizationId: string option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesOpenAITaskSettings = {
        [<JsonPropertyName("user")>]
        User: string option
        [<JsonPropertyName("headers")>]
        Headers: obj option
    }

    and TypesTaskTypeOpenAIConverter() =
        inherit JsonConverter<TypesTaskTypeOpenAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeOpenAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeOpenAI.TextEmbedding -> "text_embedding"
                | TypesTaskTypeOpenAI.ChatCompletion -> "chat_completion"
                | TypesTaskTypeOpenAI.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeOpenAI.TextEmbedding
            | "chat_completion" -> TypesTaskTypeOpenAI.ChatCompletion
            | "completion" -> TypesTaskTypeOpenAI.Completion
            | s -> failwith $"Unknown TypesTaskTypeOpenAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeOpenAIConverter>)>]
        TypesTaskTypeOpenAI =
        | TextEmbedding
        | ChatCompletion
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoOpenAI = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeOpenAI
    }

    and TypesOpenShiftAiTaskTypeConverter() =
        inherit JsonConverter<TypesOpenShiftAiTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesOpenShiftAiTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesOpenShiftAiTaskType.TextEmbedding -> "text_embedding"
                | TypesOpenShiftAiTaskType.Completion -> "completion"
                | TypesOpenShiftAiTaskType.ChatCompletion -> "chat_completion"
                | TypesOpenShiftAiTaskType.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesOpenShiftAiTaskType.TextEmbedding
            | "completion" -> TypesOpenShiftAiTaskType.Completion
            | "chat_completion" -> TypesOpenShiftAiTaskType.ChatCompletion
            | "rerank" -> TypesOpenShiftAiTaskType.Rerank
            | s -> failwith $"Unknown TypesOpenShiftAiTaskType: {s}"

    and [<JsonConverter(typeof<TypesOpenShiftAiTaskTypeConverter>)>]
        TypesOpenShiftAiTaskType =
        | TextEmbedding
        | Completion
        | ChatCompletion
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Completion -> "completion"
            | ChatCompletion -> "chat_completion"
            | Rerank -> "rerank"

    and TypesOpenShiftAiServiceTypeConverter() =
        inherit JsonConverter<TypesOpenShiftAiServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesOpenShiftAiServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesOpenShiftAiServiceType.OpenshiftAi -> "openshift_ai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "openshift_ai" -> TypesOpenShiftAiServiceType.OpenshiftAi
            | s -> failwith $"Unknown TypesOpenShiftAiServiceType: {s}"

    and [<JsonConverter(typeof<TypesOpenShiftAiServiceTypeConverter>)>]
        TypesOpenShiftAiServiceType =
        | OpenshiftAi
        with
        override this.ToString() =
            match this with
            | OpenshiftAi -> "openshift_ai"

    and TypesOpenShiftAiSimilarityTypeConverter() =
        inherit JsonConverter<TypesOpenShiftAiSimilarityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesOpenShiftAiSimilarityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesOpenShiftAiSimilarityType.Cosine -> "cosine"
                | TypesOpenShiftAiSimilarityType.DotProduct -> "dot_product"
                | TypesOpenShiftAiSimilarityType.L2Norm -> "l2_norm"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cosine" -> TypesOpenShiftAiSimilarityType.Cosine
            | "dot_product" -> TypesOpenShiftAiSimilarityType.DotProduct
            | "l2_norm" -> TypesOpenShiftAiSimilarityType.L2Norm
            | s -> failwith $"Unknown TypesOpenShiftAiSimilarityType: {s}"

    and [<JsonConverter(typeof<TypesOpenShiftAiSimilarityTypeConverter>)>]
        TypesOpenShiftAiSimilarityType =
        | Cosine
        | DotProduct
        | L2Norm
        with
        override this.ToString() =
            match this with
            | Cosine -> "cosine"
            | DotProduct -> "dot_product"
            | L2Norm -> "l2_norm"

    and TypesOpenShiftAiServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("url")>]
        Url: string
        [<JsonPropertyName("model_id")>]
        ModelId: string option
        [<JsonPropertyName("max_input_tokens")>]
        MaxInputTokens: float option
        [<JsonPropertyName("similarity")>]
        Similarity: TypesOpenShiftAiSimilarityType option
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
    }

    and TypesOpenShiftAiTaskSettings = {
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_n")>]
        TopN: float option
    }

    and TypesTaskTypeOpenShiftAiConverter() =
        inherit JsonConverter<TypesTaskTypeOpenShiftAi>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeOpenShiftAi, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeOpenShiftAi.TextEmbedding -> "text_embedding"
                | TypesTaskTypeOpenShiftAi.ChatCompletion -> "chat_completion"
                | TypesTaskTypeOpenShiftAi.Completion -> "completion"
                | TypesTaskTypeOpenShiftAi.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeOpenShiftAi.TextEmbedding
            | "chat_completion" -> TypesTaskTypeOpenShiftAi.ChatCompletion
            | "completion" -> TypesTaskTypeOpenShiftAi.Completion
            | "rerank" -> TypesTaskTypeOpenShiftAi.Rerank
            | s -> failwith $"Unknown TypesTaskTypeOpenShiftAi: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeOpenShiftAiConverter>)>]
        TypesTaskTypeOpenShiftAi =
        | TextEmbedding
        | ChatCompletion
        | Completion
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoOpenShiftAi = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeOpenShiftAi
    }

    and TypesVoyageAITaskTypeConverter() =
        inherit JsonConverter<TypesVoyageAITaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesVoyageAITaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesVoyageAITaskType.TextEmbedding -> "text_embedding"
                | TypesVoyageAITaskType.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesVoyageAITaskType.TextEmbedding
            | "rerank" -> TypesVoyageAITaskType.Rerank
            | s -> failwith $"Unknown TypesVoyageAITaskType: {s}"

    and [<JsonConverter(typeof<TypesVoyageAITaskTypeConverter>)>]
        TypesVoyageAITaskType =
        | TextEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"

    and TypesVoyageAIServiceTypeConverter() =
        inherit JsonConverter<TypesVoyageAIServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesVoyageAIServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesVoyageAIServiceType.Voyageai -> "voyageai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "voyageai" -> TypesVoyageAIServiceType.Voyageai
            | s -> failwith $"Unknown TypesVoyageAIServiceType: {s}"

    and [<JsonConverter(typeof<TypesVoyageAIServiceTypeConverter>)>]
        TypesVoyageAIServiceType =
        | Voyageai
        with
        override this.ToString() =
            match this with
            | Voyageai -> "voyageai"

    and TypesVoyageAIServiceSettings = {
        [<JsonPropertyName("dimensions")>]
        Dimensions: float option
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("embedding_type")>]
        EmbeddingType: float option
    }

    and TypesVoyageAITaskSettings = {
        [<JsonPropertyName("input_type")>]
        InputType: string option
        [<JsonPropertyName("return_documents")>]
        ReturnDocuments: bool option
        [<JsonPropertyName("top_k")>]
        TopK: float option
        [<JsonPropertyName("truncation")>]
        Truncation: bool option
    }

    and TypesTaskTypeVoyageAIConverter() =
        inherit JsonConverter<TypesTaskTypeVoyageAI>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeVoyageAI, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeVoyageAI.TextEmbedding -> "text_embedding"
                | TypesTaskTypeVoyageAI.Rerank -> "rerank"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeVoyageAI.TextEmbedding
            | "rerank" -> TypesTaskTypeVoyageAI.Rerank
            | s -> failwith $"Unknown TypesTaskTypeVoyageAI: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeVoyageAIConverter>)>]
        TypesTaskTypeVoyageAI =
        | TextEmbedding
        | Rerank
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | Rerank -> "rerank"

    and TypesInferenceEndpointInfoVoyageAI = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeVoyageAI
    }

    and TypesWatsonxTaskTypeConverter() =
        inherit JsonConverter<TypesWatsonxTaskType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesWatsonxTaskType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesWatsonxTaskType.TextEmbedding -> "text_embedding"
                | TypesWatsonxTaskType.ChatCompletion -> "chat_completion"
                | TypesWatsonxTaskType.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesWatsonxTaskType.TextEmbedding
            | "chat_completion" -> TypesWatsonxTaskType.ChatCompletion
            | "completion" -> TypesWatsonxTaskType.Completion
            | s -> failwith $"Unknown TypesWatsonxTaskType: {s}"

    and [<JsonConverter(typeof<TypesWatsonxTaskTypeConverter>)>]
        TypesWatsonxTaskType =
        | TextEmbedding
        | ChatCompletion
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"

    and TypesWatsonxServiceTypeConverter() =
        inherit JsonConverter<TypesWatsonxServiceType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesWatsonxServiceType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesWatsonxServiceType.Watsonxai -> "watsonxai"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "watsonxai" -> TypesWatsonxServiceType.Watsonxai
            | s -> failwith $"Unknown TypesWatsonxServiceType: {s}"

    and [<JsonConverter(typeof<TypesWatsonxServiceTypeConverter>)>]
        TypesWatsonxServiceType =
        | Watsonxai
        with
        override this.ToString() =
            match this with
            | Watsonxai -> "watsonxai"

    and TypesWatsonxServiceSettings = {
        [<JsonPropertyName("api_key")>]
        ApiKey: string
        [<JsonPropertyName("api_version")>]
        ApiVersion: string
        [<JsonPropertyName("model_id")>]
        ModelId: string
        [<JsonPropertyName("project_id")>]
        ProjectId: string
        [<JsonPropertyName("rate_limit")>]
        RateLimit: TypesRateLimitSetting option
        [<JsonPropertyName("url")>]
        Url: string
    }

    and TypesTaskTypeWatsonxConverter() =
        inherit JsonConverter<TypesTaskTypeWatsonx>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTaskTypeWatsonx, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTaskTypeWatsonx.TextEmbedding -> "text_embedding"
                | TypesTaskTypeWatsonx.ChatCompletion -> "chat_completion"
                | TypesTaskTypeWatsonx.Completion -> "completion"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "text_embedding" -> TypesTaskTypeWatsonx.TextEmbedding
            | "chat_completion" -> TypesTaskTypeWatsonx.ChatCompletion
            | "completion" -> TypesTaskTypeWatsonx.Completion
            | s -> failwith $"Unknown TypesTaskTypeWatsonx: {s}"

    and [<JsonConverter(typeof<TypesTaskTypeWatsonxConverter>)>]
        TypesTaskTypeWatsonx =
        | TextEmbedding
        | ChatCompletion
        | Completion
        with
        override this.ToString() =
            match this with
            | TextEmbedding -> "text_embedding"
            | ChatCompletion -> "chat_completion"
            | Completion -> "completion"

    and TypesInferenceEndpointInfoWatsonx = {
        [<JsonPropertyName("chunking_settings")>]
        ChunkingSettings: TypesInferenceChunkingSettings option
        [<JsonPropertyName("service")>]
        Service: string
        [<JsonPropertyName("service_settings")>]
        ServiceSettings: TypesServiceSettings
        [<JsonPropertyName("task_settings")>]
        TaskSettings: TypesTaskSettings option
        [<JsonPropertyName("inference_id")>]
        InferenceId: string
        [<JsonPropertyName("task_type")>]
        TaskType: TypesTaskTypeWatsonx
    }

    /// <summary>
    /// Defines the response for a rerank request.
    /// </summary>
    and TypesRerankedInferenceResult = {
        [<JsonPropertyName("rerank")>]
        Rerank: TypesRankedDocument array
    }

    /// <summary>
    /// The response format for the sparse embedding request.
    /// </summary>
    and TypesSparseEmbeddingInferenceResult = {
        [<JsonPropertyName("sparse_embedding")>]
        SparseEmbedding: TypesSparseEmbeddingResult array
    }

    /// <summary>
    /// TextEmbeddingInferenceResult is an aggregation of mutually exclusive text_embedding variants
    /// </summary>
    and TypesTextEmbeddingInferenceResult = {
        [<JsonPropertyName("text_embedding_bytes")>]
        TextEmbeddingBytes: TypesTextEmbeddingByteResult array option
        [<JsonPropertyName("text_embedding_bits")>]
        TextEmbeddingBits: TypesTextEmbeddingByteResult array option
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: TypesTextEmbeddingResult array option
    }

    and ElasticsearchVersionInfo = {
        [<JsonPropertyName("build_date")>]
        BuildDate: DateTime
        [<JsonPropertyName("build_flavor")>]
        BuildFlavor: string
        [<JsonPropertyName("build_hash")>]
        BuildHash: string
        [<JsonPropertyName("build_snapshot")>]
        BuildSnapshot: bool
        [<JsonPropertyName("build_type")>]
        BuildType: string
        [<JsonPropertyName("lucene_version")>]
        LuceneVersion: VersionString
        [<JsonPropertyName("minimum_index_compatibility_version")>]
        MinimumIndexCompatibilityVersion: VersionString
        [<JsonPropertyName("minimum_wire_compatibility_version")>]
        MinimumWireCompatibilityVersion: VersionString
        [<JsonPropertyName("number")>]
        Number: string
    }

    and GeoIpStatsGeoIpDownloadStatistics = {
        [<JsonPropertyName("successful_downloads")>]
        SuccessfulDownloads: float
        [<JsonPropertyName("failed_downloads")>]
        FailedDownloads: float
        [<JsonPropertyName("total_download_time")>]
        TotalDownloadTime: DurationValueUnitMillis
        [<JsonPropertyName("databases_count")>]
        DatabasesCount: float
        [<JsonPropertyName("skipped_updates")>]
        SkippedUpdates: float
        [<JsonPropertyName("expired_databases")>]
        ExpiredDatabases: float
    }

    and GeoIpStatsGeoIpNodeDatabaseName = {
        [<JsonPropertyName("name")>]
        Name: Name
    }

    /// <summary>
    /// Downloaded databases for the node. The field key is the node ID.
    /// </summary>
    and GeoIpStatsGeoIpNodeDatabases = {
        [<JsonPropertyName("databases")>]
        Databases: GeoIpStatsGeoIpNodeDatabaseName array
        [<JsonPropertyName("files_in_temp")>]
        FilesInTemp: string array
    }

    and TypesIpinfo = obj

    and TypesMaxmind = {
        [<JsonPropertyName("account_id")>]
        AccountId: Id
    }

    /// <summary>
    /// The configuration necessary to identify which IP geolocation provider to use to download a database, as well as any provider-specific configuration necessary for such downloading.
    /// At present, the only supported providers are `maxmind` and `ipinfo`, and the `maxmind` provider requires that an `account_id` (string) is configured.
    /// A provider (either `maxmind` or `ipinfo`) must be specified. The web and local providers can be returned as read only configurations.
    /// </summary>
    and TypesDatabaseConfiguration = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("maxmind")>]
        Maxmind: TypesMaxmind option
        [<JsonPropertyName("ipinfo")>]
        Ipinfo: TypesIpinfo option
    }

    and GetGeoipDatabaseDatabaseConfigurationMetadata = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("version")>]
        Version: float
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis
        [<JsonPropertyName("database")>]
        Database: TypesDatabaseConfiguration
    }

    and TypesLocal = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and TypesWeb = obj

    and TypesDatabaseConfigurationFull = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("web")>]
        Web: TypesWeb option
        [<JsonPropertyName("local")>]
        Local: TypesLocal option
        [<JsonPropertyName("maxmind")>]
        Maxmind: TypesMaxmind option
        [<JsonPropertyName("ipinfo")>]
        Ipinfo: TypesIpinfo option
    }

    and GetIpLocationDatabaseDatabaseConfigurationMetadata = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("version")>]
        Version: VersionNumber
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: EpochTimeUnitMillis option
        [<JsonPropertyName("database")>]
        Database: TypesDatabaseConfigurationFull
    }

    and TypesFieldAccessPatternConverter() =
        inherit JsonConverter<TypesFieldAccessPattern>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFieldAccessPattern, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFieldAccessPattern.Classic -> "classic"
                | TypesFieldAccessPattern.Flexible -> "flexible"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "classic" -> TypesFieldAccessPattern.Classic
            | "flexible" -> TypesFieldAccessPattern.Flexible
            | s -> failwith $"Unknown TypesFieldAccessPattern: {s}"

    and [<JsonConverter(typeof<TypesFieldAccessPatternConverter>)>]
        TypesFieldAccessPattern =
        | Classic
        | Flexible
        with
        override this.ToString() =
            match this with
            | Classic -> "classic"
            | Flexible -> "flexible"

    and TypesProcessorBase = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
    }

    and TypesAppendProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("value")>]
        Value: System.Text.Json.JsonElement option
        [<JsonPropertyName("copy_from")>]
        CopyFrom: Field option
        [<JsonPropertyName("allow_duplicates")>]
        AllowDuplicates: bool option
    }

    and TypesAttachmentProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("indexed_chars")>]
        IndexedChars: float option
        [<JsonPropertyName("indexed_chars_field")>]
        IndexedCharsField: Field option
        [<JsonPropertyName("properties")>]
        Properties: string array option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("remove_binary")>]
        RemoveBinary: bool option
        [<JsonPropertyName("resource_name")>]
        ResourceName: string option
    }

    and TypesBytesProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesShapeTypeConverter() =
        inherit JsonConverter<TypesShapeType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesShapeType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesShapeType.GeoShape -> "geo_shape"
                | TypesShapeType.Shape -> "shape"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "geo_shape" -> TypesShapeType.GeoShape
            | "shape" -> TypesShapeType.Shape
            | s -> failwith $"Unknown TypesShapeType: {s}"

    and [<JsonConverter(typeof<TypesShapeTypeConverter>)>]
        TypesShapeType =
        | GeoShape
        | Shape
        with
        override this.ToString() =
            match this with
            | GeoShape -> "geo_shape"
            | Shape -> "shape"

    and TypesCircleProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("error_distance")>]
        ErrorDistance: float
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("shape_type")>]
        ShapeType: TypesShapeType
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesCommunityIDProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("source_ip")>]
        SourceIp: Field option
        [<JsonPropertyName("source_port")>]
        SourcePort: Field option
        [<JsonPropertyName("destination_ip")>]
        DestinationIp: Field option
        [<JsonPropertyName("destination_port")>]
        DestinationPort: Field option
        [<JsonPropertyName("iana_number")>]
        IanaNumber: Field option
        [<JsonPropertyName("icmp_type")>]
        IcmpType: Field option
        [<JsonPropertyName("icmp_code")>]
        IcmpCode: Field option
        [<JsonPropertyName("transport")>]
        Transport: Field option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("seed")>]
        Seed: float option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesConvertTypeConverter() =
        inherit JsonConverter<TypesConvertType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConvertType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConvertType.Integer -> "integer"
                | TypesConvertType.Long -> "long"
                | TypesConvertType.Double -> "double"
                | TypesConvertType.Float -> "float"
                | TypesConvertType.Boolean -> "boolean"
                | TypesConvertType.Ip -> "ip"
                | TypesConvertType.String -> "string"
                | TypesConvertType.Auto -> "auto"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "integer" -> TypesConvertType.Integer
            | "long" -> TypesConvertType.Long
            | "double" -> TypesConvertType.Double
            | "float" -> TypesConvertType.Float
            | "boolean" -> TypesConvertType.Boolean
            | "ip" -> TypesConvertType.Ip
            | "string" -> TypesConvertType.String
            | "auto" -> TypesConvertType.Auto
            | s -> failwith $"Unknown TypesConvertType: {s}"

    and [<JsonConverter(typeof<TypesConvertTypeConverter>)>]
        TypesConvertType =
        | Integer
        | Long
        | Double
        | Float
        | Boolean
        | Ip
        | String
        | Auto
        with
        override this.ToString() =
            match this with
            | Integer -> "integer"
            | Long -> "long"
            | Double -> "double"
            | Float -> "float"
            | Boolean -> "boolean"
            | Ip -> "ip"
            | String -> "string"
            | Auto -> "auto"

    and TypesConvertProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("type")>]
        Type: TypesConvertType
    }

    and TypesCsvProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("empty_value")>]
        EmptyValue: obj option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("quote")>]
        Quote: string option
        [<JsonPropertyName("separator")>]
        Separator: string option
        [<JsonPropertyName("target_fields")>]
        TargetFields: Fields
        [<JsonPropertyName("trim")>]
        Trim: bool option
    }

    and TypesDateIndexNameProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("date_formats")>]
        DateFormats: string array option
        [<JsonPropertyName("date_rounding")>]
        DateRounding: string
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("index_name_format")>]
        IndexNameFormat: string option
        [<JsonPropertyName("index_name_prefix")>]
        IndexNamePrefix: string option
        [<JsonPropertyName("locale")>]
        Locale: string option
        [<JsonPropertyName("timezone")>]
        Timezone: string option
    }

    and TypesDateProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("formats")>]
        Formats: string array
        [<JsonPropertyName("locale")>]
        Locale: string option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("timezone")>]
        Timezone: string option
        [<JsonPropertyName("output_format")>]
        OutputFormat: string option
    }

    and TypesDissectProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("append_separator")>]
        AppendSeparator: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("pattern")>]
        Pattern: string
    }

    and TypesDotExpanderProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("override")>]
        Override: bool option
        [<JsonPropertyName("path")>]
        Path: string option
    }

    and TypesDropProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
    }

    and GeoShapeRelationConverter() =
        inherit JsonConverter<GeoShapeRelation>()

        override _.Write(writer: Utf8JsonWriter, value: GeoShapeRelation, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GeoShapeRelation.Intersects -> "intersects"
                | GeoShapeRelation.Disjoint -> "disjoint"
                | GeoShapeRelation.Within -> "within"
                | GeoShapeRelation.Contains -> "contains"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "intersects" -> GeoShapeRelation.Intersects
            | "disjoint" -> GeoShapeRelation.Disjoint
            | "within" -> GeoShapeRelation.Within
            | "contains" -> GeoShapeRelation.Contains
            | s -> failwith $"Unknown GeoShapeRelation: {s}"

    and [<JsonConverter(typeof<GeoShapeRelationConverter>)>]
        GeoShapeRelation =
        | Intersects
        | Disjoint
        | Within
        | Contains
        with
        override this.ToString() =
            match this with
            | Intersects -> "intersects"
            | Disjoint -> "disjoint"
            | Within -> "within"
            | Contains -> "contains"

    and TypesEnrichProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("max_matches")>]
        MaxMatches: float option
        [<JsonPropertyName("override")>]
        Override: bool option
        [<JsonPropertyName("policy_name")>]
        PolicyName: string
        [<JsonPropertyName("shape_relation")>]
        ShapeRelation: GeoShapeRelation option
        [<JsonPropertyName("target_field")>]
        TargetField: Field
    }

    and TypesFailProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("message")>]
        Message: string
    }

    and TypesFingerprintDigestConverter() =
        inherit JsonConverter<TypesFingerprintDigest>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFingerprintDigest, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFingerprintDigest.MD5 -> "MD5"
                | TypesFingerprintDigest.SHA1 -> "SHA_1"
                | TypesFingerprintDigest.SHA256 -> "SHA_256"
                | TypesFingerprintDigest.SHA512 -> "SHA_512"
                | TypesFingerprintDigest.MurmurHash3 -> "MurmurHash3"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "MD5" -> TypesFingerprintDigest.MD5
            | "SHA_1" -> TypesFingerprintDigest.SHA1
            | "SHA_256" -> TypesFingerprintDigest.SHA256
            | "SHA_512" -> TypesFingerprintDigest.SHA512
            | "MurmurHash3" -> TypesFingerprintDigest.MurmurHash3
            | s -> failwith $"Unknown TypesFingerprintDigest: {s}"

    and [<JsonConverter(typeof<TypesFingerprintDigestConverter>)>]
        TypesFingerprintDigest =
        | MD5
        | SHA1
        | SHA256
        | SHA512
        | MurmurHash3
        with
        override this.ToString() =
            match this with
            | MD5 -> "MD5"
            | SHA1 -> "SHA_1"
            | SHA256 -> "SHA_256"
            | SHA512 -> "SHA_512"
            | MurmurHash3 -> "MurmurHash3"

    and TypesFingerprintProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("fields")>]
        Fields: Fields
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("salt")>]
        Salt: string option
        [<JsonPropertyName("method")>]
        Method: TypesFingerprintDigest option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesForeachProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("processor")>]
        Processor: TypesProcessorContainer
    }

    and TypesGeoGridTargetFormatConverter() =
        inherit JsonConverter<TypesGeoGridTargetFormat>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGeoGridTargetFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGeoGridTargetFormat.Geojson -> "geojson"
                | TypesGeoGridTargetFormat.Wkt -> "wkt"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "geojson" -> TypesGeoGridTargetFormat.Geojson
            | "wkt" -> TypesGeoGridTargetFormat.Wkt
            | s -> failwith $"Unknown TypesGeoGridTargetFormat: {s}"

    and [<JsonConverter(typeof<TypesGeoGridTargetFormatConverter>)>]
        TypesGeoGridTargetFormat =
        | Geojson
        | Wkt
        with
        override this.ToString() =
            match this with
            | Geojson -> "geojson"
            | Wkt -> "wkt"

    and TypesGeoGridTileTypeConverter() =
        inherit JsonConverter<TypesGeoGridTileType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGeoGridTileType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGeoGridTileType.Geotile -> "geotile"
                | TypesGeoGridTileType.Geohex -> "geohex"
                | TypesGeoGridTileType.Geohash -> "geohash"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "geotile" -> TypesGeoGridTileType.Geotile
            | "geohex" -> TypesGeoGridTileType.Geohex
            | "geohash" -> TypesGeoGridTileType.Geohash
            | s -> failwith $"Unknown TypesGeoGridTileType: {s}"

    and [<JsonConverter(typeof<TypesGeoGridTileTypeConverter>)>]
        TypesGeoGridTileType =
        | Geotile
        | Geohex
        | Geohash
        with
        override this.ToString() =
            match this with
            | Geotile -> "geotile"
            | Geohex -> "geohex"
            | Geohash -> "geohash"

    and TypesGeoGridProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("tile_type")>]
        TileType: TypesGeoGridTileType
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("parent_field")>]
        ParentField: Field option
        [<JsonPropertyName("children_field")>]
        ChildrenField: Field option
        [<JsonPropertyName("non_children_field")>]
        NonChildrenField: Field option
        [<JsonPropertyName("precision_field")>]
        PrecisionField: Field option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_format")>]
        TargetFormat: TypesGeoGridTargetFormat option
    }

    and TypesGeoIpProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("database_file")>]
        DatabaseFile: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("first_only")>]
        FirstOnly: bool option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("properties")>]
        Properties: string array option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("download_database_on_pipeline_creation")>]
        DownloadDatabaseOnPipelineCreation: bool option
    }

    and GrokPattern = string

    and TypesGrokProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("ecs_compatibility")>]
        EcsCompatibility: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("pattern_definitions")>]
        PatternDefinitions: Map<string, string> option
        [<JsonPropertyName("patterns")>]
        Patterns: GrokPattern array
        [<JsonPropertyName("trace_match")>]
        TraceMatch: bool option
    }

    and TypesGsubProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("pattern")>]
        Pattern: string
        [<JsonPropertyName("replacement")>]
        Replacement: string
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesHtmlStripProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesInferenceConfigClassification = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
        [<JsonPropertyName("results_field")>]
        ResultsField: Field option
        [<JsonPropertyName("top_classes_results_field")>]
        TopClassesResultsField: Field option
        [<JsonPropertyName("prediction_field_type")>]
        PredictionFieldType: string option
    }

    and TypesInferenceConfigRegression = {
        [<JsonPropertyName("results_field")>]
        ResultsField: Field option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
    }

    and TypesInferenceConfig = {
        [<JsonPropertyName("regression")>]
        Regression: TypesInferenceConfigRegression option
        [<JsonPropertyName("classification")>]
        Classification: TypesInferenceConfigClassification option
    }

    and TypesInputConfig = {
        [<JsonPropertyName("input_field")>]
        InputField: string
        [<JsonPropertyName("output_field")>]
        OutputField: string
    }

    and TypesInferenceProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("model_id")>]
        ModelId: Id
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("field_map")>]
        FieldMap: Map<string, obj> option
        [<JsonPropertyName("inference_config")>]
        InferenceConfig: TypesInferenceConfig option
        [<JsonPropertyName("input_output")>]
        InputOutput: System.Text.Json.JsonElement option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesIpLocationProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("database_file")>]
        DatabaseFile: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("first_only")>]
        FirstOnly: bool option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("properties")>]
        Properties: string array option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("download_database_on_pipeline_creation")>]
        DownloadDatabaseOnPipelineCreation: bool option
    }

    and TypesJoinProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("separator")>]
        Separator: string
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesJsonProcessorConflictStrategyConverter() =
        inherit JsonConverter<TypesJsonProcessorConflictStrategy>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJsonProcessorConflictStrategy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJsonProcessorConflictStrategy.Replace -> "replace"
                | TypesJsonProcessorConflictStrategy.Merge -> "merge"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "replace" -> TypesJsonProcessorConflictStrategy.Replace
            | "merge" -> TypesJsonProcessorConflictStrategy.Merge
            | s -> failwith $"Unknown TypesJsonProcessorConflictStrategy: {s}"

    and [<JsonConverter(typeof<TypesJsonProcessorConflictStrategyConverter>)>]
        TypesJsonProcessorConflictStrategy =
        | Replace
        | Merge
        with
        override this.ToString() =
            match this with
            | Replace -> "replace"
            | Merge -> "merge"

    and TypesJsonProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("add_to_root")>]
        AddToRoot: bool option
        [<JsonPropertyName("add_to_root_conflict_strategy")>]
        AddToRootConflictStrategy: TypesJsonProcessorConflictStrategy option
        [<JsonPropertyName("allow_duplicate_keys")>]
        AllowDuplicateKeys: bool option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesKeyValueProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("exclude_keys")>]
        ExcludeKeys: string array option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("field_split")>]
        FieldSplit: string
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("include_keys")>]
        IncludeKeys: string array option
        [<JsonPropertyName("prefix")>]
        Prefix: string option
        [<JsonPropertyName("strip_brackets")>]
        StripBrackets: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("trim_key")>]
        TrimKey: string option
        [<JsonPropertyName("trim_value")>]
        TrimValue: string option
        [<JsonPropertyName("value_split")>]
        ValueSplit: string
    }

    and TypesLowercaseProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesNetworkDirectionProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("source_ip")>]
        SourceIp: Field option
        [<JsonPropertyName("destination_ip")>]
        DestinationIp: Field option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("internal_networks")>]
        InternalNetworks: string array option
        [<JsonPropertyName("internal_networks_field")>]
        InternalNetworksField: Field option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesPipelineProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("ignore_missing_pipeline")>]
        IgnoreMissingPipeline: bool option
    }

    and TypesRedactProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("patterns")>]
        Patterns: GrokPattern array
        [<JsonPropertyName("pattern_definitions")>]
        PatternDefinitions: Map<string, string> option
        [<JsonPropertyName("prefix")>]
        Prefix: string option
        [<JsonPropertyName("suffix")>]
        Suffix: string option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("skip_if_unlicensed")>]
        SkipIfUnlicensed: bool option
        [<JsonPropertyName("trace_redact")>]
        TraceRedact: bool option
    }

    and TypesRegisteredDomainProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesRemoveProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Fields
        [<JsonPropertyName("keep")>]
        Keep: Fields option
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
    }

    and TypesRenameProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field
    }

    and TypesRerouteProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("destination")>]
        Destination: string option
        [<JsonPropertyName("dataset")>]
        Dataset: System.Text.Json.JsonElement option
        [<JsonPropertyName("namespace")>]
        Namespace: System.Text.Json.JsonElement option
    }

    and TypesScriptProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("lang")>]
        Lang: ScriptLanguage option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("source")>]
        Source: ScriptSource option
    }

    and TypesSetProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("copy_from")>]
        CopyFrom: Field option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_empty_value")>]
        IgnoreEmptyValue: bool option
        [<JsonPropertyName("media_type")>]
        MediaType: string option
        [<JsonPropertyName("override")>]
        Override: bool option
        [<JsonPropertyName("value")>]
        Value: obj option
    }

    and TypesSetSecurityUserProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("properties")>]
        Properties: string array option
    }

    and TypesSortProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("order")>]
        Order: SortOrder option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesSplitProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("preserve_trailing")>]
        PreserveTrailing: bool option
        [<JsonPropertyName("separator")>]
        Separator: string
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesTerminateProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
    }

    and TypesTrimProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesUppercaseProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesUriPartsProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("keep_original")>]
        KeepOriginal: bool option
        [<JsonPropertyName("remove_if_successful")>]
        RemoveIfSuccessful: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesUrlDecodeProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
    }

    and TypesUserAgentPropertyConverter() =
        inherit JsonConverter<TypesUserAgentProperty>()

        override _.Write(writer: Utf8JsonWriter, value: TypesUserAgentProperty, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesUserAgentProperty.Name -> "name"
                | TypesUserAgentProperty.Os -> "os"
                | TypesUserAgentProperty.Device -> "device"
                | TypesUserAgentProperty.Original -> "original"
                | TypesUserAgentProperty.Version -> "version"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "name" -> TypesUserAgentProperty.Name
            | "os" -> TypesUserAgentProperty.Os
            | "device" -> TypesUserAgentProperty.Device
            | "original" -> TypesUserAgentProperty.Original
            | "version" -> TypesUserAgentProperty.Version
            | s -> failwith $"Unknown TypesUserAgentProperty: {s}"

    and [<JsonConverter(typeof<TypesUserAgentPropertyConverter>)>]
        TypesUserAgentProperty =
        | Name
        | Os
        | Device
        | Original
        | Version
        with
        override this.ToString() =
            match this with
            | Name -> "name"
            | Os -> "os"
            | Device -> "device"
            | Original -> "original"
            | Version -> "version"

    and TypesUserAgentProcessor = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("if")>]
        If: Script option
        [<JsonPropertyName("ignore_failure")>]
        IgnoreFailure: bool option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("ignore_missing")>]
        IgnoreMissing: bool option
        [<JsonPropertyName("regex_file")>]
        RegexFile: string option
        [<JsonPropertyName("target_field")>]
        TargetField: Field option
        [<JsonPropertyName("properties")>]
        Properties: TypesUserAgentProperty array option
        [<JsonPropertyName("extract_device_type")>]
        ExtractDeviceType: bool option
    }

    and TypesProcessorContainer = {
        [<JsonPropertyName("append")>]
        Append: TypesAppendProcessor option
        [<JsonPropertyName("attachment")>]
        Attachment: TypesAttachmentProcessor option
        [<JsonPropertyName("bytes")>]
        Bytes: TypesBytesProcessor option
        [<JsonPropertyName("circle")>]
        Circle: TypesCircleProcessor option
        [<JsonPropertyName("community_id")>]
        CommunityId: TypesCommunityIDProcessor option
        [<JsonPropertyName("convert")>]
        Convert: TypesConvertProcessor option
        [<JsonPropertyName("csv")>]
        Csv: TypesCsvProcessor option
        [<JsonPropertyName("date")>]
        Date: TypesDateProcessor option
        [<JsonPropertyName("date_index_name")>]
        DateIndexName: TypesDateIndexNameProcessor option
        [<JsonPropertyName("dissect")>]
        Dissect: TypesDissectProcessor option
        [<JsonPropertyName("dot_expander")>]
        DotExpander: TypesDotExpanderProcessor option
        [<JsonPropertyName("drop")>]
        Drop: TypesDropProcessor option
        [<JsonPropertyName("enrich")>]
        Enrich: TypesEnrichProcessor option
        [<JsonPropertyName("fail")>]
        Fail: TypesFailProcessor option
        [<JsonPropertyName("fingerprint")>]
        Fingerprint: TypesFingerprintProcessor option
        [<JsonPropertyName("foreach")>]
        Foreach: TypesForeachProcessor option
        [<JsonPropertyName("ip_location")>]
        IpLocation: TypesIpLocationProcessor option
        [<JsonPropertyName("geo_grid")>]
        GeoGrid: TypesGeoGridProcessor option
        [<JsonPropertyName("geoip")>]
        Geoip: TypesGeoIpProcessor option
        [<JsonPropertyName("grok")>]
        Grok: TypesGrokProcessor option
        [<JsonPropertyName("gsub")>]
        Gsub: TypesGsubProcessor option
        [<JsonPropertyName("html_strip")>]
        HtmlStrip: TypesHtmlStripProcessor option
        [<JsonPropertyName("inference")>]
        Inference: TypesInferenceProcessor option
        [<JsonPropertyName("join")>]
        Join: TypesJoinProcessor option
        [<JsonPropertyName("json")>]
        Json: TypesJsonProcessor option
        [<JsonPropertyName("kv")>]
        Kv: TypesKeyValueProcessor option
        [<JsonPropertyName("lowercase")>]
        Lowercase: TypesLowercaseProcessor option
        [<JsonPropertyName("network_direction")>]
        NetworkDirection: TypesNetworkDirectionProcessor option
        [<JsonPropertyName("pipeline")>]
        Pipeline: TypesPipelineProcessor option
        [<JsonPropertyName("redact")>]
        Redact: TypesRedactProcessor option
        [<JsonPropertyName("registered_domain")>]
        RegisteredDomain: TypesRegisteredDomainProcessor option
        [<JsonPropertyName("remove")>]
        Remove: TypesRemoveProcessor option
        [<JsonPropertyName("rename")>]
        Rename: TypesRenameProcessor option
        [<JsonPropertyName("reroute")>]
        Reroute: TypesRerouteProcessor option
        [<JsonPropertyName("script")>]
        Script: TypesScriptProcessor option
        [<JsonPropertyName("set")>]
        Set: TypesSetProcessor option
        [<JsonPropertyName("set_security_user")>]
        SetSecurityUser: TypesSetSecurityUserProcessor option
        [<JsonPropertyName("sort")>]
        Sort: TypesSortProcessor option
        [<JsonPropertyName("split")>]
        Split: TypesSplitProcessor option
        [<JsonPropertyName("terminate")>]
        Terminate: TypesTerminateProcessor option
        [<JsonPropertyName("trim")>]
        Trim: TypesTrimProcessor option
        [<JsonPropertyName("uppercase")>]
        Uppercase: TypesUppercaseProcessor option
        [<JsonPropertyName("urldecode")>]
        Urldecode: TypesUrlDecodeProcessor option
        [<JsonPropertyName("uri_parts")>]
        UriParts: TypesUriPartsProcessor option
        [<JsonPropertyName("user_agent")>]
        UserAgent: TypesUserAgentProcessor option
    }

    and TypesPipeline = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("on_failure")>]
        OnFailure: TypesProcessorContainer array option
        [<JsonPropertyName("processors")>]
        Processors: TypesProcessorContainer array option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("deprecated")>]
        Deprecated: bool option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
        [<JsonPropertyName("created_date")>]
        CreatedDate: DateTime option
        [<JsonPropertyName("created_date_millis")>]
        CreatedDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: DateTime option
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("field_access_pattern")>]
        FieldAccessPattern: TypesFieldAccessPattern option
    }

    and TypesDocument = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("_source")>]
        Source: obj
    }

    /// <summary>
    /// Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
    /// is used to capture this behavior while keeping the semantics of the field type.
    /// </summary>
    and StringifiedVersionNumber = obj

    /// <summary>
    /// The simulated document, with optional metadata.
    /// </summary>
    and TypesDocumentSimulation = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_ingest")>]
        Ingest: System.Text.Json.JsonElement
        [<JsonPropertyName("_routing")>]
        Routing: string option
        [<JsonPropertyName("_source")>]
        Source: Map<string, obj>
        [<JsonPropertyName("_version")>]
        Version: StringifiedVersionNumber option
        [<JsonPropertyName("_version_type")>]
        VersionType: VersionType option
    }

    and TypesPipelineSimulationStatusOptionsConverter() =
        inherit JsonConverter<TypesPipelineSimulationStatusOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesPipelineSimulationStatusOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesPipelineSimulationStatusOptions.Success -> "success"
                | TypesPipelineSimulationStatusOptions.Error -> "error"
                | TypesPipelineSimulationStatusOptions.ErrorIgnored -> "error_ignored"
                | TypesPipelineSimulationStatusOptions.Skipped -> "skipped"
                | TypesPipelineSimulationStatusOptions.Dropped -> "dropped"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "success" -> TypesPipelineSimulationStatusOptions.Success
            | "error" -> TypesPipelineSimulationStatusOptions.Error
            | "error_ignored" -> TypesPipelineSimulationStatusOptions.ErrorIgnored
            | "skipped" -> TypesPipelineSimulationStatusOptions.Skipped
            | "dropped" -> TypesPipelineSimulationStatusOptions.Dropped
            | s -> failwith $"Unknown TypesPipelineSimulationStatusOptions: {s}"

    and [<JsonConverter(typeof<TypesPipelineSimulationStatusOptionsConverter>)>]
        TypesPipelineSimulationStatusOptions =
        | Success
        | Error
        | ErrorIgnored
        | Skipped
        | Dropped
        with
        override this.ToString() =
            match this with
            | Success -> "success"
            | Error -> "error"
            | ErrorIgnored -> "error_ignored"
            | Skipped -> "skipped"
            | Dropped -> "dropped"

    and TypesPipelineProcessorResult = {
        [<JsonPropertyName("doc")>]
        Doc: TypesDocumentSimulation option
        [<JsonPropertyName("tag")>]
        Tag: string option
        [<JsonPropertyName("processor_type")>]
        ProcessorType: string option
        [<JsonPropertyName("status")>]
        Status: TypesPipelineSimulationStatusOptions option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("ignored_error")>]
        IgnoredError: ErrorCause option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
    }

    and TypesSimulateDocumentResult = {
        [<JsonPropertyName("doc")>]
        Doc: TypesDocumentSimulation option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
        [<JsonPropertyName("processor_results")>]
        ProcessorResults: TypesPipelineProcessorResult array option
    }

    and TypesRedact = {
        [<JsonPropertyName("_is_redacted")>]
        IsRedacted: bool
    }

    and TypesLicenseStatusConverter() =
        inherit JsonConverter<TypesLicenseStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesLicenseStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesLicenseStatus.Active -> "active"
                | TypesLicenseStatus.Valid -> "valid"
                | TypesLicenseStatus.Invalid -> "invalid"
                | TypesLicenseStatus.Expired -> "expired"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "active" -> TypesLicenseStatus.Active
            | "valid" -> TypesLicenseStatus.Valid
            | "invalid" -> TypesLicenseStatus.Invalid
            | "expired" -> TypesLicenseStatus.Expired
            | s -> failwith $"Unknown TypesLicenseStatus: {s}"

    and [<JsonConverter(typeof<TypesLicenseStatusConverter>)>]
        TypesLicenseStatus =
        | Active
        | Valid
        | Invalid
        | Expired
        with
        override this.ToString() =
            match this with
            | Active -> "active"
            | Valid -> "valid"
            | Invalid -> "invalid"
            | Expired -> "expired"

    and TypesLicenseTypeConverter() =
        inherit JsonConverter<TypesLicenseType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesLicenseType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesLicenseType.Missing -> "missing"
                | TypesLicenseType.Trial -> "trial"
                | TypesLicenseType.Basic -> "basic"
                | TypesLicenseType.Standard -> "standard"
                | TypesLicenseType.Dev -> "dev"
                | TypesLicenseType.Silver -> "silver"
                | TypesLicenseType.Gold -> "gold"
                | TypesLicenseType.Platinum -> "platinum"
                | TypesLicenseType.Enterprise -> "enterprise"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "missing" -> TypesLicenseType.Missing
            | "trial" -> TypesLicenseType.Trial
            | "basic" -> TypesLicenseType.Basic
            | "standard" -> TypesLicenseType.Standard
            | "dev" -> TypesLicenseType.Dev
            | "silver" -> TypesLicenseType.Silver
            | "gold" -> TypesLicenseType.Gold
            | "platinum" -> TypesLicenseType.Platinum
            | "enterprise" -> TypesLicenseType.Enterprise
            | s -> failwith $"Unknown TypesLicenseType: {s}"

    and [<JsonConverter(typeof<TypesLicenseTypeConverter>)>]
        TypesLicenseType =
        | Missing
        | Trial
        | Basic
        | Standard
        | Dev
        | Silver
        | Gold
        | Platinum
        | Enterprise
        with
        override this.ToString() =
            match this with
            | Missing -> "missing"
            | Trial -> "trial"
            | Basic -> "basic"
            | Standard -> "standard"
            | Dev -> "dev"
            | Silver -> "silver"
            | Gold -> "gold"
            | Platinum -> "platinum"
            | Enterprise -> "enterprise"

    and GetLicenseInformation = {
        [<JsonPropertyName("expiry_date")>]
        ExpiryDate: DateTime option
        [<JsonPropertyName("expiry_date_in_millis")>]
        ExpiryDateInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("issue_date")>]
        IssueDate: DateTime
        [<JsonPropertyName("issue_date_in_millis")>]
        IssueDateInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("issued_to")>]
        IssuedTo: string
        [<JsonPropertyName("issuer")>]
        Issuer: string
        [<JsonPropertyName("max_nodes")>]
        MaxNodes: System.Text.Json.JsonElement
        [<JsonPropertyName("max_resource_units")>]
        MaxResourceUnits: System.Text.Json.JsonElement option
        [<JsonPropertyName("status")>]
        Status: TypesLicenseStatus
        [<JsonPropertyName("type")>]
        Type: TypesLicenseType
        [<JsonPropertyName("uid")>]
        Uid: Uuid
        [<JsonPropertyName("start_date_in_millis")>]
        StartDateInMillis: EpochTimeUnitMillis
    }

    and TypesLicense = {
        [<JsonPropertyName("expiry_date_in_millis")>]
        ExpiryDateInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("issue_date_in_millis")>]
        IssueDateInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("start_date_in_millis")>]
        StartDateInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("issued_to")>]
        IssuedTo: string
        [<JsonPropertyName("issuer")>]
        Issuer: string
        [<JsonPropertyName("max_nodes")>]
        MaxNodes: System.Text.Json.JsonElement option
        [<JsonPropertyName("max_resource_units")>]
        MaxResourceUnits: float option
        [<JsonPropertyName("signature")>]
        Signature: string
        [<JsonPropertyName("type")>]
        Type: TypesLicenseType
        [<JsonPropertyName("uid")>]
        Uid: string
    }

    and PostAcknowledgement = {
        [<JsonPropertyName("license")>]
        License: string array
        [<JsonPropertyName("message")>]
        Message: string
    }

    and TypesPipelineMetadata = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("version")>]
        Version: string
    }

    and TypesPipelineSettings = {
        [<JsonPropertyName("pipeline.workers")>]
        PipelineWorkers: float
        [<JsonPropertyName("pipeline.batch.size")>]
        PipelineBatchSize: float
        [<JsonPropertyName("pipeline.batch.delay")>]
        PipelineBatchDelay: float
        [<JsonPropertyName("queue.type")>]
        QueueType: string
        [<JsonPropertyName("queue.max_bytes")>]
        QueueMaxBytes: string
        [<JsonPropertyName("queue.checkpoint.writes")>]
        QueueCheckpointWrites: float
    }

    and MgetOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("stored_fields")>]
        StoredFields: Fields option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and MgetMultiGetError = {
        [<JsonPropertyName("error")>]
        Error: ErrorCause
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
    }

    and MgetResponseItem = obj

    and DeprecationsDeprecationLevelConverter() =
        inherit JsonConverter<DeprecationsDeprecationLevel>()

        override _.Write(writer: Utf8JsonWriter, value: DeprecationsDeprecationLevel, _options: JsonSerializerOptions) =
            let str =
                match value with
                | DeprecationsDeprecationLevel.None -> "none"
                | DeprecationsDeprecationLevel.Info -> "info"
                | DeprecationsDeprecationLevel.Warning -> "warning"
                | DeprecationsDeprecationLevel.Critical -> "critical"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "none" -> DeprecationsDeprecationLevel.None
            | "info" -> DeprecationsDeprecationLevel.Info
            | "warning" -> DeprecationsDeprecationLevel.Warning
            | "critical" -> DeprecationsDeprecationLevel.Critical
            | s -> failwith $"Unknown DeprecationsDeprecationLevel: {s}"

    and [<JsonConverter(typeof<DeprecationsDeprecationLevelConverter>)>]
        DeprecationsDeprecationLevel =
        | None
        | Info
        | Warning
        | Critical
        with
        override this.ToString() =
            match this with
            | None -> "none"
            | Info -> "info"
            | Warning -> "warning"
            | Critical -> "critical"

    and DeprecationsDeprecation = {
        [<JsonPropertyName("details")>]
        Details: string option
        [<JsonPropertyName("level")>]
        Level: DeprecationsDeprecationLevel
        [<JsonPropertyName("message")>]
        Message: string
        [<JsonPropertyName("url")>]
        Url: string
        [<JsonPropertyName("resolve_during_rolling_upgrade")>]
        ResolveDuringRollingUpgrade: bool
        [<JsonPropertyName("_meta")>]
        Meta: Map<string, obj> option
    }

    and GetFeatureUpgradeStatusMigrationFeatureIndexInfo = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("failure_cause")>]
        FailureCause: ErrorCause option
    }

    and GetFeatureUpgradeStatusMigrationStatusConverter() =
        inherit JsonConverter<GetFeatureUpgradeStatusMigrationStatus>()

        override _.Write(writer: Utf8JsonWriter, value: GetFeatureUpgradeStatusMigrationStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GetFeatureUpgradeStatusMigrationStatus.NOMIGRATIONNEEDED -> "NO_MIGRATION_NEEDED"
                | GetFeatureUpgradeStatusMigrationStatus.MIGRATIONNEEDED -> "MIGRATION_NEEDED"
                | GetFeatureUpgradeStatusMigrationStatus.INPROGRESS -> "IN_PROGRESS"
                | GetFeatureUpgradeStatusMigrationStatus.ERROR -> "ERROR"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "NO_MIGRATION_NEEDED" -> GetFeatureUpgradeStatusMigrationStatus.NOMIGRATIONNEEDED
            | "MIGRATION_NEEDED" -> GetFeatureUpgradeStatusMigrationStatus.MIGRATIONNEEDED
            | "IN_PROGRESS" -> GetFeatureUpgradeStatusMigrationStatus.INPROGRESS
            | "ERROR" -> GetFeatureUpgradeStatusMigrationStatus.ERROR
            | s -> failwith $"Unknown GetFeatureUpgradeStatusMigrationStatus: {s}"

    and [<JsonConverter(typeof<GetFeatureUpgradeStatusMigrationStatusConverter>)>]
        GetFeatureUpgradeStatusMigrationStatus =
        | NOMIGRATIONNEEDED
        | MIGRATIONNEEDED
        | INPROGRESS
        | ERROR
        with
        override this.ToString() =
            match this with
            | NOMIGRATIONNEEDED -> "NO_MIGRATION_NEEDED"
            | MIGRATIONNEEDED -> "MIGRATION_NEEDED"
            | INPROGRESS -> "IN_PROGRESS"
            | ERROR -> "ERROR"

    and GetFeatureUpgradeStatusMigrationFeature = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("minimum_index_version")>]
        MinimumIndexVersion: VersionString
        [<JsonPropertyName("migration_status")>]
        MigrationStatus: GetFeatureUpgradeStatusMigrationStatus
        [<JsonPropertyName("indices")>]
        Indices: GetFeatureUpgradeStatusMigrationFeatureIndexInfo array
    }

    and PostFeatureUpgradeMigrationFeature = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
    }

    and TypesCategorizationAnalyzerDefinition = {
        [<JsonPropertyName("char_filter")>]
        CharFilter: AnalysisCharFilter array option
        [<JsonPropertyName("filter")>]
        Filter: AnalysisTokenFilter array option
        [<JsonPropertyName("tokenizer")>]
        Tokenizer: System.Text.Json.JsonElement option
    }

    and TypesCategorizationAnalyzer = obj

    and TypesFilterTypeConverter() =
        inherit JsonConverter<TypesFilterType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFilterType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFilterType.Include -> "include"
                | TypesFilterType.Exclude -> "exclude"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "include" -> TypesFilterType.Include
            | "exclude" -> TypesFilterType.Exclude
            | s -> failwith $"Unknown TypesFilterType: {s}"

    and [<JsonConverter(typeof<TypesFilterTypeConverter>)>]
        TypesFilterType =
        | Include
        | Exclude
        with
        override this.ToString() =
            match this with
            | Include -> "include"
            | Exclude -> "exclude"

    and TypesFilterRef = {
        [<JsonPropertyName("filter_id")>]
        FilterId: Id
        [<JsonPropertyName("filter_type")>]
        FilterType: TypesFilterType option
    }

    and TypesRuleActionConverter() =
        inherit JsonConverter<TypesRuleAction>()

        override _.Write(writer: Utf8JsonWriter, value: TypesRuleAction, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesRuleAction.SkipResult -> "skip_result"
                | TypesRuleAction.SkipModelUpdate -> "skip_model_update"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "skip_result" -> TypesRuleAction.SkipResult
            | "skip_model_update" -> TypesRuleAction.SkipModelUpdate
            | s -> failwith $"Unknown TypesRuleAction: {s}"

    and [<JsonConverter(typeof<TypesRuleActionConverter>)>]
        TypesRuleAction =
        | SkipResult
        | SkipModelUpdate
        with
        override this.ToString() =
            match this with
            | SkipResult -> "skip_result"
            | SkipModelUpdate -> "skip_model_update"

    and TypesAppliesToConverter() =
        inherit JsonConverter<TypesAppliesTo>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAppliesTo, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAppliesTo.Actual -> "actual"
                | TypesAppliesTo.Typical -> "typical"
                | TypesAppliesTo.DiffFromTypical -> "diff_from_typical"
                | TypesAppliesTo.Time -> "time"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "actual" -> TypesAppliesTo.Actual
            | "typical" -> TypesAppliesTo.Typical
            | "diff_from_typical" -> TypesAppliesTo.DiffFromTypical
            | "time" -> TypesAppliesTo.Time
            | s -> failwith $"Unknown TypesAppliesTo: {s}"

    and [<JsonConverter(typeof<TypesAppliesToConverter>)>]
        TypesAppliesTo =
        | Actual
        | Typical
        | DiffFromTypical
        | Time
        with
        override this.ToString() =
            match this with
            | Actual -> "actual"
            | Typical -> "typical"
            | DiffFromTypical -> "diff_from_typical"
            | Time -> "time"

    and TypesConditionOperatorConverter() =
        inherit JsonConverter<TypesConditionOperator>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConditionOperator, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConditionOperator.Gt -> "gt"
                | TypesConditionOperator.Gte -> "gte"
                | TypesConditionOperator.Lt -> "lt"
                | TypesConditionOperator.Lte -> "lte"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "gt" -> TypesConditionOperator.Gt
            | "gte" -> TypesConditionOperator.Gte
            | "lt" -> TypesConditionOperator.Lt
            | "lte" -> TypesConditionOperator.Lte
            | s -> failwith $"Unknown TypesConditionOperator: {s}"

    and [<JsonConverter(typeof<TypesConditionOperatorConverter>)>]
        TypesConditionOperator =
        | Gt
        | Gte
        | Lt
        | Lte
        with
        override this.ToString() =
            match this with
            | Gt -> "gt"
            | Gte -> "gte"
            | Lt -> "lt"
            | Lte -> "lte"

    and TypesRuleCondition = {
        [<JsonPropertyName("applies_to")>]
        AppliesTo: TypesAppliesTo
        [<JsonPropertyName("operator")>]
        Operator: TypesConditionOperator
        [<JsonPropertyName("value")>]
        Value: float
    }

    and TypesDetectionRule = {
        [<JsonPropertyName("actions")>]
        Actions: TypesRuleAction array option
        [<JsonPropertyName("conditions")>]
        Conditions: TypesRuleCondition array option
        [<JsonPropertyName("scope")>]
        Scope: Map<string, TypesFilterRef> option
    }

    and TypesExcludeFrequentConverter() =
        inherit JsonConverter<TypesExcludeFrequent>()

        override _.Write(writer: Utf8JsonWriter, value: TypesExcludeFrequent, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesExcludeFrequent.All -> "all"
                | TypesExcludeFrequent.None -> "none"
                | TypesExcludeFrequent.By -> "by"
                | TypesExcludeFrequent.Over -> "over"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "all" -> TypesExcludeFrequent.All
            | "none" -> TypesExcludeFrequent.None
            | "by" -> TypesExcludeFrequent.By
            | "over" -> TypesExcludeFrequent.Over
            | s -> failwith $"Unknown TypesExcludeFrequent: {s}"

    and [<JsonConverter(typeof<TypesExcludeFrequentConverter>)>]
        TypesExcludeFrequent =
        | All
        | None
        | By
        | Over
        with
        override this.ToString() =
            match this with
            | All -> "all"
            | None -> "none"
            | By -> "by"
            | Over -> "over"

    and TypesDetector = {
        [<JsonPropertyName("by_field_name")>]
        ByFieldName: Field option
        [<JsonPropertyName("custom_rules")>]
        CustomRules: TypesDetectionRule array option
        [<JsonPropertyName("detector_description")>]
        DetectorDescription: string option
        [<JsonPropertyName("detector_index")>]
        DetectorIndex: float option
        [<JsonPropertyName("exclude_frequent")>]
        ExcludeFrequent: TypesExcludeFrequent option
        [<JsonPropertyName("field_name")>]
        FieldName: Field option
        [<JsonPropertyName("function")>]
        Function: string option
        [<JsonPropertyName("over_field_name")>]
        OverFieldName: Field option
        [<JsonPropertyName("partition_field_name")>]
        PartitionFieldName: Field option
        [<JsonPropertyName("use_null")>]
        UseNull: bool option
    }

    and TypesPerPartitionCategorization = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("stop_on_warn")>]
        StopOnWarn: bool option
    }

    and TypesAnalysisConfig = {
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: Duration option
        [<JsonPropertyName("categorization_analyzer")>]
        CategorizationAnalyzer: TypesCategorizationAnalyzer option
        [<JsonPropertyName("categorization_field_name")>]
        CategorizationFieldName: Field option
        [<JsonPropertyName("categorization_filters")>]
        CategorizationFilters: string array option
        [<JsonPropertyName("detectors")>]
        Detectors: TypesDetector array
        [<JsonPropertyName("influencers")>]
        Influencers: Field array option
        [<JsonPropertyName("latency")>]
        Latency: Duration option
        [<JsonPropertyName("model_prune_window")>]
        ModelPruneWindow: Duration option
        [<JsonPropertyName("multivariate_by_fields")>]
        MultivariateByFields: bool option
        [<JsonPropertyName("per_partition_categorization")>]
        PerPartitionCategorization: TypesPerPartitionCategorization option
        [<JsonPropertyName("summary_count_field_name")>]
        SummaryCountFieldName: Field option
    }

    and TypesDataframeEvaluationClassificationMetricsAucRoc = {
        [<JsonPropertyName("class_name")>]
        ClassName: Name option
        [<JsonPropertyName("include_curve")>]
        IncludeCurve: bool option
    }

    and TypesDataframeEvaluationMetrics = {
        [<JsonPropertyName("auc_roc")>]
        AucRoc: TypesDataframeEvaluationClassificationMetricsAucRoc option
        [<JsonPropertyName("precision")>]
        Precision: Map<string, obj> option
        [<JsonPropertyName("recall")>]
        Recall: Map<string, obj> option
    }

    and TypesDataframeEvaluationClassificationMetrics = {
        [<JsonPropertyName("auc_roc")>]
        AucRoc: TypesDataframeEvaluationClassificationMetricsAucRoc option
        [<JsonPropertyName("precision")>]
        Precision: Map<string, obj> option
        [<JsonPropertyName("recall")>]
        Recall: Map<string, obj> option
        [<JsonPropertyName("accuracy")>]
        Accuracy: Map<string, obj> option
        [<JsonPropertyName("multiclass_confusion_matrix")>]
        MulticlassConfusionMatrix: Map<string, obj> option
    }

    and TypesDataframeEvaluationClassification = {
        [<JsonPropertyName("actual_field")>]
        ActualField: Field
        [<JsonPropertyName("predicted_field")>]
        PredictedField: Field option
        [<JsonPropertyName("top_classes_field")>]
        TopClassesField: Field option
        [<JsonPropertyName("metrics")>]
        Metrics: TypesDataframeEvaluationClassificationMetrics option
    }

    and TypesDataframeEvaluationOutlierDetectionMetrics = {
        [<JsonPropertyName("auc_roc")>]
        AucRoc: TypesDataframeEvaluationClassificationMetricsAucRoc option
        [<JsonPropertyName("precision")>]
        Precision: Map<string, obj> option
        [<JsonPropertyName("recall")>]
        Recall: Map<string, obj> option
        [<JsonPropertyName("confusion_matrix")>]
        ConfusionMatrix: Map<string, obj> option
    }

    and TypesDataframeEvaluationOutlierDetection = {
        [<JsonPropertyName("actual_field")>]
        ActualField: Field
        [<JsonPropertyName("predicted_probability_field")>]
        PredictedProbabilityField: Field
        [<JsonPropertyName("metrics")>]
        Metrics: TypesDataframeEvaluationOutlierDetectionMetrics option
    }

    and TypesDataframeEvaluationRegressionMetricsHuber = {
        [<JsonPropertyName("delta")>]
        Delta: float option
    }

    and TypesDataframeEvaluationRegressionMetricsMsle = {
        [<JsonPropertyName("offset")>]
        Offset: float option
    }

    and TypesDataframeEvaluationRegressionMetrics = {
        [<JsonPropertyName("mse")>]
        Mse: Map<string, obj> option
        [<JsonPropertyName("msle")>]
        Msle: TypesDataframeEvaluationRegressionMetricsMsle option
        [<JsonPropertyName("huber")>]
        Huber: TypesDataframeEvaluationRegressionMetricsHuber option
        [<JsonPropertyName("r_squared")>]
        RSquared: Map<string, obj> option
    }

    and TypesDataframeEvaluationRegression = {
        [<JsonPropertyName("actual_field")>]
        ActualField: Field
        [<JsonPropertyName("predicted_field")>]
        PredictedField: Field
        [<JsonPropertyName("metrics")>]
        Metrics: TypesDataframeEvaluationRegressionMetrics option
    }

    and TypesDataframeEvaluationContainer = {
        [<JsonPropertyName("classification")>]
        Classification: TypesDataframeEvaluationClassification option
        [<JsonPropertyName("outlier_detection")>]
        OutlierDetection: TypesDataframeEvaluationOutlierDetection option
        [<JsonPropertyName("regression")>]
        Regression: TypesDataframeEvaluationRegression option
    }

    and EvaluateDataFrameDataframeEvaluationValue = {
        [<JsonPropertyName("value")>]
        Value: float
    }

    and EvaluateDataFrameDataframeEvaluationClass = {
        [<JsonPropertyName("value")>]
        Value: float
        [<JsonPropertyName("class_name")>]
        ClassName: Name
    }

    and EvaluateDataFrameDataframeClassificationSummaryAccuracy = {
        [<JsonPropertyName("classes")>]
        Classes: EvaluateDataFrameDataframeEvaluationClass array
        [<JsonPropertyName("overall_accuracy")>]
        OverallAccuracy: float
    }

    and EvaluateDataFrameConfusionMatrixPrediction = {
        [<JsonPropertyName("predicted_class")>]
        PredictedClass: Name
        [<JsonPropertyName("count")>]
        Count: float
    }

    and EvaluateDataFrameConfusionMatrixItem = {
        [<JsonPropertyName("actual_class")>]
        ActualClass: Name
        [<JsonPropertyName("actual_class_doc_count")>]
        ActualClassDocCount: float
        [<JsonPropertyName("predicted_classes")>]
        PredictedClasses: EvaluateDataFrameConfusionMatrixPrediction array
        [<JsonPropertyName("other_predicted_class_doc_count")>]
        OtherPredictedClassDocCount: float
    }

    and EvaluateDataFrameDataframeClassificationSummaryMulticlassConfusionMatrix = {
        [<JsonPropertyName("confusion_matrix")>]
        ConfusionMatrix: EvaluateDataFrameConfusionMatrixItem array
        [<JsonPropertyName("other_actual_class_count")>]
        OtherActualClassCount: float
    }

    and EvaluateDataFrameDataframeClassificationSummaryPrecision = {
        [<JsonPropertyName("classes")>]
        Classes: EvaluateDataFrameDataframeEvaluationClass array
        [<JsonPropertyName("avg_precision")>]
        AvgPrecision: float
    }

    and EvaluateDataFrameDataframeClassificationSummaryRecall = {
        [<JsonPropertyName("classes")>]
        Classes: EvaluateDataFrameDataframeEvaluationClass array
        [<JsonPropertyName("avg_recall")>]
        AvgRecall: float
    }

    and EvaluateDataFrameDataframeEvaluationSummaryAucRocCurveItem = {
        [<JsonPropertyName("tpr")>]
        Tpr: float
        [<JsonPropertyName("fpr")>]
        Fpr: float
        [<JsonPropertyName("threshold")>]
        Threshold: float
    }

    and EvaluateDataFrameDataframeEvaluationSummaryAucRoc = {
        [<JsonPropertyName("value")>]
        Value: float
        [<JsonPropertyName("curve")>]
        Curve: EvaluateDataFrameDataframeEvaluationSummaryAucRocCurveItem array option
    }

    and EvaluateDataFrameDataframeClassificationSummary = {
        [<JsonPropertyName("auc_roc")>]
        AucRoc: EvaluateDataFrameDataframeEvaluationSummaryAucRoc option
        [<JsonPropertyName("accuracy")>]
        Accuracy: EvaluateDataFrameDataframeClassificationSummaryAccuracy option
        [<JsonPropertyName("multiclass_confusion_matrix")>]
        MulticlassConfusionMatrix: EvaluateDataFrameDataframeClassificationSummaryMulticlassConfusionMatrix option
        [<JsonPropertyName("precision")>]
        Precision: EvaluateDataFrameDataframeClassificationSummaryPrecision option
        [<JsonPropertyName("recall")>]
        Recall: EvaluateDataFrameDataframeClassificationSummaryRecall option
    }

    and EvaluateDataFrameConfusionMatrixThreshold = {
        [<JsonPropertyName("tp")>]
        Tp: float
        [<JsonPropertyName("fp")>]
        Fp: float
        [<JsonPropertyName("tn")>]
        Tn: float
        [<JsonPropertyName("fn")>]
        Fn: float
    }

    and EvaluateDataFrameDataframeOutlierDetectionSummary = {
        [<JsonPropertyName("auc_roc")>]
        AucRoc: EvaluateDataFrameDataframeEvaluationSummaryAucRoc option
        [<JsonPropertyName("precision")>]
        Precision: Map<string, float> option
        [<JsonPropertyName("recall")>]
        Recall: Map<string, float> option
        [<JsonPropertyName("confusion_matrix")>]
        ConfusionMatrix: Map<string, EvaluateDataFrameConfusionMatrixThreshold> option
    }

    and EvaluateDataFrameDataframeRegressionSummary = {
        [<JsonPropertyName("huber")>]
        Huber: EvaluateDataFrameDataframeEvaluationValue option
        [<JsonPropertyName("mse")>]
        Mse: EvaluateDataFrameDataframeEvaluationValue option
        [<JsonPropertyName("msle")>]
        Msle: EvaluateDataFrameDataframeEvaluationValue option
        [<JsonPropertyName("r_squared")>]
        RSquared: EvaluateDataFrameDataframeEvaluationValue option
    }

    and TypesDataframeAnalysisAnalyzedFields = {
        [<JsonPropertyName("includes")>]
        Includes: string array option
        [<JsonPropertyName("excludes")>]
        Excludes: string array option
    }

    and TypesDataframeAnalyticsSource = {
        [<JsonPropertyName("index")>]
        Index: Indices
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
        [<JsonPropertyName("_source")>]
        Source: TypesDataframeAnalysisAnalyzedFields option
        [<JsonPropertyName("query")>]
        Query: obj option
    }

    and TypesDataframeAnalyticsDestination = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("results_field")>]
        ResultsField: Field option
    }

    and TypesDataframeAnalysisFeatureProcessorFrequencyEncoding = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: Name
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("frequency_map")>]
        FrequencyMap: Map<string, float>
    }

    and TypesDataframeAnalysisFeatureProcessorMultiEncoding = {
        [<JsonPropertyName("processors")>]
        Processors: float array
    }

    and TypesDataframeAnalysisFeatureProcessorNGramEncoding = {
        [<JsonPropertyName("feature_prefix")>]
        FeaturePrefix: string option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("length")>]
        Length: float option
        [<JsonPropertyName("n_grams")>]
        NGrams: float array
        [<JsonPropertyName("start")>]
        Start: float option
        [<JsonPropertyName("custom")>]
        Custom: bool option
    }

    and TypesDataframeAnalysisFeatureProcessorOneHotEncoding = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("hot_map")>]
        HotMap: string
    }

    and TypesDataframeAnalysisFeatureProcessorTargetMeanEncoding = {
        [<JsonPropertyName("default_value")>]
        DefaultValue: float
        [<JsonPropertyName("feature_name")>]
        FeatureName: Name
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("target_map")>]
        TargetMap: Map<string, obj>
    }

    and TypesDataframeAnalysisFeatureProcessor = {
        [<JsonPropertyName("frequency_encoding")>]
        FrequencyEncoding: TypesDataframeAnalysisFeatureProcessorFrequencyEncoding option
        [<JsonPropertyName("multi_encoding")>]
        MultiEncoding: TypesDataframeAnalysisFeatureProcessorMultiEncoding option
        [<JsonPropertyName("n_gram_encoding")>]
        NGramEncoding: TypesDataframeAnalysisFeatureProcessorNGramEncoding option
        [<JsonPropertyName("one_hot_encoding")>]
        OneHotEncoding: TypesDataframeAnalysisFeatureProcessorOneHotEncoding option
        [<JsonPropertyName("target_mean_encoding")>]
        TargetMeanEncoding: TypesDataframeAnalysisFeatureProcessorTargetMeanEncoding option
    }

    and TypesDataframeAnalysis = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("dependent_variable")>]
        DependentVariable: string
        [<JsonPropertyName("downsample_factor")>]
        DownsampleFactor: float option
        [<JsonPropertyName("early_stopping_enabled")>]
        EarlyStoppingEnabled: bool option
        [<JsonPropertyName("eta")>]
        Eta: float option
        [<JsonPropertyName("eta_growth_rate_per_tree")>]
        EtaGrowthRatePerTree: float option
        [<JsonPropertyName("feature_bag_fraction")>]
        FeatureBagFraction: float option
        [<JsonPropertyName("feature_processors")>]
        FeatureProcessors: TypesDataframeAnalysisFeatureProcessor array option
        [<JsonPropertyName("gamma")>]
        Gamma: float option
        [<JsonPropertyName("lambda")>]
        Lambda: float option
        [<JsonPropertyName("max_optimization_rounds_per_hyperparameter")>]
        MaxOptimizationRoundsPerHyperparameter: float option
        [<JsonPropertyName("max_trees")>]
        MaxTrees: float option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
        [<JsonPropertyName("prediction_field_name")>]
        PredictionFieldName: Field option
        [<JsonPropertyName("randomize_seed")>]
        RandomizeSeed: float option
        [<JsonPropertyName("soft_tree_depth_limit")>]
        SoftTreeDepthLimit: float option
        [<JsonPropertyName("soft_tree_depth_tolerance")>]
        SoftTreeDepthTolerance: float option
        [<JsonPropertyName("training_percent")>]
        TrainingPercent: Percentage option
    }

    and TypesDataframeAnalysisClassification = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("dependent_variable")>]
        DependentVariable: string
        [<JsonPropertyName("downsample_factor")>]
        DownsampleFactor: float option
        [<JsonPropertyName("early_stopping_enabled")>]
        EarlyStoppingEnabled: bool option
        [<JsonPropertyName("eta")>]
        Eta: float option
        [<JsonPropertyName("eta_growth_rate_per_tree")>]
        EtaGrowthRatePerTree: float option
        [<JsonPropertyName("feature_bag_fraction")>]
        FeatureBagFraction: float option
        [<JsonPropertyName("feature_processors")>]
        FeatureProcessors: TypesDataframeAnalysisFeatureProcessor array option
        [<JsonPropertyName("gamma")>]
        Gamma: float option
        [<JsonPropertyName("lambda")>]
        Lambda: float option
        [<JsonPropertyName("max_optimization_rounds_per_hyperparameter")>]
        MaxOptimizationRoundsPerHyperparameter: float option
        [<JsonPropertyName("max_trees")>]
        MaxTrees: float option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
        [<JsonPropertyName("prediction_field_name")>]
        PredictionFieldName: Field option
        [<JsonPropertyName("randomize_seed")>]
        RandomizeSeed: float option
        [<JsonPropertyName("soft_tree_depth_limit")>]
        SoftTreeDepthLimit: float option
        [<JsonPropertyName("soft_tree_depth_tolerance")>]
        SoftTreeDepthTolerance: float option
        [<JsonPropertyName("training_percent")>]
        TrainingPercent: Percentage option
        [<JsonPropertyName("class_assignment_objective")>]
        ClassAssignmentObjective: string option
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
    }

    and TypesDataframeAnalysisOutlierDetection = {
        [<JsonPropertyName("compute_feature_influence")>]
        ComputeFeatureInfluence: bool option
        [<JsonPropertyName("feature_influence_threshold")>]
        FeatureInfluenceThreshold: float option
        [<JsonPropertyName("method")>]
        Method: string option
        [<JsonPropertyName("n_neighbors")>]
        NNeighbors: float option
        [<JsonPropertyName("outlier_fraction")>]
        OutlierFraction: float option
        [<JsonPropertyName("standardization_enabled")>]
        StandardizationEnabled: bool option
    }

    and TypesDataframeAnalysisRegression = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("dependent_variable")>]
        DependentVariable: string
        [<JsonPropertyName("downsample_factor")>]
        DownsampleFactor: float option
        [<JsonPropertyName("early_stopping_enabled")>]
        EarlyStoppingEnabled: bool option
        [<JsonPropertyName("eta")>]
        Eta: float option
        [<JsonPropertyName("eta_growth_rate_per_tree")>]
        EtaGrowthRatePerTree: float option
        [<JsonPropertyName("feature_bag_fraction")>]
        FeatureBagFraction: float option
        [<JsonPropertyName("feature_processors")>]
        FeatureProcessors: TypesDataframeAnalysisFeatureProcessor array option
        [<JsonPropertyName("gamma")>]
        Gamma: float option
        [<JsonPropertyName("lambda")>]
        Lambda: float option
        [<JsonPropertyName("max_optimization_rounds_per_hyperparameter")>]
        MaxOptimizationRoundsPerHyperparameter: float option
        [<JsonPropertyName("max_trees")>]
        MaxTrees: float option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float option
        [<JsonPropertyName("prediction_field_name")>]
        PredictionFieldName: Field option
        [<JsonPropertyName("randomize_seed")>]
        RandomizeSeed: float option
        [<JsonPropertyName("soft_tree_depth_limit")>]
        SoftTreeDepthLimit: float option
        [<JsonPropertyName("soft_tree_depth_tolerance")>]
        SoftTreeDepthTolerance: float option
        [<JsonPropertyName("training_percent")>]
        TrainingPercent: Percentage option
        [<JsonPropertyName("loss_function")>]
        LossFunction: string option
        [<JsonPropertyName("loss_function_parameter")>]
        LossFunctionParameter: float option
    }

    and TypesDataframeAnalysisContainer = {
        [<JsonPropertyName("classification")>]
        Classification: TypesDataframeAnalysisClassification option
        [<JsonPropertyName("outlier_detection")>]
        OutlierDetection: TypesDataframeAnalysisOutlierDetection option
        [<JsonPropertyName("regression")>]
        Regression: TypesDataframeAnalysisRegression option
    }

    and TypesDataframeAnalyticsFieldSelection = {
        [<JsonPropertyName("is_included")>]
        IsIncluded: bool
        [<JsonPropertyName("is_required")>]
        IsRequired: bool
        [<JsonPropertyName("feature_type")>]
        FeatureType: string option
        [<JsonPropertyName("mapping_types")>]
        MappingTypes: string array
        [<JsonPropertyName("name")>]
        Name: Field
        [<JsonPropertyName("reason")>]
        Reason: string option
    }

    and TypesDataframeAnalyticsMemoryEstimation = {
        [<JsonPropertyName("expected_memory_with_disk")>]
        ExpectedMemoryWithDisk: string
        [<JsonPropertyName("expected_memory_without_disk")>]
        ExpectedMemoryWithoutDisk: string
    }

    and TypesPage = {
        [<JsonPropertyName("from")>]
        From: float option
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and DurationValueUnitSeconds = obj

    and TypesBucketInfluencer = {
        [<JsonPropertyName("anomaly_score")>]
        AnomalyScore: float
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: DurationValueUnitSeconds
        [<JsonPropertyName("influencer_field_name")>]
        InfluencerFieldName: Field
        [<JsonPropertyName("initial_anomaly_score")>]
        InitialAnomalyScore: float
        [<JsonPropertyName("is_interim")>]
        IsInterim: bool
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("probability")>]
        Probability: float
        [<JsonPropertyName("raw_anomaly_score")>]
        RawAnomalyScore: float
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("timestamp_string")>]
        TimestampString: DateTime option
    }

    and TypesBucketSummary = {
        [<JsonPropertyName("anomaly_score")>]
        AnomalyScore: float
        [<JsonPropertyName("bucket_influencers")>]
        BucketInfluencers: TypesBucketInfluencer array
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: DurationValueUnitSeconds
        [<JsonPropertyName("event_count")>]
        EventCount: float
        [<JsonPropertyName("initial_anomaly_score")>]
        InitialAnomalyScore: float
        [<JsonPropertyName("is_interim")>]
        IsInterim: bool
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("processing_time_ms")>]
        ProcessingTimeMs: DurationValueUnitMillis
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("timestamp_string")>]
        TimestampString: DateTime option
    }

    and TypesCalendarEvent = {
        [<JsonPropertyName("calendar_id")>]
        CalendarId: Id option
        [<JsonPropertyName("event_id")>]
        EventId: Id option
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("end_time")>]
        EndTime: DateTime
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime
        [<JsonPropertyName("skip_result")>]
        SkipResult: bool option
        [<JsonPropertyName("skip_model_update")>]
        SkipModelUpdate: bool option
        [<JsonPropertyName("force_time_shift")>]
        ForceTimeShift: float option
    }

    and GetCalendarsCalendar = {
        [<JsonPropertyName("calendar_id")>]
        CalendarId: Id
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("job_ids")>]
        JobIds: Id array
    }

    and CategoryId = float

    and TypesCategory = {
        [<JsonPropertyName("category_id")>]
        CategoryId: Ulong
        [<JsonPropertyName("examples")>]
        Examples: string array
        [<JsonPropertyName("grok_pattern")>]
        GrokPattern: GrokPattern option
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("max_matching_length")>]
        MaxMatchingLength: Ulong
        [<JsonPropertyName("partition_field_name")>]
        PartitionFieldName: string option
        [<JsonPropertyName("partition_field_value")>]
        PartitionFieldValue: string option
        [<JsonPropertyName("regex")>]
        Regex: string
        [<JsonPropertyName("terms")>]
        Terms: string
        [<JsonPropertyName("num_matches")>]
        NumMatches: float option
        [<JsonPropertyName("preferred_to_categories")>]
        PreferredToCategories: Id array option
        [<JsonPropertyName("p")>]
        P: string option
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("mlcategory")>]
        Mlcategory: string
    }

    and TypesApiKeyAuthorization = {
        [<JsonPropertyName("id")>]
        Id: string
        [<JsonPropertyName("name")>]
        Name: string
    }

    and TypesDataframeAnalyticsAuthorization = {
        [<JsonPropertyName("api_key")>]
        ApiKey: TypesApiKeyAuthorization option
        [<JsonPropertyName("roles")>]
        Roles: string array option
        [<JsonPropertyName("service_account")>]
        ServiceAccount: string option
    }

    and TypesDataframeAnalyticsSummary = {
        [<JsonPropertyName("allow_lazy_start")>]
        AllowLazyStart: bool option
        [<JsonPropertyName("analysis")>]
        Analysis: TypesDataframeAnalysisContainer
        [<JsonPropertyName("analyzed_fields")>]
        AnalyzedFields: TypesDataframeAnalysisAnalyzedFields option
        [<JsonPropertyName("authorization")>]
        Authorization: TypesDataframeAnalyticsAuthorization option
        [<JsonPropertyName("create_time")>]
        CreateTime: EpochTimeUnitMillis option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("dest")>]
        Dest: TypesDataframeAnalyticsDestination
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("max_num_threads")>]
        MaxNumThreads: float option
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: string option
        [<JsonPropertyName("source")>]
        Source: TypesDataframeAnalyticsSource
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
    }

    and NodeAttributes = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("ephemeral_id")>]
        EphemeralId: Id
        [<JsonPropertyName("id")>]
        Id: NodeId option
        [<JsonPropertyName("name")>]
        Name: NodeName
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
    }

    and TypesHyperparameters = {
        [<JsonPropertyName("alpha")>]
        Alpha: float option
        [<JsonPropertyName("lambda")>]
        Lambda: float option
        [<JsonPropertyName("gamma")>]
        Gamma: float option
        [<JsonPropertyName("eta")>]
        Eta: float option
        [<JsonPropertyName("eta_growth_rate_per_tree")>]
        EtaGrowthRatePerTree: float option
        [<JsonPropertyName("feature_bag_fraction")>]
        FeatureBagFraction: float option
        [<JsonPropertyName("downsample_factor")>]
        DownsampleFactor: float option
        [<JsonPropertyName("max_attempts_to_add_tree")>]
        MaxAttemptsToAddTree: float option
        [<JsonPropertyName("max_optimization_rounds_per_hyperparameter")>]
        MaxOptimizationRoundsPerHyperparameter: float option
        [<JsonPropertyName("max_trees")>]
        MaxTrees: float option
        [<JsonPropertyName("num_folds")>]
        NumFolds: float option
        [<JsonPropertyName("num_splits_per_feature")>]
        NumSplitsPerFeature: float option
        [<JsonPropertyName("soft_tree_depth_limit")>]
        SoftTreeDepthLimit: float option
        [<JsonPropertyName("soft_tree_depth_tolerance")>]
        SoftTreeDepthTolerance: float option
    }

    and TypesTimingStats = {
        [<JsonPropertyName("elapsed_time")>]
        ElapsedTime: DurationValueUnitMillis
        [<JsonPropertyName("iteration_time")>]
        IterationTime: DurationValueUnitMillis option
    }

    and TypesValidationLoss = {
        [<JsonPropertyName("fold_values")>]
        FoldValues: string array
        [<JsonPropertyName("loss_type")>]
        LossType: string
    }

    and TypesDataframeAnalyticsStatsHyperparameters = {
        [<JsonPropertyName("hyperparameters")>]
        Hyperparameters: TypesHyperparameters
        [<JsonPropertyName("iteration")>]
        Iteration: float
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("timing_stats")>]
        TimingStats: TypesTimingStats
        [<JsonPropertyName("validation_loss")>]
        ValidationLoss: TypesValidationLoss
    }

    and TypesOutlierDetectionParameters = {
        [<JsonPropertyName("compute_feature_influence")>]
        ComputeFeatureInfluence: bool option
        [<JsonPropertyName("feature_influence_threshold")>]
        FeatureInfluenceThreshold: float option
        [<JsonPropertyName("method")>]
        Method: string option
        [<JsonPropertyName("n_neighbors")>]
        NNeighbors: float option
        [<JsonPropertyName("outlier_fraction")>]
        OutlierFraction: float option
        [<JsonPropertyName("standardization_enabled")>]
        StandardizationEnabled: bool option
    }

    and TypesDataframeAnalyticsStatsOutlierDetection = {
        [<JsonPropertyName("parameters")>]
        Parameters: TypesOutlierDetectionParameters
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("timing_stats")>]
        TimingStats: TypesTimingStats
    }

    and TypesDataframeAnalyticsStatsContainer = {
        [<JsonPropertyName("classification_stats")>]
        ClassificationStats: TypesDataframeAnalyticsStatsHyperparameters option
        [<JsonPropertyName("outlier_detection_stats")>]
        OutlierDetectionStats: TypesDataframeAnalyticsStatsOutlierDetection option
        [<JsonPropertyName("regression_stats")>]
        RegressionStats: TypesDataframeAnalyticsStatsHyperparameters option
    }

    and TypesDataframeAnalyticsStatsDataCounts = {
        [<JsonPropertyName("skipped_docs_count")>]
        SkippedDocsCount: float
        [<JsonPropertyName("test_docs_count")>]
        TestDocsCount: float
        [<JsonPropertyName("training_docs_count")>]
        TrainingDocsCount: float
    }

    and TypesDataframeAnalyticsStatsMemoryUsage = {
        [<JsonPropertyName("memory_reestimate_bytes")>]
        MemoryReestimateBytes: float option
        [<JsonPropertyName("peak_usage_bytes")>]
        PeakUsageBytes: float
        [<JsonPropertyName("status")>]
        Status: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis option
    }

    and TypesDataframeAnalyticsStatsProgress = {
        [<JsonPropertyName("phase")>]
        Phase: string
        [<JsonPropertyName("progress_percent")>]
        ProgressPercent: float
    }

    and TypesDataframeStateConverter() =
        inherit JsonConverter<TypesDataframeState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDataframeState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDataframeState.Started -> "started"
                | TypesDataframeState.Stopped -> "stopped"
                | TypesDataframeState.Starting -> "starting"
                | TypesDataframeState.Stopping -> "stopping"
                | TypesDataframeState.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "started" -> TypesDataframeState.Started
            | "stopped" -> TypesDataframeState.Stopped
            | "starting" -> TypesDataframeState.Starting
            | "stopping" -> TypesDataframeState.Stopping
            | "failed" -> TypesDataframeState.Failed
            | s -> failwith $"Unknown TypesDataframeState: {s}"

    and [<JsonConverter(typeof<TypesDataframeStateConverter>)>]
        TypesDataframeState =
        | Started
        | Stopped
        | Starting
        | Stopping
        | Failed
        with
        override this.ToString() =
            match this with
            | Started -> "started"
            | Stopped -> "stopped"
            | Starting -> "starting"
            | Stopping -> "stopping"
            | Failed -> "failed"

    and TypesDataframeAnalytics = {
        [<JsonPropertyName("analysis_stats")>]
        AnalysisStats: TypesDataframeAnalyticsStatsContainer option
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("data_counts")>]
        DataCounts: TypesDataframeAnalyticsStatsDataCounts
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("memory_usage")>]
        MemoryUsage: TypesDataframeAnalyticsStatsMemoryUsage
        [<JsonPropertyName("node")>]
        Node: NodeAttributes option
        [<JsonPropertyName("progress")>]
        Progress: TypesDataframeAnalyticsStatsProgress array
        [<JsonPropertyName("state")>]
        State: TypesDataframeState
    }

    and TypesRunningStateSearchInterval = {
        [<JsonPropertyName("end")>]
        End: Duration option
        [<JsonPropertyName("end_ms")>]
        EndMs: DurationValueUnitMillis
        [<JsonPropertyName("start")>]
        Start: Duration option
        [<JsonPropertyName("start_ms")>]
        StartMs: DurationValueUnitMillis
    }

    and TypesDatafeedRunningState = {
        [<JsonPropertyName("real_time_configured")>]
        RealTimeConfigured: bool
        [<JsonPropertyName("real_time_running")>]
        RealTimeRunning: bool
        [<JsonPropertyName("search_interval")>]
        SearchInterval: TypesRunningStateSearchInterval option
    }

    /// <summary>
    /// Time unit for fractional milliseconds
    /// </summary>
    and UnitFloatMillis = float

    and DurationValueUnitFloatMillis = obj

    and TypesExponentialAverageCalculationContext = {
        [<JsonPropertyName("incremental_metric_value_ms")>]
        IncrementalMetricValueMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("latest_timestamp")>]
        LatestTimestamp: EpochTimeUnitMillis option
        [<JsonPropertyName("previous_exponential_average_ms")>]
        PreviousExponentialAverageMs: DurationValueUnitFloatMillis option
    }

    and TypesDatafeedTimingStats = {
        [<JsonPropertyName("bucket_count")>]
        BucketCount: float
        [<JsonPropertyName("exponential_average_search_time_per_hour_ms")>]
        ExponentialAverageSearchTimePerHourMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("exponential_average_calculation_context")>]
        ExponentialAverageCalculationContext: TypesExponentialAverageCalculationContext option
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("search_count")>]
        SearchCount: float
        [<JsonPropertyName("total_search_time_ms")>]
        TotalSearchTimeMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("average_search_time_per_bucket_ms")>]
        AverageSearchTimePerBucketMs: DurationValueUnitFloatMillis option
    }

    /// <summary>
    /// Alternative representation of DiscoveryNode used in ml.get_job_stats and ml.get_datafeed_stats
    /// </summary>
    and TypesDiscoveryNodeCompact = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("ephemeral_id")>]
        EphemeralId: Id
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
    }

    and TypesDatafeedStats = {
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("datafeed_id")>]
        DatafeedId: Id
        [<JsonPropertyName("node")>]
        Node: TypesDiscoveryNodeCompact option
        [<JsonPropertyName("state")>]
        State: TypesDatafeedState
        [<JsonPropertyName("timing_stats")>]
        TimingStats: TypesDatafeedTimingStats option
        [<JsonPropertyName("running_state")>]
        RunningState: TypesDatafeedRunningState option
    }

    /// <summary>
    /// Controls how to deal with unavailable concrete indices (closed or missing), how wildcard expressions are expanded
    /// to actual indices (all, closed or open indices) and how to deal with wildcard expressions that resolve to no indices.
    /// </summary>
    and IndicesOptions = {
        [<JsonPropertyName("allow_no_indices")>]
        AllowNoIndices: bool option
        [<JsonPropertyName("expand_wildcards")>]
        ExpandWildcards: ExpandWildcards option
        [<JsonPropertyName("ignore_unavailable")>]
        IgnoreUnavailable: bool option
        [<JsonPropertyName("ignore_throttled")>]
        IgnoreThrottled: bool option
    }

    and TypesChunkingModeConverter() =
        inherit JsonConverter<TypesChunkingMode>()

        override _.Write(writer: Utf8JsonWriter, value: TypesChunkingMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesChunkingMode.Auto -> "auto"
                | TypesChunkingMode.Manual -> "manual"
                | TypesChunkingMode.Off -> "off"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "auto" -> TypesChunkingMode.Auto
            | "manual" -> TypesChunkingMode.Manual
            | "off" -> TypesChunkingMode.Off
            | s -> failwith $"Unknown TypesChunkingMode: {s}"

    and [<JsonConverter(typeof<TypesChunkingModeConverter>)>]
        TypesChunkingMode =
        | Auto
        | Manual
        | Off
        with
        override this.ToString() =
            match this with
            | Auto -> "auto"
            | Manual -> "manual"
            | Off -> "off"

    and TypesChunkingConfig = {
        [<JsonPropertyName("mode")>]
        Mode: TypesChunkingMode
        [<JsonPropertyName("time_span")>]
        TimeSpan: Duration option
    }

    and TypesDatafeedAuthorization = {
        [<JsonPropertyName("api_key")>]
        ApiKey: TypesApiKeyAuthorization option
        [<JsonPropertyName("roles")>]
        Roles: string array option
        [<JsonPropertyName("service_account")>]
        ServiceAccount: string option
    }

    and TypesDelayedDataCheckConfig = {
        [<JsonPropertyName("check_window")>]
        CheckWindow: Duration option
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and TypesDatafeed = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregationContainer> option
        [<JsonPropertyName("authorization")>]
        Authorization: TypesDatafeedAuthorization option
        [<JsonPropertyName("chunking_config")>]
        ChunkingConfig: TypesChunkingConfig option
        [<JsonPropertyName("datafeed_id")>]
        DatafeedId: Id
        [<JsonPropertyName("frequency")>]
        Frequency: Duration option
        [<JsonPropertyName("indices")>]
        Indices: string array
        [<JsonPropertyName("indexes")>]
        Indexes: string array option
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("max_empty_searches")>]
        MaxEmptySearches: float option
        [<JsonPropertyName("query_delay")>]
        QueryDelay: Duration option
        [<JsonPropertyName("script_fields")>]
        ScriptFields: Map<string, ScriptField> option
        [<JsonPropertyName("scroll_size")>]
        ScrollSize: float option
        [<JsonPropertyName("delayed_data_check_config")>]
        DelayedDataCheckConfig: TypesDelayedDataCheckConfig
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
        [<JsonPropertyName("indices_options")>]
        IndicesOptions: IndicesOptions option
        [<JsonPropertyName("query")>]
        Query: obj
    }

    and TypesFilter = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("filter_id")>]
        FilterId: Id
        [<JsonPropertyName("items")>]
        Items: string array
    }

    and TypesInfluencer = {
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: DurationValueUnitSeconds
        [<JsonPropertyName("influencer_score")>]
        InfluencerScore: float
        [<JsonPropertyName("influencer_field_name")>]
        InfluencerFieldName: Field
        [<JsonPropertyName("influencer_field_value")>]
        InfluencerFieldValue: string
        [<JsonPropertyName("initial_influencer_score")>]
        InitialInfluencerScore: float
        [<JsonPropertyName("is_interim")>]
        IsInterim: bool
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("probability")>]
        Probability: float
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("foo")>]
        Foo: string option
    }

    and TypesDataCounts = {
        [<JsonPropertyName("bucket_count")>]
        BucketCount: float
        [<JsonPropertyName("earliest_record_timestamp")>]
        EarliestRecordTimestamp: float option
        [<JsonPropertyName("empty_bucket_count")>]
        EmptyBucketCount: float
        [<JsonPropertyName("input_bytes")>]
        InputBytes: float
        [<JsonPropertyName("input_field_count")>]
        InputFieldCount: float
        [<JsonPropertyName("input_record_count")>]
        InputRecordCount: float
        [<JsonPropertyName("invalid_date_count")>]
        InvalidDateCount: float
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("last_data_time")>]
        LastDataTime: float option
        [<JsonPropertyName("latest_empty_bucket_timestamp")>]
        LatestEmptyBucketTimestamp: float option
        [<JsonPropertyName("latest_record_timestamp")>]
        LatestRecordTimestamp: float option
        [<JsonPropertyName("latest_sparse_bucket_timestamp")>]
        LatestSparseBucketTimestamp: float option
        [<JsonPropertyName("latest_bucket_timestamp")>]
        LatestBucketTimestamp: float option
        [<JsonPropertyName("log_time")>]
        LogTime: float option
        [<JsonPropertyName("missing_field_count")>]
        MissingFieldCount: float
        [<JsonPropertyName("out_of_order_timestamp_count")>]
        OutOfOrderTimestampCount: float
        [<JsonPropertyName("processed_field_count")>]
        ProcessedFieldCount: float
        [<JsonPropertyName("processed_record_count")>]
        ProcessedRecordCount: float
        [<JsonPropertyName("sparse_bucket_count")>]
        SparseBucketCount: float
    }

    and TypesJobStatistics = {
        [<JsonPropertyName("avg")>]
        Avg: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min")>]
        Min: float
        [<JsonPropertyName("total")>]
        Total: float
    }

    and TypesJobForecastStatistics = {
        [<JsonPropertyName("memory_bytes")>]
        MemoryBytes: TypesJobStatistics option
        [<JsonPropertyName("processing_time_ms")>]
        ProcessingTimeMs: TypesJobStatistics option
        [<JsonPropertyName("records")>]
        Records: TypesJobStatistics option
        [<JsonPropertyName("status")>]
        Status: Map<string, float> option
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("forecasted_jobs")>]
        ForecastedJobs: float
    }

    and TypesJobTimingStats = {
        [<JsonPropertyName("average_bucket_processing_time_ms")>]
        AverageBucketProcessingTimeMs: DurationValueUnitFloatMillis option
        [<JsonPropertyName("bucket_count")>]
        BucketCount: float
        [<JsonPropertyName("exponential_average_bucket_processing_time_ms")>]
        ExponentialAverageBucketProcessingTimeMs: DurationValueUnitFloatMillis option
        [<JsonPropertyName("exponential_average_bucket_processing_time_per_hour_ms")>]
        ExponentialAverageBucketProcessingTimePerHourMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("total_bucket_processing_time_ms")>]
        TotalBucketProcessingTimeMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("maximum_bucket_processing_time_ms")>]
        MaximumBucketProcessingTimeMs: DurationValueUnitFloatMillis option
        [<JsonPropertyName("minimum_bucket_processing_time_ms")>]
        MinimumBucketProcessingTimeMs: DurationValueUnitFloatMillis option
    }

    and TypesModelSizeStats = {
        [<JsonPropertyName("bucket_allocation_failures_count")>]
        BucketAllocationFailuresCount: float
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("log_time")>]
        LogTime: DateTime
        [<JsonPropertyName("memory_status")>]
        MemoryStatus: TypesMemoryStatus
        [<JsonPropertyName("model_bytes")>]
        ModelBytes: ByteSize
        [<JsonPropertyName("model_bytes_exceeded")>]
        ModelBytesExceeded: ByteSize option
        [<JsonPropertyName("model_bytes_memory_limit")>]
        ModelBytesMemoryLimit: ByteSize option
        [<JsonPropertyName("output_memory_allocator_bytes")>]
        OutputMemoryAllocatorBytes: ByteSize option
        [<JsonPropertyName("peak_model_bytes")>]
        PeakModelBytes: ByteSize option
        [<JsonPropertyName("assignment_memory_basis")>]
        AssignmentMemoryBasis: string option
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("total_by_field_count")>]
        TotalByFieldCount: float
        [<JsonPropertyName("total_over_field_count")>]
        TotalOverFieldCount: float
        [<JsonPropertyName("total_partition_field_count")>]
        TotalPartitionFieldCount: float
        [<JsonPropertyName("categorization_status")>]
        CategorizationStatus: TypesCategorizationStatus
        [<JsonPropertyName("categorized_doc_count")>]
        CategorizedDocCount: float
        [<JsonPropertyName("dead_category_count")>]
        DeadCategoryCount: float
        [<JsonPropertyName("failed_category_count")>]
        FailedCategoryCount: float
        [<JsonPropertyName("frequent_category_count")>]
        FrequentCategoryCount: float
        [<JsonPropertyName("rare_category_count")>]
        RareCategoryCount: float
        [<JsonPropertyName("total_category_count")>]
        TotalCategoryCount: float
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
    }

    and TypesJobStats = {
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string option
        [<JsonPropertyName("data_counts")>]
        DataCounts: TypesDataCounts
        [<JsonPropertyName("forecasts_stats")>]
        ForecastsStats: TypesJobForecastStatistics
        [<JsonPropertyName("job_id")>]
        JobId: string
        [<JsonPropertyName("model_size_stats")>]
        ModelSizeStats: TypesModelSizeStats
        [<JsonPropertyName("node")>]
        Node: TypesDiscoveryNodeCompact option
        [<JsonPropertyName("open_time")>]
        OpenTime: DateTime option
        [<JsonPropertyName("state")>]
        State: TypesJobState
        [<JsonPropertyName("timing_stats")>]
        TimingStats: TypesJobTimingStats
        [<JsonPropertyName("deleting")>]
        Deleting: bool option
    }

    and TypesAnalysisLimits = {
        [<JsonPropertyName("categorization_examples_limit")>]
        CategorizationExamplesLimit: float option
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: ByteSize option
    }

    /// <summary>
    /// Custom metadata about the job
    /// </summary>
    and TypesCustomSettings = obj

    and TypesDataDescription = {
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("time_field")>]
        TimeField: Field option
        [<JsonPropertyName("time_format")>]
        TimeFormat: string option
        [<JsonPropertyName("field_delimiter")>]
        FieldDelimiter: string option
    }

    and TypesJobBlockedReasonConverter() =
        inherit JsonConverter<TypesJobBlockedReason>()

        override _.Write(writer: Utf8JsonWriter, value: TypesJobBlockedReason, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesJobBlockedReason.Delete -> "delete"
                | TypesJobBlockedReason.Reset -> "reset"
                | TypesJobBlockedReason.Revert -> "revert"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "delete" -> TypesJobBlockedReason.Delete
            | "reset" -> TypesJobBlockedReason.Reset
            | "revert" -> TypesJobBlockedReason.Revert
            | s -> failwith $"Unknown TypesJobBlockedReason: {s}"

    and [<JsonConverter(typeof<TypesJobBlockedReasonConverter>)>]
        TypesJobBlockedReason =
        | Delete
        | Reset
        | Revert
        with
        override this.ToString() =
            match this with
            | Delete -> "delete"
            | Reset -> "reset"
            | Revert -> "revert"

    and TypesJobBlocked = {
        [<JsonPropertyName("reason")>]
        Reason: TypesJobBlockedReason
        [<JsonPropertyName("task_id")>]
        TaskId: TaskId option
    }

    and TypesModelPlotConfig = {
        [<JsonPropertyName("annotations_enabled")>]
        AnnotationsEnabled: bool option
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("terms")>]
        Terms: Field option
    }

    and TypesJob = {
        [<JsonPropertyName("allow_lazy_open")>]
        AllowLazyOpen: bool
        [<JsonPropertyName("analysis_config")>]
        AnalysisConfig: TypesAnalysisConfig
        [<JsonPropertyName("analysis_limits")>]
        AnalysisLimits: TypesAnalysisLimits option
        [<JsonPropertyName("background_persist_interval")>]
        BackgroundPersistInterval: Duration option
        [<JsonPropertyName("blocked")>]
        Blocked: TypesJobBlocked option
        [<JsonPropertyName("create_time")>]
        CreateTime: DateTime option
        [<JsonPropertyName("custom_settings")>]
        CustomSettings: TypesCustomSettings option
        [<JsonPropertyName("daily_model_snapshot_retention_after_days")>]
        DailyModelSnapshotRetentionAfterDays: float option
        [<JsonPropertyName("data_description")>]
        DataDescription: TypesDataDescription
        [<JsonPropertyName("datafeed_config")>]
        DatafeedConfig: TypesDatafeed option
        [<JsonPropertyName("deleting")>]
        Deleting: bool option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("finished_time")>]
        FinishedTime: DateTime option
        [<JsonPropertyName("groups")>]
        Groups: string array option
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("job_type")>]
        JobType: string option
        [<JsonPropertyName("job_version")>]
        JobVersion: VersionString option
        [<JsonPropertyName("model_plot_config")>]
        ModelPlotConfig: TypesModelPlotConfig option
        [<JsonPropertyName("model_snapshot_id")>]
        ModelSnapshotId: Id option
        [<JsonPropertyName("model_snapshot_retention_days")>]
        ModelSnapshotRetentionDays: float
        [<JsonPropertyName("renormalization_window_days")>]
        RenormalizationWindowDays: float option
        [<JsonPropertyName("results_index_name")>]
        ResultsIndexName: IndexName
        [<JsonPropertyName("results_retention_days")>]
        ResultsRetentionDays: float option
    }

    and GetMemoryStatsJvmStats = {
        [<JsonPropertyName("heap_max")>]
        HeapMax: ByteSize option
        [<JsonPropertyName("heap_max_in_bytes")>]
        HeapMaxInBytes: float
        [<JsonPropertyName("java_inference")>]
        JavaInference: ByteSize option
        [<JsonPropertyName("java_inference_in_bytes")>]
        JavaInferenceInBytes: float
        [<JsonPropertyName("java_inference_max")>]
        JavaInferenceMax: ByteSize option
        [<JsonPropertyName("java_inference_max_in_bytes")>]
        JavaInferenceMaxInBytes: float
    }

    and GetMemoryStatsMemMlStats = {
        [<JsonPropertyName("anomaly_detectors")>]
        AnomalyDetectors: ByteSize option
        [<JsonPropertyName("anomaly_detectors_in_bytes")>]
        AnomalyDetectorsInBytes: float
        [<JsonPropertyName("data_frame_analytics")>]
        DataFrameAnalytics: ByteSize option
        [<JsonPropertyName("data_frame_analytics_in_bytes")>]
        DataFrameAnalyticsInBytes: float
        [<JsonPropertyName("max")>]
        Max: ByteSize option
        [<JsonPropertyName("max_in_bytes")>]
        MaxInBytes: float
        [<JsonPropertyName("native_code_overhead")>]
        NativeCodeOverhead: ByteSize option
        [<JsonPropertyName("native_code_overhead_in_bytes")>]
        NativeCodeOverheadInBytes: float
        [<JsonPropertyName("native_inference")>]
        NativeInference: ByteSize option
        [<JsonPropertyName("native_inference_in_bytes")>]
        NativeInferenceInBytes: float
    }

    and GetMemoryStatsMemStats = {
        [<JsonPropertyName("adjusted_total")>]
        AdjustedTotal: ByteSize option
        [<JsonPropertyName("adjusted_total_in_bytes")>]
        AdjustedTotalInBytes: float
        [<JsonPropertyName("total")>]
        Total: ByteSize option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float
        [<JsonPropertyName("ml")>]
        Ml: GetMemoryStatsMemMlStats
    }

    and GetMemoryStatsMemory = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("jvm")>]
        Jvm: GetMemoryStatsJvmStats
        [<JsonPropertyName("mem")>]
        Mem: GetMemoryStatsMemStats
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("ephemeral_id")>]
        EphemeralId: Id
    }

    and TypesDiscoveryNodeContent = {
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("ephemeral_id")>]
        EphemeralId: Id
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("external_id")>]
        ExternalId: string
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("min_index_version")>]
        MinIndexVersion: float
        [<JsonPropertyName("max_index_version")>]
        MaxIndexVersion: float
    }

    and TypesDiscoveryNode = Map<string, TypesDiscoveryNodeContent>

    and TypesSnapshotUpgradeStateConverter() =
        inherit JsonConverter<TypesSnapshotUpgradeState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSnapshotUpgradeState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSnapshotUpgradeState.LoadingOldState -> "loading_old_state"
                | TypesSnapshotUpgradeState.SavingNewState -> "saving_new_state"
                | TypesSnapshotUpgradeState.Stopped -> "stopped"
                | TypesSnapshotUpgradeState.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "loading_old_state" -> TypesSnapshotUpgradeState.LoadingOldState
            | "saving_new_state" -> TypesSnapshotUpgradeState.SavingNewState
            | "stopped" -> TypesSnapshotUpgradeState.Stopped
            | "failed" -> TypesSnapshotUpgradeState.Failed
            | s -> failwith $"Unknown TypesSnapshotUpgradeState: {s}"

    and [<JsonConverter(typeof<TypesSnapshotUpgradeStateConverter>)>]
        TypesSnapshotUpgradeState =
        | LoadingOldState
        | SavingNewState
        | Stopped
        | Failed
        with
        override this.ToString() =
            match this with
            | LoadingOldState -> "loading_old_state"
            | SavingNewState -> "saving_new_state"
            | Stopped -> "stopped"
            | Failed -> "failed"

    and TypesModelSnapshotUpgrade = {
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("snapshot_id")>]
        SnapshotId: Id
        [<JsonPropertyName("state")>]
        State: TypesSnapshotUpgradeState
        [<JsonPropertyName("node")>]
        Node: TypesDiscoveryNode
        [<JsonPropertyName("assignment_explanation")>]
        AssignmentExplanation: string
    }

    and TypesModelSnapshot = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("latest_record_time_stamp")>]
        LatestRecordTimeStamp: float option
        [<JsonPropertyName("latest_result_time_stamp")>]
        LatestResultTimeStamp: float option
        [<JsonPropertyName("min_version")>]
        MinVersion: VersionString
        [<JsonPropertyName("model_size_stats")>]
        ModelSizeStats: TypesModelSizeStats option
        [<JsonPropertyName("retain")>]
        Retain: bool
        [<JsonPropertyName("snapshot_doc_count")>]
        SnapshotDocCount: float
        [<JsonPropertyName("snapshot_id")>]
        SnapshotId: Id
        [<JsonPropertyName("timestamp")>]
        Timestamp: float
    }

    and TypesOverallBucketJob = {
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("max_anomaly_score")>]
        MaxAnomalyScore: float
    }

    and TypesOverallBucket = {
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: DurationValueUnitSeconds
        [<JsonPropertyName("is_interim")>]
        IsInterim: bool
        [<JsonPropertyName("jobs")>]
        Jobs: TypesOverallBucketJob array
        [<JsonPropertyName("overall_score")>]
        OverallScore: float
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("timestamp_string")>]
        TimestampString: DateTime option
    }

    and TypesGeoResults = {
        [<JsonPropertyName("actual_point")>]
        ActualPoint: string option
        [<JsonPropertyName("typical_point")>]
        TypicalPoint: string option
    }

    and TypesInfluence = {
        [<JsonPropertyName("influencer_field_name")>]
        InfluencerFieldName: string
        [<JsonPropertyName("influencer_field_values")>]
        InfluencerFieldValues: string array
    }

    and TypesAnomalyCause = {
        [<JsonPropertyName("actual")>]
        Actual: float array option
        [<JsonPropertyName("by_field_name")>]
        ByFieldName: Name option
        [<JsonPropertyName("by_field_value")>]
        ByFieldValue: string option
        [<JsonPropertyName("correlated_by_field_value")>]
        CorrelatedByFieldValue: string option
        [<JsonPropertyName("field_name")>]
        FieldName: Field option
        [<JsonPropertyName("function")>]
        Function: string option
        [<JsonPropertyName("function_description")>]
        FunctionDescription: string option
        [<JsonPropertyName("geo_results")>]
        GeoResults: TypesGeoResults option
        [<JsonPropertyName("influencers")>]
        Influencers: TypesInfluence array option
        [<JsonPropertyName("over_field_name")>]
        OverFieldName: Name option
        [<JsonPropertyName("over_field_value")>]
        OverFieldValue: string option
        [<JsonPropertyName("partition_field_name")>]
        PartitionFieldName: string option
        [<JsonPropertyName("partition_field_value")>]
        PartitionFieldValue: string option
        [<JsonPropertyName("probability")>]
        Probability: float
        [<JsonPropertyName("typical")>]
        Typical: float array option
    }

    and TypesAnomalyExplanation = {
        [<JsonPropertyName("anomaly_characteristics_impact")>]
        AnomalyCharacteristicsImpact: float option
        [<JsonPropertyName("anomaly_length")>]
        AnomalyLength: float option
        [<JsonPropertyName("anomaly_type")>]
        AnomalyType: string option
        [<JsonPropertyName("high_variance_penalty")>]
        HighVariancePenalty: bool option
        [<JsonPropertyName("incomplete_bucket_penalty")>]
        IncompleteBucketPenalty: bool option
        [<JsonPropertyName("lower_confidence_bound")>]
        LowerConfidenceBound: float option
        [<JsonPropertyName("multi_bucket_impact")>]
        MultiBucketImpact: float option
        [<JsonPropertyName("single_bucket_impact")>]
        SingleBucketImpact: float option
        [<JsonPropertyName("typical_value")>]
        TypicalValue: float option
        [<JsonPropertyName("upper_confidence_bound")>]
        UpperConfidenceBound: float option
    }

    and TypesAnomaly = {
        [<JsonPropertyName("actual")>]
        Actual: float array option
        [<JsonPropertyName("anomaly_score_explanation")>]
        AnomalyScoreExplanation: TypesAnomalyExplanation option
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: DurationValueUnitSeconds
        [<JsonPropertyName("by_field_name")>]
        ByFieldName: string option
        [<JsonPropertyName("by_field_value")>]
        ByFieldValue: string option
        [<JsonPropertyName("causes")>]
        Causes: TypesAnomalyCause array option
        [<JsonPropertyName("detector_index")>]
        DetectorIndex: float
        [<JsonPropertyName("field_name")>]
        FieldName: string option
        [<JsonPropertyName("function")>]
        Function: string option
        [<JsonPropertyName("function_description")>]
        FunctionDescription: string option
        [<JsonPropertyName("geo_results")>]
        GeoResults: TypesGeoResults option
        [<JsonPropertyName("influencers")>]
        Influencers: TypesInfluence array option
        [<JsonPropertyName("initial_record_score")>]
        InitialRecordScore: float
        [<JsonPropertyName("is_interim")>]
        IsInterim: bool
        [<JsonPropertyName("job_id")>]
        JobId: string
        [<JsonPropertyName("over_field_name")>]
        OverFieldName: string option
        [<JsonPropertyName("over_field_value")>]
        OverFieldValue: string option
        [<JsonPropertyName("partition_field_name")>]
        PartitionFieldName: string option
        [<JsonPropertyName("partition_field_value")>]
        PartitionFieldValue: string option
        [<JsonPropertyName("probability")>]
        Probability: float
        [<JsonPropertyName("record_score")>]
        RecordScore: float
        [<JsonPropertyName("result_type")>]
        ResultType: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("typical")>]
        Typical: float array option
    }

    and TypesIncludeConverter() =
        inherit JsonConverter<TypesInclude>()

        override _.Write(writer: Utf8JsonWriter, value: TypesInclude, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesInclude.Definition -> "definition"
                | TypesInclude.FeatureImportanceBaseline -> "feature_importance_baseline"
                | TypesInclude.Hyperparameters -> "hyperparameters"
                | TypesInclude.TotalFeatureImportance -> "total_feature_importance"
                | TypesInclude.DefinitionStatus -> "definition_status"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "definition" -> TypesInclude.Definition
            | "feature_importance_baseline" -> TypesInclude.FeatureImportanceBaseline
            | "hyperparameters" -> TypesInclude.Hyperparameters
            | "total_feature_importance" -> TypesInclude.TotalFeatureImportance
            | "definition_status" -> TypesInclude.DefinitionStatus
            | s -> failwith $"Unknown TypesInclude: {s}"

    and [<JsonConverter(typeof<TypesIncludeConverter>)>]
        TypesInclude =
        | Definition
        | FeatureImportanceBaseline
        | Hyperparameters
        | TotalFeatureImportance
        | DefinitionStatus
        with
        override this.ToString() =
            match this with
            | Definition -> "definition"
            | FeatureImportanceBaseline -> "feature_importance_baseline"
            | Hyperparameters -> "hyperparameters"
            | TotalFeatureImportance -> "total_feature_importance"
            | DefinitionStatus -> "definition_status"

    and TypesTokenizationTruncateConverter() =
        inherit JsonConverter<TypesTokenizationTruncate>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTokenizationTruncate, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTokenizationTruncate.First -> "first"
                | TypesTokenizationTruncate.Second -> "second"
                | TypesTokenizationTruncate.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "first" -> TypesTokenizationTruncate.First
            | "second" -> TypesTokenizationTruncate.Second
            | "none" -> TypesTokenizationTruncate.None
            | s -> failwith $"Unknown TypesTokenizationTruncate: {s}"

    and [<JsonConverter(typeof<TypesTokenizationTruncateConverter>)>]
        TypesTokenizationTruncate =
        | First
        | Second
        | None
        with
        override this.ToString() =
            match this with
            | First -> "first"
            | Second -> "second"
            | None -> "none"

    and TypesCommonTokenizationConfig = {
        [<JsonPropertyName("do_lower_case")>]
        DoLowerCase: bool option
        [<JsonPropertyName("max_sequence_length")>]
        MaxSequenceLength: float option
        [<JsonPropertyName("span")>]
        Span: float option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesTokenizationTruncate option
        [<JsonPropertyName("with_special_tokens")>]
        WithSpecialTokens: bool option
    }

    /// <summary>
    /// BERT and MPNet tokenization configuration options
    /// </summary>
    and TypesNlpBertTokenizationConfig = {
        [<JsonPropertyName("do_lower_case")>]
        DoLowerCase: bool option
        [<JsonPropertyName("max_sequence_length")>]
        MaxSequenceLength: float option
        [<JsonPropertyName("span")>]
        Span: float option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesTokenizationTruncate option
        [<JsonPropertyName("with_special_tokens")>]
        WithSpecialTokens: bool option
    }

    /// <summary>
    /// RoBERTa tokenization configuration options
    /// </summary>
    and TypesNlpRobertaTokenizationConfig = {
        [<JsonPropertyName("do_lower_case")>]
        DoLowerCase: bool option
        [<JsonPropertyName("max_sequence_length")>]
        MaxSequenceLength: float option
        [<JsonPropertyName("span")>]
        Span: float option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesTokenizationTruncate option
        [<JsonPropertyName("with_special_tokens")>]
        WithSpecialTokens: bool option
        [<JsonPropertyName("add_prefix_space")>]
        AddPrefixSpace: bool option
    }

    and TypesXlmRobertaTokenizationConfig = {
        [<JsonPropertyName("do_lower_case")>]
        DoLowerCase: bool option
        [<JsonPropertyName("max_sequence_length")>]
        MaxSequenceLength: float option
        [<JsonPropertyName("span")>]
        Span: float option
        [<JsonPropertyName("truncate")>]
        Truncate: TypesTokenizationTruncate option
        [<JsonPropertyName("with_special_tokens")>]
        WithSpecialTokens: bool option
    }

    /// <summary>
    /// Tokenization options stored in inference configuration
    /// </summary>
    and TypesTokenizationConfigContainer = {
        [<JsonPropertyName("bert")>]
        Bert: TypesNlpBertTokenizationConfig option
        [<JsonPropertyName("bert_ja")>]
        BertJa: TypesNlpBertTokenizationConfig option
        [<JsonPropertyName("mpnet")>]
        Mpnet: TypesNlpBertTokenizationConfig option
        [<JsonPropertyName("roberta")>]
        Roberta: TypesNlpRobertaTokenizationConfig option
        [<JsonPropertyName("xlm_roberta")>]
        XlmRoberta: TypesXlmRobertaTokenizationConfig option
    }

    and TypesVocabulary = {
        [<JsonPropertyName("index")>]
        Index: IndexName
    }

    /// <summary>
    /// Fill mask inference options
    /// </summary>
    and TypesFillMaskInferenceOptions = {
        [<JsonPropertyName("mask_token")>]
        MaskToken: string option
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    and TypesQueryFeatureExtractor = {
        [<JsonPropertyName("default_score")>]
        DefaultScore: float option
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
    }

    and TypesFeatureExtractor = {
        [<JsonPropertyName("default_score")>]
        DefaultScore: float option
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
    }

    and TypesLearningToRankConfig = {
        [<JsonPropertyName("default_params")>]
        DefaultParams: Map<string, obj> option
        [<JsonPropertyName("feature_extractors")>]
        FeatureExtractors: Map<string, TypesFeatureExtractor> array option
        [<JsonPropertyName("num_top_feature_importance_values")>]
        NumTopFeatureImportanceValues: float
    }

    /// <summary>
    /// Named entity recognition options
    /// </summary>
    and TypesNerInferenceOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    /// <summary>
    /// Pass through configuration options
    /// </summary>
    and TypesPassThroughInferenceOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    /// <summary>
    /// Question answering inference options
    /// </summary>
    and TypesQuestionAnsweringInferenceOptions = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("max_answer_length")>]
        MaxAnswerLength: float option
    }

    /// <summary>
    /// Text classification configuration options
    /// </summary>
    and TypesTextClassificationInferenceOptions = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    /// <summary>
    /// Text embedding inference options
    /// </summary>
    and TypesTextEmbeddingInferenceOptions = {
        [<JsonPropertyName("embedding_size")>]
        EmbeddingSize: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    /// <summary>
    /// Text expansion inference options
    /// </summary>
    and TypesTextExpansionInferenceOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("vocabulary")>]
        Vocabulary: TypesVocabulary option
    }

    /// <summary>
    /// Zero shot classification configuration options
    /// </summary>
    and TypesZeroShotClassificationInferenceOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesTokenizationConfigContainer option
        [<JsonPropertyName("hypothesis_template")>]
        HypothesisTemplate: string option
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("multi_label")>]
        MultiLabel: bool option
        [<JsonPropertyName("labels")>]
        Labels: string array option
    }

    /// <summary>
    /// Inference configuration provided when storing the model config
    /// </summary>
    and TypesInferenceConfigCreateContainer = {
        [<JsonPropertyName("regression")>]
        Regression: TypesRegressionInferenceOptions option
        [<JsonPropertyName("classification")>]
        Classification: TypesClassificationInferenceOptions option
        [<JsonPropertyName("text_classification")>]
        TextClassification: TypesTextClassificationInferenceOptions option
        [<JsonPropertyName("zero_shot_classification")>]
        ZeroShotClassification: TypesZeroShotClassificationInferenceOptions option
        [<JsonPropertyName("fill_mask")>]
        FillMask: TypesFillMaskInferenceOptions option
        [<JsonPropertyName("learning_to_rank")>]
        LearningToRank: TypesLearningToRankConfig option
        [<JsonPropertyName("ner")>]
        Ner: TypesNerInferenceOptions option
        [<JsonPropertyName("pass_through")>]
        PassThrough: TypesPassThroughInferenceOptions option
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: TypesTextEmbeddingInferenceOptions option
        [<JsonPropertyName("text_expansion")>]
        TextExpansion: TypesTextExpansionInferenceOptions option
        [<JsonPropertyName("question_answering")>]
        QuestionAnswering: TypesQuestionAnsweringInferenceOptions option
    }

    and TypesTrainedModelPrefixStrings = {
        [<JsonPropertyName("ingest")>]
        Ingest: string option
        [<JsonPropertyName("search")>]
        Search: string option
    }

    and TypesModelPackageConfig = {
        [<JsonPropertyName("create_time")>]
        CreateTime: EpochTimeUnitMillis option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("inference_config")>]
        InferenceConfig: Map<string, obj> option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("minimum_version")>]
        MinimumVersion: string option
        [<JsonPropertyName("model_repository")>]
        ModelRepository: string option
        [<JsonPropertyName("model_type")>]
        ModelType: string option
        [<JsonPropertyName("packaged_model_id")>]
        PackagedModelId: Id
        [<JsonPropertyName("platform_architecture")>]
        PlatformArchitecture: string option
        [<JsonPropertyName("prefix_strings")>]
        PrefixStrings: TypesTrainedModelPrefixStrings option
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("sha256")>]
        Sha256: string option
        [<JsonPropertyName("tags")>]
        Tags: string array option
        [<JsonPropertyName("vocabulary_file")>]
        VocabularyFile: string option
    }

    and TypesTrainedModelConfigInput = {
        [<JsonPropertyName("field_names")>]
        FieldNames: Field array
    }

    and TypesHyperparameter = {
        [<JsonPropertyName("absolute_importance")>]
        AbsoluteImportance: float option
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("relative_importance")>]
        RelativeImportance: float option
        [<JsonPropertyName("supplied")>]
        Supplied: bool
        [<JsonPropertyName("value")>]
        Value: float
    }

    and TypesTotalFeatureImportanceStatistics = {
        [<JsonPropertyName("mean_magnitude")>]
        MeanMagnitude: float
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("min")>]
        Min: float
    }

    and TypesTotalFeatureImportanceClass = {
        [<JsonPropertyName("class_name")>]
        ClassName: Name
        [<JsonPropertyName("importance")>]
        Importance: TypesTotalFeatureImportanceStatistics array
    }

    and TypesTotalFeatureImportance = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: Name
        [<JsonPropertyName("importance")>]
        Importance: TypesTotalFeatureImportanceStatistics array
        [<JsonPropertyName("classes")>]
        Classes: TypesTotalFeatureImportanceClass array
    }

    and TypesTrainedModelConfigMetadata = {
        [<JsonPropertyName("model_aliases")>]
        ModelAliases: string array option
        [<JsonPropertyName("feature_importance_baseline")>]
        FeatureImportanceBaseline: Map<string, string> option
        [<JsonPropertyName("hyperparameters")>]
        Hyperparameters: TypesHyperparameter array option
        [<JsonPropertyName("total_feature_importance")>]
        TotalFeatureImportance: TypesTotalFeatureImportance array option
    }

    and TypesTrainedModelLocationIndex = {
        [<JsonPropertyName("name")>]
        Name: IndexName
    }

    and TypesTrainedModelLocation = {
        [<JsonPropertyName("index")>]
        Index: TypesTrainedModelLocationIndex
    }

    and TypesTrainedModelTypeConverter() =
        inherit JsonConverter<TypesTrainedModelType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTrainedModelType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTrainedModelType.TreeEnsemble -> "tree_ensemble"
                | TypesTrainedModelType.LangIdent -> "lang_ident"
                | TypesTrainedModelType.Pytorch -> "pytorch"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "tree_ensemble" -> TypesTrainedModelType.TreeEnsemble
            | "lang_ident" -> TypesTrainedModelType.LangIdent
            | "pytorch" -> TypesTrainedModelType.Pytorch
            | s -> failwith $"Unknown TypesTrainedModelType: {s}"

    and [<JsonConverter(typeof<TypesTrainedModelTypeConverter>)>]
        TypesTrainedModelType =
        | TreeEnsemble
        | LangIdent
        | Pytorch
        with
        override this.ToString() =
            match this with
            | TreeEnsemble -> "tree_ensemble"
            | LangIdent -> "lang_ident"
            | Pytorch -> "pytorch"

    and TypesTrainedModelConfig = {
        [<JsonPropertyName("model_id")>]
        ModelId: Id
        [<JsonPropertyName("model_type")>]
        ModelType: TypesTrainedModelType option
        [<JsonPropertyName("tags")>]
        Tags: string array
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("compressed_definition")>]
        CompressedDefinition: string option
        [<JsonPropertyName("created_by")>]
        CreatedBy: string option
        [<JsonPropertyName("create_time")>]
        CreateTime: DateTime option
        [<JsonPropertyName("default_field_map")>]
        DefaultFieldMap: Map<string, string> option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("estimated_heap_memory_usage_bytes")>]
        EstimatedHeapMemoryUsageBytes: float option
        [<JsonPropertyName("estimated_operations")>]
        EstimatedOperations: float option
        [<JsonPropertyName("fully_defined")>]
        FullyDefined: bool option
        [<JsonPropertyName("inference_config")>]
        InferenceConfig: TypesInferenceConfigCreateContainer option
        [<JsonPropertyName("input")>]
        Input: TypesTrainedModelConfigInput
        [<JsonPropertyName("license_level")>]
        LicenseLevel: string option
        [<JsonPropertyName("metadata")>]
        Metadata: TypesTrainedModelConfigMetadata option
        [<JsonPropertyName("model_size_bytes")>]
        ModelSizeBytes: ByteSize option
        [<JsonPropertyName("model_package")>]
        ModelPackage: TypesModelPackageConfig option
        [<JsonPropertyName("location")>]
        Location: TypesTrainedModelLocation option
        [<JsonPropertyName("platform_architecture")>]
        PlatformArchitecture: string option
        [<JsonPropertyName("prefix_strings")>]
        PrefixStrings: TypesTrainedModelPrefixStrings option
    }

    and TypesAdaptiveAllocationsSettings = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("min_number_of_allocations")>]
        MinNumberOfAllocations: float option
        [<JsonPropertyName("max_number_of_allocations")>]
        MaxNumberOfAllocations: float option
    }

    and TypesDeploymentAssignmentStateConverter() =
        inherit JsonConverter<TypesDeploymentAssignmentState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDeploymentAssignmentState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDeploymentAssignmentState.Started -> "started"
                | TypesDeploymentAssignmentState.Starting -> "starting"
                | TypesDeploymentAssignmentState.Stopping -> "stopping"
                | TypesDeploymentAssignmentState.Failed -> "failed"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "started" -> TypesDeploymentAssignmentState.Started
            | "starting" -> TypesDeploymentAssignmentState.Starting
            | "stopping" -> TypesDeploymentAssignmentState.Stopping
            | "failed" -> TypesDeploymentAssignmentState.Failed
            | s -> failwith $"Unknown TypesDeploymentAssignmentState: {s}"

    and [<JsonConverter(typeof<TypesDeploymentAssignmentStateConverter>)>]
        TypesDeploymentAssignmentState =
        | Started
        | Starting
        | Stopping
        | Failed
        with
        override this.ToString() =
            match this with
            | Started -> "started"
            | Starting -> "starting"
            | Stopping -> "stopping"
            | Failed -> "failed"

    and TypesDeploymentAllocationStateConverter() =
        inherit JsonConverter<TypesDeploymentAllocationState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDeploymentAllocationState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDeploymentAllocationState.Started -> "started"
                | TypesDeploymentAllocationState.Starting -> "starting"
                | TypesDeploymentAllocationState.FullyAllocated -> "fully_allocated"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "started" -> TypesDeploymentAllocationState.Started
            | "starting" -> TypesDeploymentAllocationState.Starting
            | "fully_allocated" -> TypesDeploymentAllocationState.FullyAllocated
            | s -> failwith $"Unknown TypesDeploymentAllocationState: {s}"

    and [<JsonConverter(typeof<TypesDeploymentAllocationStateConverter>)>]
        TypesDeploymentAllocationState =
        | Started
        | Starting
        | FullyAllocated
        with
        override this.ToString() =
            match this with
            | Started -> "started"
            | Starting -> "starting"
            | FullyAllocated -> "fully_allocated"

    and TypesTrainedModelDeploymentAllocationStatus = {
        [<JsonPropertyName("allocation_count")>]
        AllocationCount: float
        [<JsonPropertyName("state")>]
        State: TypesDeploymentAllocationState
        [<JsonPropertyName("target_allocation_count")>]
        TargetAllocationCount: float
    }

    and TypesRoutingStateConverter() =
        inherit JsonConverter<TypesRoutingState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesRoutingState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesRoutingState.Failed -> "failed"
                | TypesRoutingState.Started -> "started"
                | TypesRoutingState.Starting -> "starting"
                | TypesRoutingState.Stopped -> "stopped"
                | TypesRoutingState.Stopping -> "stopping"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "failed" -> TypesRoutingState.Failed
            | "started" -> TypesRoutingState.Started
            | "starting" -> TypesRoutingState.Starting
            | "stopped" -> TypesRoutingState.Stopped
            | "stopping" -> TypesRoutingState.Stopping
            | s -> failwith $"Unknown TypesRoutingState: {s}"

    and [<JsonConverter(typeof<TypesRoutingStateConverter>)>]
        TypesRoutingState =
        | Failed
        | Started
        | Starting
        | Stopped
        | Stopping
        with
        override this.ToString() =
            match this with
            | Failed -> "failed"
            | Started -> "started"
            | Starting -> "starting"
            | Stopped -> "stopped"
            | Stopping -> "stopping"

    and TypesTrainedModelAssignmentRoutingStateAndReason = {
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("routing_state")>]
        RoutingState: TypesRoutingState
    }

    and TypesTrainedModelDeploymentNodesStats = {
        [<JsonPropertyName("average_inference_time_ms")>]
        AverageInferenceTimeMs: DurationValueUnitFloatMillis option
        [<JsonPropertyName("average_inference_time_ms_last_minute")>]
        AverageInferenceTimeMsLastMinute: DurationValueUnitFloatMillis option
        [<JsonPropertyName("average_inference_time_ms_excluding_cache_hits")>]
        AverageInferenceTimeMsExcludingCacheHits: DurationValueUnitFloatMillis option
        [<JsonPropertyName("error_count")>]
        ErrorCount: float option
        [<JsonPropertyName("inference_count")>]
        InferenceCount: float option
        [<JsonPropertyName("inference_cache_hit_count")>]
        InferenceCacheHitCount: float option
        [<JsonPropertyName("inference_cache_hit_count_last_minute")>]
        InferenceCacheHitCountLastMinute: float option
        [<JsonPropertyName("last_access")>]
        LastAccess: EpochTimeUnitMillis option
        [<JsonPropertyName("node")>]
        Node: TypesDiscoveryNode option
        [<JsonPropertyName("number_of_allocations")>]
        NumberOfAllocations: float option
        [<JsonPropertyName("number_of_pending_requests")>]
        NumberOfPendingRequests: float option
        [<JsonPropertyName("peak_throughput_per_minute")>]
        PeakThroughputPerMinute: float
        [<JsonPropertyName("rejected_execution_count")>]
        RejectedExecutionCount: float option
        [<JsonPropertyName("routing_state")>]
        RoutingState: TypesTrainedModelAssignmentRoutingStateAndReason
        [<JsonPropertyName("start_time")>]
        StartTime: EpochTimeUnitMillis option
        [<JsonPropertyName("threads_per_allocation")>]
        ThreadsPerAllocation: float option
        [<JsonPropertyName("throughput_last_minute")>]
        ThroughputLastMinute: float
        [<JsonPropertyName("timeout_count")>]
        TimeoutCount: float option
    }

    and TypesTrainingPriorityConverter() =
        inherit JsonConverter<TypesTrainingPriority>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTrainingPriority, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTrainingPriority.Normal -> "normal"
                | TypesTrainingPriority.Low -> "low"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "normal" -> TypesTrainingPriority.Normal
            | "low" -> TypesTrainingPriority.Low
            | s -> failwith $"Unknown TypesTrainingPriority: {s}"

    and [<JsonConverter(typeof<TypesTrainingPriorityConverter>)>]
        TypesTrainingPriority =
        | Normal
        | Low
        with
        override this.ToString() =
            match this with
            | Normal -> "normal"
            | Low -> "low"

    and TypesTrainedModelDeploymentStats = {
        [<JsonPropertyName("adaptive_allocations")>]
        AdaptiveAllocations: TypesAdaptiveAllocationsSettings option
        [<JsonPropertyName("allocation_status")>]
        AllocationStatus: TypesTrainedModelDeploymentAllocationStatus option
        [<JsonPropertyName("cache_size")>]
        CacheSize: ByteSize option
        [<JsonPropertyName("deployment_id")>]
        DeploymentId: Id
        [<JsonPropertyName("error_count")>]
        ErrorCount: float option
        [<JsonPropertyName("inference_count")>]
        InferenceCount: float option
        [<JsonPropertyName("model_id")>]
        ModelId: Id
        [<JsonPropertyName("nodes")>]
        Nodes: TypesTrainedModelDeploymentNodesStats array
        [<JsonPropertyName("number_of_allocations")>]
        NumberOfAllocations: float option
        [<JsonPropertyName("peak_throughput_per_minute")>]
        PeakThroughputPerMinute: float
        [<JsonPropertyName("priority")>]
        Priority: TypesTrainingPriority
        [<JsonPropertyName("queue_capacity")>]
        QueueCapacity: float option
        [<JsonPropertyName("rejected_execution_count")>]
        RejectedExecutionCount: float option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("start_time")>]
        StartTime: EpochTimeUnitMillis
        [<JsonPropertyName("state")>]
        State: TypesDeploymentAssignmentState option
        [<JsonPropertyName("threads_per_allocation")>]
        ThreadsPerAllocation: float option
        [<JsonPropertyName("timeout_count")>]
        TimeoutCount: float option
    }

    and TypesTrainedModelInferenceStats = {
        [<JsonPropertyName("cache_miss_count")>]
        CacheMissCount: float
        [<JsonPropertyName("failure_count")>]
        FailureCount: float
        [<JsonPropertyName("inference_count")>]
        InferenceCount: float
        [<JsonPropertyName("missing_all_fields_count")>]
        MissingAllFieldsCount: float
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
    }

    and TypesTrainedModelSizeStats = {
        [<JsonPropertyName("model_size_bytes")>]
        ModelSizeBytes: ByteSize
        [<JsonPropertyName("required_native_memory_bytes")>]
        RequiredNativeMemoryBytes: ByteSize
    }

    and TypesTrainedModelStats = {
        [<JsonPropertyName("deployment_stats")>]
        DeploymentStats: TypesTrainedModelDeploymentStats option
        [<JsonPropertyName("inference_stats")>]
        InferenceStats: TypesTrainedModelInferenceStats option
        [<JsonPropertyName("ingest")>]
        Ingest: Map<string, obj> option
        [<JsonPropertyName("model_id")>]
        ModelId: Id
        [<JsonPropertyName("model_size_stats")>]
        ModelSizeStats: TypesTrainedModelSizeStats
        [<JsonPropertyName("pipeline_count")>]
        PipelineCount: float
    }

    and TypesNlpTokenizationUpdateOptions = {
        [<JsonPropertyName("truncate")>]
        Truncate: TypesTokenizationTruncate option
        [<JsonPropertyName("span")>]
        Span: float option
    }

    and TypesFillMaskInferenceUpdateOptions = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
    }

    and TypesNerInferenceUpdateOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
    }

    and TypesPassThroughInferenceUpdateOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
    }

    and TypesQuestionAnsweringInferenceUpdateOptions = {
        [<JsonPropertyName("question")>]
        Question: string
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("max_answer_length")>]
        MaxAnswerLength: float option
    }

    and TypesTextClassificationInferenceUpdateOptions = {
        [<JsonPropertyName("num_top_classes")>]
        NumTopClasses: float option
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array option
    }

    and TypesTextEmbeddingInferenceUpdateOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
    }

    and TypesTextExpansionInferenceUpdateOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
    }

    and TypesZeroShotClassificationInferenceUpdateOptions = {
        [<JsonPropertyName("tokenization")>]
        Tokenization: TypesNlpTokenizationUpdateOptions option
        [<JsonPropertyName("results_field")>]
        ResultsField: string option
        [<JsonPropertyName("multi_label")>]
        MultiLabel: bool option
        [<JsonPropertyName("labels")>]
        Labels: string array
    }

    and TypesInferenceConfigUpdateContainer = {
        [<JsonPropertyName("regression")>]
        Regression: TypesRegressionInferenceOptions option
        [<JsonPropertyName("classification")>]
        Classification: TypesClassificationInferenceOptions option
        [<JsonPropertyName("text_classification")>]
        TextClassification: TypesTextClassificationInferenceUpdateOptions option
        [<JsonPropertyName("zero_shot_classification")>]
        ZeroShotClassification: TypesZeroShotClassificationInferenceUpdateOptions option
        [<JsonPropertyName("fill_mask")>]
        FillMask: TypesFillMaskInferenceUpdateOptions option
        [<JsonPropertyName("ner")>]
        Ner: TypesNerInferenceUpdateOptions option
        [<JsonPropertyName("pass_through")>]
        PassThrough: TypesPassThroughInferenceUpdateOptions option
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: TypesTextEmbeddingInferenceUpdateOptions option
        [<JsonPropertyName("text_expansion")>]
        TextExpansion: TypesTextExpansionInferenceUpdateOptions option
        [<JsonPropertyName("question_answering")>]
        QuestionAnswering: TypesQuestionAnsweringInferenceUpdateOptions option
    }

    and TypesPredictedValue = obj

    and TypesTopClassEntry = {
        [<JsonPropertyName("class_name")>]
        ClassName: string
        [<JsonPropertyName("class_probability")>]
        ClassProbability: float
        [<JsonPropertyName("class_score")>]
        ClassScore: float
    }

    and TypesTrainedModelEntities = {
        [<JsonPropertyName("class_name")>]
        ClassName: string
        [<JsonPropertyName("class_probability")>]
        ClassProbability: float
        [<JsonPropertyName("entity")>]
        Entity: string
        [<JsonPropertyName("start_pos")>]
        StartPos: float
        [<JsonPropertyName("end_pos")>]
        EndPos: float
    }

    and TypesTrainedModelInferenceClassImportance = {
        [<JsonPropertyName("class_name")>]
        ClassName: string
        [<JsonPropertyName("importance")>]
        Importance: float
    }

    and TypesTrainedModelInferenceFeatureImportance = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("importance")>]
        Importance: float option
        [<JsonPropertyName("classes")>]
        Classes: TypesTrainedModelInferenceClassImportance array option
    }

    and TypesInferenceResponseResult = {
        [<JsonPropertyName("entities")>]
        Entities: TypesTrainedModelEntities array option
        [<JsonPropertyName("is_truncated")>]
        IsTruncated: bool option
        [<JsonPropertyName("predicted_value")>]
        PredictedValue: System.Text.Json.JsonElement option
        [<JsonPropertyName("predicted_value_sequence")>]
        PredictedValueSequence: string option
        [<JsonPropertyName("prediction_probability")>]
        PredictionProbability: float option
        [<JsonPropertyName("prediction_score")>]
        PredictionScore: float option
        [<JsonPropertyName("top_classes")>]
        TopClasses: TypesTopClassEntry array option
        [<JsonPropertyName("warning")>]
        Warning: string option
        [<JsonPropertyName("feature_importance")>]
        FeatureImportance: TypesTrainedModelInferenceFeatureImportance array option
    }

    and InfoAnomalyDetectors = {
        [<JsonPropertyName("categorization_analyzer")>]
        CategorizationAnalyzer: TypesCategorizationAnalyzer
        [<JsonPropertyName("categorization_examples_limit")>]
        CategorizationExamplesLimit: float
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: string
        [<JsonPropertyName("model_snapshot_retention_days")>]
        ModelSnapshotRetentionDays: float
        [<JsonPropertyName("daily_model_snapshot_retention_after_days")>]
        DailyModelSnapshotRetentionAfterDays: float
    }

    and InfoDatafeeds = {
        [<JsonPropertyName("scroll_size")>]
        ScrollSize: float
    }

    and InfoDefaults = {
        [<JsonPropertyName("anomaly_detectors")>]
        AnomalyDetectors: InfoAnomalyDetectors
        [<JsonPropertyName("datafeeds")>]
        Datafeeds: InfoDatafeeds
    }

    and InfoLimits = {
        [<JsonPropertyName("max_single_ml_node_processors")>]
        MaxSingleMlNodeProcessors: float option
        [<JsonPropertyName("total_ml_processors")>]
        TotalMlProcessors: float option
        [<JsonPropertyName("max_model_memory_limit")>]
        MaxModelMemoryLimit: ByteSize option
        [<JsonPropertyName("effective_max_model_memory_limit")>]
        EffectiveMaxModelMemoryLimit: ByteSize option
        [<JsonPropertyName("total_ml_memory")>]
        TotalMlMemory: ByteSize
    }

    and InfoNativeCode = {
        [<JsonPropertyName("build_hash")>]
        BuildHash: string
        [<JsonPropertyName("version")>]
        Version: VersionString
    }

    and PreviewDataFrameAnalyticsDataframePreviewConfig = {
        [<JsonPropertyName("source")>]
        Source: TypesDataframeAnalyticsSource
        [<JsonPropertyName("analysis")>]
        Analysis: TypesDataframeAnalysisContainer
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: string option
        [<JsonPropertyName("max_num_threads")>]
        MaxNumThreads: float option
        [<JsonPropertyName("analyzed_fields")>]
        AnalyzedFields: TypesDataframeAnalysisAnalyzedFields option
    }

    and TypesDatafeedConfig = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregationContainer> option
        [<JsonPropertyName("chunking_config")>]
        ChunkingConfig: TypesChunkingConfig option
        [<JsonPropertyName("datafeed_id")>]
        DatafeedId: Id option
        [<JsonPropertyName("delayed_data_check_config")>]
        DelayedDataCheckConfig: TypesDelayedDataCheckConfig option
        [<JsonPropertyName("frequency")>]
        Frequency: Duration option
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("indices_options")>]
        IndicesOptions: IndicesOptions option
        [<JsonPropertyName("job_id")>]
        JobId: Id option
        [<JsonPropertyName("max_empty_searches")>]
        MaxEmptySearches: float option
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("query_delay")>]
        QueryDelay: Duration option
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
        [<JsonPropertyName("script_fields")>]
        ScriptFields: Map<string, ScriptField> option
        [<JsonPropertyName("scroll_size")>]
        ScrollSize: float option
    }

    and TypesJobConfig = {
        [<JsonPropertyName("allow_lazy_open")>]
        AllowLazyOpen: bool option
        [<JsonPropertyName("analysis_config")>]
        AnalysisConfig: TypesAnalysisConfig
        [<JsonPropertyName("analysis_limits")>]
        AnalysisLimits: TypesAnalysisLimits option
        [<JsonPropertyName("background_persist_interval")>]
        BackgroundPersistInterval: Duration option
        [<JsonPropertyName("custom_settings")>]
        CustomSettings: TypesCustomSettings option
        [<JsonPropertyName("daily_model_snapshot_retention_after_days")>]
        DailyModelSnapshotRetentionAfterDays: float option
        [<JsonPropertyName("data_description")>]
        DataDescription: TypesDataDescription
        [<JsonPropertyName("datafeed_config")>]
        DatafeedConfig: TypesDatafeedConfig option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("groups")>]
        Groups: string array option
        [<JsonPropertyName("job_id")>]
        JobId: Id option
        [<JsonPropertyName("model_plot_config")>]
        ModelPlotConfig: TypesModelPlotConfig option
        [<JsonPropertyName("model_snapshot_retention_days")>]
        ModelSnapshotRetentionDays: float option
        [<JsonPropertyName("renormalization_window_days")>]
        RenormalizationWindowDays: float option
        [<JsonPropertyName("results_index_name")>]
        ResultsIndexName: IndexName option
        [<JsonPropertyName("results_retention_days")>]
        ResultsRetentionDays: float option
    }

    and HttpHeaders = Map<string, System.Text.Json.JsonElement>

    and TypesDetectorRead = {
        [<JsonPropertyName("by_field_name")>]
        ByFieldName: Field option
        [<JsonPropertyName("custom_rules")>]
        CustomRules: TypesDetectionRule array option
        [<JsonPropertyName("detector_description")>]
        DetectorDescription: string option
        [<JsonPropertyName("detector_index")>]
        DetectorIndex: float option
        [<JsonPropertyName("exclude_frequent")>]
        ExcludeFrequent: TypesExcludeFrequent option
        [<JsonPropertyName("field_name")>]
        FieldName: Field option
        [<JsonPropertyName("function")>]
        Function: string
        [<JsonPropertyName("over_field_name")>]
        OverFieldName: Field option
        [<JsonPropertyName("partition_field_name")>]
        PartitionFieldName: Field option
        [<JsonPropertyName("use_null")>]
        UseNull: bool option
    }

    and TypesAnalysisConfigRead = {
        [<JsonPropertyName("bucket_span")>]
        BucketSpan: Duration
        [<JsonPropertyName("categorization_analyzer")>]
        CategorizationAnalyzer: TypesCategorizationAnalyzer option
        [<JsonPropertyName("categorization_field_name")>]
        CategorizationFieldName: Field option
        [<JsonPropertyName("categorization_filters")>]
        CategorizationFilters: string array option
        [<JsonPropertyName("detectors")>]
        Detectors: TypesDetectorRead array
        [<JsonPropertyName("influencers")>]
        Influencers: Field array
        [<JsonPropertyName("model_prune_window")>]
        ModelPruneWindow: Duration option
        [<JsonPropertyName("latency")>]
        Latency: Duration option
        [<JsonPropertyName("multivariate_by_fields")>]
        MultivariateByFields: bool option
        [<JsonPropertyName("per_partition_categorization")>]
        PerPartitionCategorization: TypesPerPartitionCategorization option
        [<JsonPropertyName("summary_count_field_name")>]
        SummaryCountFieldName: Field option
    }

    and PutTrainedModelFrequencyEncodingPreprocessor = {
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("frequency_map")>]
        FrequencyMap: Map<string, float>
    }

    and PutTrainedModelOneHotEncodingPreprocessor = {
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("hot_map")>]
        HotMap: Map<string, string>
    }

    and PutTrainedModelTargetMeanEncodingPreprocessor = {
        [<JsonPropertyName("field")>]
        Field: string
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("target_map")>]
        TargetMap: Map<string, float>
        [<JsonPropertyName("default_value")>]
        DefaultValue: float
    }

    and PutTrainedModelPreprocessor = {
        [<JsonPropertyName("frequency_encoding")>]
        FrequencyEncoding: PutTrainedModelFrequencyEncodingPreprocessor option
        [<JsonPropertyName("one_hot_encoding")>]
        OneHotEncoding: PutTrainedModelOneHotEncodingPreprocessor option
        [<JsonPropertyName("target_mean_encoding")>]
        TargetMeanEncoding: PutTrainedModelTargetMeanEncodingPreprocessor option
    }

    and PutTrainedModelWeights = {
        [<JsonPropertyName("weights")>]
        Weights: float
    }

    and PutTrainedModelAggregateOutput = {
        [<JsonPropertyName("logistic_regression")>]
        LogisticRegression: PutTrainedModelWeights option
        [<JsonPropertyName("weighted_sum")>]
        WeightedSum: PutTrainedModelWeights option
        [<JsonPropertyName("weighted_mode")>]
        WeightedMode: PutTrainedModelWeights option
        [<JsonPropertyName("exponent")>]
        Exponent: PutTrainedModelWeights option
    }

    and PutTrainedModelEnsemble = {
        [<JsonPropertyName("aggregate_output")>]
        AggregateOutput: PutTrainedModelAggregateOutput option
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array option
        [<JsonPropertyName("feature_names")>]
        FeatureNames: string array option
        [<JsonPropertyName("target_type")>]
        TargetType: string option
        [<JsonPropertyName("trained_models")>]
        TrainedModels: PutTrainedModelTrainedModel array
    }

    and PutTrainedModelTrainedModelTreeNode = {
        [<JsonPropertyName("decision_type")>]
        DecisionType: string option
        [<JsonPropertyName("default_left")>]
        DefaultLeft: bool option
        [<JsonPropertyName("leaf_value")>]
        LeafValue: float option
        [<JsonPropertyName("left_child")>]
        LeftChild: float option
        [<JsonPropertyName("node_index")>]
        NodeIndex: float
        [<JsonPropertyName("right_child")>]
        RightChild: float option
        [<JsonPropertyName("split_feature")>]
        SplitFeature: float option
        [<JsonPropertyName("split_gain")>]
        SplitGain: float option
        [<JsonPropertyName("threshold")>]
        Threshold: float option
    }

    and PutTrainedModelTrainedModelTree = {
        [<JsonPropertyName("classification_labels")>]
        ClassificationLabels: string array option
        [<JsonPropertyName("feature_names")>]
        FeatureNames: string array
        [<JsonPropertyName("target_type")>]
        TargetType: string option
        [<JsonPropertyName("tree_structure")>]
        TreeStructure: PutTrainedModelTrainedModelTreeNode array
    }

    and PutTrainedModelTrainedModel = {
        [<JsonPropertyName("tree")>]
        Tree: PutTrainedModelTrainedModelTree option
        [<JsonPropertyName("tree_node")>]
        TreeNode: PutTrainedModelTrainedModelTreeNode option
        [<JsonPropertyName("ensemble")>]
        Ensemble: PutTrainedModelEnsemble option
    }

    and PutTrainedModelDefinition = {
        [<JsonPropertyName("preprocessors")>]
        Preprocessors: PutTrainedModelPreprocessor array option
        [<JsonPropertyName("trained_model")>]
        TrainedModel: PutTrainedModelTrainedModel
    }

    and PutTrainedModelInput = {
        [<JsonPropertyName("field_names")>]
        FieldNames: Names
    }

    and TypesTrainedModelAssignmentRoutingTable = {
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("routing_state")>]
        RoutingState: TypesRoutingState
        [<JsonPropertyName("current_allocations")>]
        CurrentAllocations: float
        [<JsonPropertyName("target_allocations")>]
        TargetAllocations: float
    }

    and TypesTrainedModelAssignmentTaskParameters = {
        [<JsonPropertyName("model_bytes")>]
        ModelBytes: ByteSize
        [<JsonPropertyName("model_id")>]
        ModelId: Id
        [<JsonPropertyName("deployment_id")>]
        DeploymentId: Id
        [<JsonPropertyName("cache_size")>]
        CacheSize: ByteSize option
        [<JsonPropertyName("number_of_allocations")>]
        NumberOfAllocations: float
        [<JsonPropertyName("priority")>]
        Priority: TypesTrainingPriority
        [<JsonPropertyName("per_deployment_memory_bytes")>]
        PerDeploymentMemoryBytes: ByteSize
        [<JsonPropertyName("per_allocation_memory_bytes")>]
        PerAllocationMemoryBytes: ByteSize
        [<JsonPropertyName("queue_capacity")>]
        QueueCapacity: float
        [<JsonPropertyName("threads_per_allocation")>]
        ThreadsPerAllocation: float
    }

    and TypesTrainedModelAssignment = {
        [<JsonPropertyName("adaptive_allocations")>]
        AdaptiveAllocations: System.Text.Json.JsonElement option
        [<JsonPropertyName("assignment_state")>]
        AssignmentState: TypesDeploymentAssignmentState
        [<JsonPropertyName("max_assigned_allocations")>]
        MaxAssignedAllocations: float option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("routing_table")>]
        RoutingTable: Map<string, TypesTrainedModelAssignmentRoutingTable>
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime
        [<JsonPropertyName("task_parameters")>]
        TaskParameters: TypesTrainedModelAssignmentTaskParameters
    }

    and TypesAnalysisMemoryLimit = {
        [<JsonPropertyName("model_memory_limit")>]
        ModelMemoryLimit: string
    }

    and TypesDetectorUpdate = {
        [<JsonPropertyName("detector_index")>]
        DetectorIndex: float
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("custom_rules")>]
        CustomRules: TypesDetectionRule array option
    }

    and MsearchMultiSearchResult = {
        [<JsonPropertyName("took")>]
        Took: float
        [<JsonPropertyName("responses")>]
        Responses: MsearchResponseItem array
    }

    and MsearchTemplateTemplateConfig = {
        [<JsonPropertyName("explain")>]
        Explain: bool option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("profile")>]
        Profile: bool option
        [<JsonPropertyName("source")>]
        Source: ScriptSource option
    }

    and MsearchTemplateRequestItem = obj

    and TermvectorsFilter = {
        [<JsonPropertyName("max_doc_freq")>]
        MaxDocFreq: float option
        [<JsonPropertyName("max_num_terms")>]
        MaxNumTerms: float option
        [<JsonPropertyName("max_term_freq")>]
        MaxTermFreq: float option
        [<JsonPropertyName("max_word_length")>]
        MaxWordLength: float option
        [<JsonPropertyName("min_doc_freq")>]
        MinDocFreq: float option
        [<JsonPropertyName("min_term_freq")>]
        MinTermFreq: float option
        [<JsonPropertyName("min_word_length")>]
        MinWordLength: float option
    }

    and MtermvectorsOperation = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName option
        [<JsonPropertyName("doc")>]
        Doc: obj option
        [<JsonPropertyName("fields")>]
        Fields: Fields option
        [<JsonPropertyName("field_statistics")>]
        FieldStatistics: bool option
        [<JsonPropertyName("filter")>]
        Filter: TermvectorsFilter option
        [<JsonPropertyName("offsets")>]
        Offsets: bool option
        [<JsonPropertyName("payloads")>]
        Payloads: bool option
        [<JsonPropertyName("positions")>]
        Positions: bool option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("term_statistics")>]
        TermStatistics: bool option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and TermvectorsFieldStatistics = {
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("sum_doc_freq")>]
        SumDocFreq: float
        [<JsonPropertyName("sum_ttf")>]
        SumTtf: float
    }

    and TermvectorsToken = {
        [<JsonPropertyName("end_offset")>]
        EndOffset: float option
        [<JsonPropertyName("payload")>]
        Payload: string option
        [<JsonPropertyName("position")>]
        Position: float
        [<JsonPropertyName("start_offset")>]
        StartOffset: float option
    }

    and TermvectorsTerm = {
        [<JsonPropertyName("doc_freq")>]
        DocFreq: float option
        [<JsonPropertyName("score")>]
        Score: float option
        [<JsonPropertyName("term_freq")>]
        TermFreq: float
        [<JsonPropertyName("tokens")>]
        Tokens: TermvectorsToken array option
        [<JsonPropertyName("ttf")>]
        Ttf: float option
    }

    and TermvectorsTermVector = {
        [<JsonPropertyName("field_statistics")>]
        FieldStatistics: TermvectorsFieldStatistics option
        [<JsonPropertyName("terms")>]
        Terms: Map<string, TermvectorsTerm>
    }

    and MtermvectorsTermVectorsResult = {
        [<JsonPropertyName("_id")>]
        Id: Id option
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_version")>]
        Version: VersionNumber option
        [<JsonPropertyName("took")>]
        Took: float option
        [<JsonPropertyName("found")>]
        Found: bool option
        [<JsonPropertyName("term_vectors")>]
        TermVectors: Map<string, TermvectorsTermVector> option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
    }

    and TypesRepositoryLocation = {
        [<JsonPropertyName("base_path")>]
        BasePath: string
        [<JsonPropertyName("container")>]
        Container: string option
        [<JsonPropertyName("bucket")>]
        Bucket: string option
    }

    and TypesRequestCounts = {
        [<JsonPropertyName("GetBlobProperties")>]
        GetBlobProperties: float option
        [<JsonPropertyName("GetBlob")>]
        GetBlob: float option
        [<JsonPropertyName("ListBlobs")>]
        ListBlobs: float option
        [<JsonPropertyName("PutBlob")>]
        PutBlob: float option
        [<JsonPropertyName("PutBlock")>]
        PutBlock: float option
        [<JsonPropertyName("PutBlockList")>]
        PutBlockList: float option
        [<JsonPropertyName("GetObject")>]
        GetObject: float option
        [<JsonPropertyName("ListObjects")>]
        ListObjects: float option
        [<JsonPropertyName("InsertObject")>]
        InsertObject: float option
        [<JsonPropertyName("PutObject")>]
        PutObject: float option
        [<JsonPropertyName("PutMultipartObject")>]
        PutMultipartObject: float option
    }

    and TypesRepositoryMeteringInformation = {
        [<JsonPropertyName("repository_name")>]
        RepositoryName: Name
        [<JsonPropertyName("repository_type")>]
        RepositoryType: string
        [<JsonPropertyName("repository_location")>]
        RepositoryLocation: TypesRepositoryLocation
        [<JsonPropertyName("repository_ephemeral_id")>]
        RepositoryEphemeralId: Id
        [<JsonPropertyName("repository_started_at")>]
        RepositoryStartedAt: EpochTimeUnitMillis
        [<JsonPropertyName("repository_stopped_at")>]
        RepositoryStoppedAt: EpochTimeUnitMillis option
        [<JsonPropertyName("archived")>]
        Archived: bool
        [<JsonPropertyName("cluster_version")>]
        ClusterVersion: VersionNumber option
        [<JsonPropertyName("request_counts")>]
        RequestCounts: TypesRequestCounts
    }

    and ClearRepositoriesMeteringArchiveResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, TypesRepositoryMeteringInformation>
    }

    and GetRepositoriesMeteringInfoResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, TypesRepositoryMeteringInformation>
    }

    and ThreadTypeConverter() =
        inherit JsonConverter<ThreadType>()

        override _.Write(writer: Utf8JsonWriter, value: ThreadType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ThreadType.Cpu -> "cpu"
                | ThreadType.Wait -> "wait"
                | ThreadType.Block -> "block"
                | ThreadType.Gpu -> "gpu"
                | ThreadType.Mem -> "mem"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cpu" -> ThreadType.Cpu
            | "wait" -> ThreadType.Wait
            | "block" -> ThreadType.Block
            | "gpu" -> ThreadType.Gpu
            | "mem" -> ThreadType.Mem
            | s -> failwith $"Unknown ThreadType: {s}"

    and [<JsonConverter(typeof<ThreadTypeConverter>)>]
        ThreadType =
        | Cpu
        | Wait
        | Block
        | Gpu
        | Mem
        with
        override this.ToString() =
            match this with
            | Cpu -> "cpu"
            | Wait -> "wait"
            | Block -> "block"
            | Gpu -> "gpu"
            | Mem -> "mem"

    and InfoNodesInfoMetricConverter() =
        inherit JsonConverter<InfoNodesInfoMetric>()

        override _.Write(writer: Utf8JsonWriter, value: InfoNodesInfoMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | InfoNodesInfoMetric.All -> "_all"
                | InfoNodesInfoMetric.None -> "_none"
                | InfoNodesInfoMetric.Settings -> "settings"
                | InfoNodesInfoMetric.Os -> "os"
                | InfoNodesInfoMetric.Process -> "process"
                | InfoNodesInfoMetric.Jvm -> "jvm"
                | InfoNodesInfoMetric.ThreadPool -> "thread_pool"
                | InfoNodesInfoMetric.Transport -> "transport"
                | InfoNodesInfoMetric.Http -> "http"
                | InfoNodesInfoMetric.RemoteClusterServer -> "remote_cluster_server"
                | InfoNodesInfoMetric.Plugins -> "plugins"
                | InfoNodesInfoMetric.Ingest -> "ingest"
                | InfoNodesInfoMetric.Aggregations -> "aggregations"
                | InfoNodesInfoMetric.Indices -> "indices"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> InfoNodesInfoMetric.All
            | "_none" -> InfoNodesInfoMetric.None
            | "settings" -> InfoNodesInfoMetric.Settings
            | "os" -> InfoNodesInfoMetric.Os
            | "process" -> InfoNodesInfoMetric.Process
            | "jvm" -> InfoNodesInfoMetric.Jvm
            | "thread_pool" -> InfoNodesInfoMetric.ThreadPool
            | "transport" -> InfoNodesInfoMetric.Transport
            | "http" -> InfoNodesInfoMetric.Http
            | "remote_cluster_server" -> InfoNodesInfoMetric.RemoteClusterServer
            | "plugins" -> InfoNodesInfoMetric.Plugins
            | "ingest" -> InfoNodesInfoMetric.Ingest
            | "aggregations" -> InfoNodesInfoMetric.Aggregations
            | "indices" -> InfoNodesInfoMetric.Indices
            | s -> failwith $"Unknown InfoNodesInfoMetric: {s}"

    and [<JsonConverter(typeof<InfoNodesInfoMetricConverter>)>]
        InfoNodesInfoMetric =
        | All
        | None
        | Settings
        | Os
        | Process
        | Jvm
        | ThreadPool
        | Transport
        | Http
        | RemoteClusterServer
        | Plugins
        | Ingest
        | Aggregations
        | Indices
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | None -> "_none"
            | Settings -> "settings"
            | Os -> "os"
            | Process -> "process"
            | Jvm -> "jvm"
            | ThreadPool -> "thread_pool"
            | Transport -> "transport"
            | Http -> "http"
            | RemoteClusterServer -> "remote_cluster_server"
            | Plugins -> "plugins"
            | Ingest -> "ingest"
            | Aggregations -> "aggregations"
            | Indices -> "indices"

    and InfoNodesInfoMetrics = obj

    and InfoNodeInfoAggregation = {
        [<JsonPropertyName("types")>]
        Types: string array
    }

    and InfoNodeInfoHttp = {
        [<JsonPropertyName("bound_address")>]
        BoundAddress: string array
        [<JsonPropertyName("max_content_length")>]
        MaxContentLength: ByteSize option
        [<JsonPropertyName("max_content_length_in_bytes")>]
        MaxContentLengthInBytes: float
        [<JsonPropertyName("publish_address")>]
        PublishAddress: string
    }

    and InfoNodeInfoIngestProcessor = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and InfoNodeInfoIngest = {
        [<JsonPropertyName("processors")>]
        Processors: InfoNodeInfoIngestProcessor array
    }

    and InfoNodeInfoAction = {
        [<JsonPropertyName("destructive_requires_name")>]
        DestructiveRequiresName: string
    }

    and InfoNodeInfoBootstrap = {
        [<JsonPropertyName("memory_lock")>]
        MemoryLock: string
    }

    and InfoNodeInfoClient = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and InfoNodeInfoDiscover = {
        [<JsonPropertyName("seed_hosts")>]
        SeedHosts: System.Text.Json.JsonElement option
        [<JsonPropertyName("type")>]
        Type: string option
        [<JsonPropertyName("seed_providers")>]
        SeedProviders: string array option
    }

    and InfoNodeInfoPath = {
        [<JsonPropertyName("logs")>]
        Logs: string option
        [<JsonPropertyName("home")>]
        Home: string option
        [<JsonPropertyName("repo")>]
        Repo: string array option
        [<JsonPropertyName("data")>]
        Data: System.Text.Json.JsonElement option
    }

    and InfoNodeInfoRepositoriesUrl = {
        [<JsonPropertyName("allowed_urls")>]
        AllowedUrls: string
    }

    and InfoNodeInfoRepositories = {
        [<JsonPropertyName("url")>]
        Url: InfoNodeInfoRepositoriesUrl
    }

    and InfoNodeInfoScript = {
        [<JsonPropertyName("allowed_types")>]
        AllowedTypes: string
        [<JsonPropertyName("disable_max_compilations_rate")>]
        DisableMaxCompilationsRate: string option
    }

    and InfoNodeInfoSearchRemote = {
        [<JsonPropertyName("connect")>]
        Connect: string
    }

    and InfoNodeInfoSearch = {
        [<JsonPropertyName("remote")>]
        Remote: InfoNodeInfoSearchRemote
    }

    and InfoDeprecationIndexing = {
        [<JsonPropertyName("enabled")>]
        Enabled: System.Text.Json.JsonElement
    }

    and InfoNodeInfoSettingsClusterElection = {
        [<JsonPropertyName("strategy")>]
        Strategy: Name
    }

    and InfoNodeInfoSettingsCluster = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("routing")>]
        Routing: TypesIndexRouting option
        [<JsonPropertyName("election")>]
        Election: InfoNodeInfoSettingsClusterElection
        [<JsonPropertyName("initial_master_nodes")>]
        InitialMasterNodes: System.Text.Json.JsonElement option
        [<JsonPropertyName("deprecation_indexing")>]
        DeprecationIndexing: InfoDeprecationIndexing option
    }

    and InfoNodeInfoSettingsHttpType = {
        [<JsonPropertyName("default")>]
        Default: string
    }

    and InfoNodeInfoSettingsHttp = {
        [<JsonPropertyName("type")>]
        Type: InfoNodeInfoSettingsHttpType
        [<JsonPropertyName("type.default")>]
        TypeDefault: string option
        [<JsonPropertyName("compression")>]
        Compression: System.Text.Json.JsonElement option
        [<JsonPropertyName("port")>]
        Port: System.Text.Json.JsonElement option
    }

    and InfoNodeInfoIngestDownloader = {
        [<JsonPropertyName("enabled")>]
        Enabled: string
    }

    and InfoNodeInfoIngestInfo = {
        [<JsonPropertyName("downloader")>]
        Downloader: InfoNodeInfoIngestDownloader
    }

    and InfoNodeInfoSettingsIngest = {
        [<JsonPropertyName("attachment")>]
        Attachment: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("append")>]
        Append: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("csv")>]
        Csv: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("convert")>]
        Convert: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("date")>]
        Date: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("date_index_name")>]
        DateIndexName: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("dot_expander")>]
        DotExpander: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("enrich")>]
        Enrich: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("fail")>]
        Fail: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("foreach")>]
        Foreach: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("json")>]
        Json: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("user_agent")>]
        UserAgent: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("kv")>]
        Kv: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("geoip")>]
        Geoip: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("grok")>]
        Grok: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("gsub")>]
        Gsub: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("join")>]
        Join: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("lowercase")>]
        Lowercase: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("remove")>]
        Remove: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("rename")>]
        Rename: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("script")>]
        Script: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("set")>]
        Set: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("sort")>]
        Sort: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("split")>]
        Split: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("trim")>]
        Trim: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("uppercase")>]
        Uppercase: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("urldecode")>]
        Urldecode: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("bytes")>]
        Bytes: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("dissect")>]
        Dissect: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("set_security_user")>]
        SetSecurityUser: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("pipeline")>]
        Pipeline: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("drop")>]
        Drop: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("circle")>]
        Circle: InfoNodeInfoIngestInfo option
        [<JsonPropertyName("inference")>]
        Inference: InfoNodeInfoIngestInfo option
    }

    and InfoNodeInfoSettingsNetwork = {
        [<JsonPropertyName("host")>]
        Host: System.Text.Json.JsonElement option
    }

    and InfoNodeInfoSettingsNode = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("attr")>]
        Attr: Map<string, obj>
        [<JsonPropertyName("max_local_storage_nodes")>]
        MaxLocalStorageNodes: string option
    }

    and InfoNodeInfoSettingsTransportFeatures = {
        [<JsonPropertyName("x-pack")>]
        XPack: string
    }

    and InfoNodeInfoSettingsTransportType = {
        [<JsonPropertyName("default")>]
        Default: string
    }

    and InfoNodeInfoSettingsTransport = {
        [<JsonPropertyName("type")>]
        Type: InfoNodeInfoSettingsTransportType
        [<JsonPropertyName("type.default")>]
        TypeDefault: string option
        [<JsonPropertyName("features")>]
        Features: InfoNodeInfoSettingsTransportFeatures option
    }

    and InfoNodeInfoXpackLicenseType = {
        [<JsonPropertyName("type")>]
        Type: string
    }

    and InfoNodeInfoXpackLicense = {
        [<JsonPropertyName("self_generated")>]
        SelfGenerated: InfoNodeInfoXpackLicenseType
    }

    and InfoNodeInfoXpackMl = {
        [<JsonPropertyName("use_auto_machine_memory_percent")>]
        UseAutoMachineMemoryPercent: bool option
    }

    and InfoNodeInfoXpackSecurityAuthcRealmsStatus = {
        [<JsonPropertyName("enabled")>]
        Enabled: string option
        [<JsonPropertyName("order")>]
        Order: string
    }

    and InfoNodeInfoXpackSecurityAuthcRealms = {
        [<JsonPropertyName("file")>]
        File: Map<string, InfoNodeInfoXpackSecurityAuthcRealmsStatus> option
        [<JsonPropertyName("native")>]
        Native: Map<string, InfoNodeInfoXpackSecurityAuthcRealmsStatus> option
        [<JsonPropertyName("pki")>]
        Pki: Map<string, InfoNodeInfoXpackSecurityAuthcRealmsStatus> option
    }

    and InfoNodeInfoXpackSecurityAuthcToken = {
        [<JsonPropertyName("enabled")>]
        Enabled: string
    }

    and InfoNodeInfoXpackSecurityAuthc = {
        [<JsonPropertyName("realms")>]
        Realms: InfoNodeInfoXpackSecurityAuthcRealms option
        [<JsonPropertyName("token")>]
        Token: InfoNodeInfoXpackSecurityAuthcToken option
    }

    and InfoNodeInfoXpackSecuritySsl = {
        [<JsonPropertyName("ssl")>]
        Ssl: Map<string, string>
    }

    and InfoNodeInfoXpackSecurity = {
        [<JsonPropertyName("http")>]
        Http: InfoNodeInfoXpackSecuritySsl option
        [<JsonPropertyName("enabled")>]
        Enabled: string
        [<JsonPropertyName("transport")>]
        Transport: InfoNodeInfoXpackSecuritySsl option
        [<JsonPropertyName("authc")>]
        Authc: InfoNodeInfoXpackSecurityAuthc option
    }

    and InfoNodeInfoXpack = {
        [<JsonPropertyName("license")>]
        License: InfoNodeInfoXpackLicense option
        [<JsonPropertyName("security")>]
        Security: InfoNodeInfoXpackSecurity
        [<JsonPropertyName("notification")>]
        Notification: Map<string, obj> option
        [<JsonPropertyName("ml")>]
        Ml: InfoNodeInfoXpackMl option
    }

    and InfoNodeInfoSettings = {
        [<JsonPropertyName("cluster")>]
        Cluster: InfoNodeInfoSettingsCluster
        [<JsonPropertyName("node")>]
        Node: InfoNodeInfoSettingsNode
        [<JsonPropertyName("path")>]
        Path: InfoNodeInfoPath option
        [<JsonPropertyName("repositories")>]
        Repositories: InfoNodeInfoRepositories option
        [<JsonPropertyName("discovery")>]
        Discovery: InfoNodeInfoDiscover option
        [<JsonPropertyName("action")>]
        Action: InfoNodeInfoAction option
        [<JsonPropertyName("client")>]
        Client: InfoNodeInfoClient option
        [<JsonPropertyName("http")>]
        Http: InfoNodeInfoSettingsHttp
        [<JsonPropertyName("bootstrap")>]
        Bootstrap: InfoNodeInfoBootstrap option
        [<JsonPropertyName("transport")>]
        Transport: InfoNodeInfoSettingsTransport
        [<JsonPropertyName("network")>]
        Network: InfoNodeInfoSettingsNetwork option
        [<JsonPropertyName("xpack")>]
        Xpack: InfoNodeInfoXpack option
        [<JsonPropertyName("script")>]
        Script: InfoNodeInfoScript option
        [<JsonPropertyName("search")>]
        Search: InfoNodeInfoSearch option
        [<JsonPropertyName("ingest")>]
        Ingest: InfoNodeInfoSettingsIngest option
    }

    and InfoNodeInfoTransport = {
        [<JsonPropertyName("bound_address")>]
        BoundAddress: string array
        [<JsonPropertyName("publish_address")>]
        PublishAddress: string
        [<JsonPropertyName("profiles")>]
        Profiles: Map<string, string>
    }

    and InfoNodeInfoJvmMemory = {
        [<JsonPropertyName("direct_max")>]
        DirectMax: ByteSize option
        [<JsonPropertyName("direct_max_in_bytes")>]
        DirectMaxInBytes: float
        [<JsonPropertyName("heap_init")>]
        HeapInit: ByteSize option
        [<JsonPropertyName("heap_init_in_bytes")>]
        HeapInitInBytes: float
        [<JsonPropertyName("heap_max")>]
        HeapMax: ByteSize option
        [<JsonPropertyName("heap_max_in_bytes")>]
        HeapMaxInBytes: float
        [<JsonPropertyName("non_heap_init")>]
        NonHeapInit: ByteSize option
        [<JsonPropertyName("non_heap_init_in_bytes")>]
        NonHeapInitInBytes: float
        [<JsonPropertyName("non_heap_max")>]
        NonHeapMax: ByteSize option
        [<JsonPropertyName("non_heap_max_in_bytes")>]
        NonHeapMaxInBytes: float
    }

    and InfoNodeJvmInfo = {
        [<JsonPropertyName("gc_collectors")>]
        GcCollectors: string array
        [<JsonPropertyName("mem")>]
        Mem: InfoNodeInfoJvmMemory
        [<JsonPropertyName("memory_pools")>]
        MemoryPools: string array
        [<JsonPropertyName("pid")>]
        Pid: float
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("vm_name")>]
        VmName: Name
        [<JsonPropertyName("vm_vendor")>]
        VmVendor: string
        [<JsonPropertyName("vm_version")>]
        VmVersion: VersionString
        [<JsonPropertyName("using_bundled_jdk")>]
        UsingBundledJdk: bool
        [<JsonPropertyName("using_compressed_ordinary_object_pointers")>]
        UsingCompressedOrdinaryObjectPointers: System.Text.Json.JsonElement option
        [<JsonPropertyName("input_arguments")>]
        InputArguments: string array
    }

    and InfoNodeInfoMemory = {
        [<JsonPropertyName("total")>]
        Total: string
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float
    }

    and InfoNodeInfoOSCPU = {
        [<JsonPropertyName("cache_size")>]
        CacheSize: string
        [<JsonPropertyName("cache_size_in_bytes")>]
        CacheSizeInBytes: float
        [<JsonPropertyName("cores_per_socket")>]
        CoresPerSocket: float
        [<JsonPropertyName("mhz")>]
        Mhz: float
        [<JsonPropertyName("model")>]
        Model: string
        [<JsonPropertyName("total_cores")>]
        TotalCores: float
        [<JsonPropertyName("total_sockets")>]
        TotalSockets: float
        [<JsonPropertyName("vendor")>]
        Vendor: string
    }

    and InfoNodeOperatingSystemInfo = {
        [<JsonPropertyName("arch")>]
        Arch: string
        [<JsonPropertyName("available_processors")>]
        AvailableProcessors: float
        [<JsonPropertyName("allocated_processors")>]
        AllocatedProcessors: float option
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("pretty_name")>]
        PrettyName: Name
        [<JsonPropertyName("refresh_interval_in_millis")>]
        RefreshIntervalInMillis: DurationValueUnitMillis
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("cpu")>]
        Cpu: InfoNodeInfoOSCPU option
        [<JsonPropertyName("mem")>]
        Mem: InfoNodeInfoMemory option
        [<JsonPropertyName("swap")>]
        Swap: InfoNodeInfoMemory option
    }

    and InfoNodeProcessInfo = {
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("mlockall")>]
        Mlockall: bool
        [<JsonPropertyName("refresh_interval_in_millis")>]
        RefreshIntervalInMillis: DurationValueUnitMillis
    }

    and InfoNodeThreadPoolInfo = {
        [<JsonPropertyName("core")>]
        Core: float option
        [<JsonPropertyName("keep_alive")>]
        KeepAlive: Duration option
        [<JsonPropertyName("max")>]
        Max: float option
        [<JsonPropertyName("queue_size")>]
        QueueSize: float
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("type")>]
        Type: string
    }

    and InfoRemoveClusterServer = {
        [<JsonPropertyName("bound_address")>]
        BoundAddress: TransportAddress array
        [<JsonPropertyName("publish_address")>]
        PublishAddress: TransportAddress
    }

    and InfoNodeInfo = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("build_flavor")>]
        BuildFlavor: string
        [<JsonPropertyName("build_hash")>]
        BuildHash: string
        [<JsonPropertyName("build_type")>]
        BuildType: string
        [<JsonPropertyName("component_versions")>]
        ComponentVersions: Map<string, float>
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("http")>]
        Http: InfoNodeInfoHttp option
        [<JsonPropertyName("index_version")>]
        IndexVersion: VersionNumber
        [<JsonPropertyName("ip")>]
        Ip: Ip
        [<JsonPropertyName("jvm")>]
        Jvm: InfoNodeJvmInfo option
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("os")>]
        Os: InfoNodeOperatingSystemInfo option
        [<JsonPropertyName("plugins")>]
        Plugins: PluginStats array option
        [<JsonPropertyName("process")>]
        Process: InfoNodeProcessInfo option
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles
        [<JsonPropertyName("settings")>]
        Settings: InfoNodeInfoSettings option
        [<JsonPropertyName("thread_pool")>]
        ThreadPool: Map<string, InfoNodeThreadPoolInfo> option
        [<JsonPropertyName("total_indexing_buffer")>]
        TotalIndexingBuffer: float option
        [<JsonPropertyName("total_indexing_buffer_in_bytes")>]
        TotalIndexingBufferInBytes: ByteSize option
        [<JsonPropertyName("transport")>]
        Transport: InfoNodeInfoTransport option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("transport_version")>]
        TransportVersion: VersionNumber
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("modules")>]
        Modules: PluginStats array option
        [<JsonPropertyName("ingest")>]
        Ingest: InfoNodeInfoIngest option
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, InfoNodeInfoAggregation> option
        [<JsonPropertyName("remote_cluster_server")>]
        RemoteClusterServer: InfoRemoveClusterServer option
    }

    and InfoResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, InfoNodeInfo>
    }

    and Password = string

    and TypesNodeReloadResult = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("reload_exception")>]
        ReloadException: ErrorCause option
        [<JsonPropertyName("secure_setting_names")>]
        SecureSettingNames: string array option
        [<JsonPropertyName("keystore_path")>]
        KeystorePath: string option
        [<JsonPropertyName("keystore_digest")>]
        KeystoreDigest: string option
        [<JsonPropertyName("keystore_last_modified_time")>]
        KeystoreLastModifiedTime: DateTime option
    }

    and ReloadSecureSettingsResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, TypesNodeReloadResult>
    }

    and StatsNodeStatsMetricConverter() =
        inherit JsonConverter<StatsNodeStatsMetric>()

        override _.Write(writer: Utf8JsonWriter, value: StatsNodeStatsMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StatsNodeStatsMetric.All -> "_all"
                | StatsNodeStatsMetric.None -> "_none"
                | StatsNodeStatsMetric.Indices -> "indices"
                | StatsNodeStatsMetric.Os -> "os"
                | StatsNodeStatsMetric.Process -> "process"
                | StatsNodeStatsMetric.Jvm -> "jvm"
                | StatsNodeStatsMetric.ThreadPool -> "thread_pool"
                | StatsNodeStatsMetric.Fs -> "fs"
                | StatsNodeStatsMetric.Transport -> "transport"
                | StatsNodeStatsMetric.Http -> "http"
                | StatsNodeStatsMetric.Breaker -> "breaker"
                | StatsNodeStatsMetric.Script -> "script"
                | StatsNodeStatsMetric.Discovery -> "discovery"
                | StatsNodeStatsMetric.Ingest -> "ingest"
                | StatsNodeStatsMetric.AdaptiveSelection -> "adaptive_selection"
                | StatsNodeStatsMetric.ScriptCache -> "script_cache"
                | StatsNodeStatsMetric.IndexingPressure -> "indexing_pressure"
                | StatsNodeStatsMetric.Repositories -> "repositories"
                | StatsNodeStatsMetric.Allocations -> "allocations"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> StatsNodeStatsMetric.All
            | "_none" -> StatsNodeStatsMetric.None
            | "indices" -> StatsNodeStatsMetric.Indices
            | "os" -> StatsNodeStatsMetric.Os
            | "process" -> StatsNodeStatsMetric.Process
            | "jvm" -> StatsNodeStatsMetric.Jvm
            | "thread_pool" -> StatsNodeStatsMetric.ThreadPool
            | "fs" -> StatsNodeStatsMetric.Fs
            | "transport" -> StatsNodeStatsMetric.Transport
            | "http" -> StatsNodeStatsMetric.Http
            | "breaker" -> StatsNodeStatsMetric.Breaker
            | "script" -> StatsNodeStatsMetric.Script
            | "discovery" -> StatsNodeStatsMetric.Discovery
            | "ingest" -> StatsNodeStatsMetric.Ingest
            | "adaptive_selection" -> StatsNodeStatsMetric.AdaptiveSelection
            | "script_cache" -> StatsNodeStatsMetric.ScriptCache
            | "indexing_pressure" -> StatsNodeStatsMetric.IndexingPressure
            | "repositories" -> StatsNodeStatsMetric.Repositories
            | "allocations" -> StatsNodeStatsMetric.Allocations
            | s -> failwith $"Unknown StatsNodeStatsMetric: {s}"

    and [<JsonConverter(typeof<StatsNodeStatsMetricConverter>)>]
        StatsNodeStatsMetric =
        | All
        | None
        | Indices
        | Os
        | Process
        | Jvm
        | ThreadPool
        | Fs
        | Transport
        | Http
        | Breaker
        | Script
        | Discovery
        | Ingest
        | AdaptiveSelection
        | ScriptCache
        | IndexingPressure
        | Repositories
        | Allocations
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | None -> "_none"
            | Indices -> "indices"
            | Os -> "os"
            | Process -> "process"
            | Jvm -> "jvm"
            | ThreadPool -> "thread_pool"
            | Fs -> "fs"
            | Transport -> "transport"
            | Http -> "http"
            | Breaker -> "breaker"
            | Script -> "script"
            | Discovery -> "discovery"
            | Ingest -> "ingest"
            | AdaptiveSelection -> "adaptive_selection"
            | ScriptCache -> "script_cache"
            | IndexingPressure -> "indexing_pressure"
            | Repositories -> "repositories"
            | Allocations -> "allocations"

    and StatsNodeStatsMetrics = obj

    and NodeStatsLevelConverter() =
        inherit JsonConverter<NodeStatsLevel>()

        override _.Write(writer: Utf8JsonWriter, value: NodeStatsLevel, _options: JsonSerializerOptions) =
            let str =
                match value with
                | NodeStatsLevel.Node -> "node"
                | NodeStatsLevel.Indices -> "indices"
                | NodeStatsLevel.Shards -> "shards"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "node" -> NodeStatsLevel.Node
            | "indices" -> NodeStatsLevel.Indices
            | "shards" -> NodeStatsLevel.Shards
            | s -> failwith $"Unknown NodeStatsLevel: {s}"

    and [<JsonConverter(typeof<NodeStatsLevelConverter>)>]
        NodeStatsLevel =
        | Node
        | Indices
        | Shards
        with
        override this.ToString() =
            match this with
            | Node -> "node"
            | Indices -> "indices"
            | Shards -> "shards"

    and TypesAdaptiveSelection = {
        [<JsonPropertyName("avg_queue_size")>]
        AvgQueueSize: float option
        [<JsonPropertyName("avg_response_time")>]
        AvgResponseTime: Duration option
        [<JsonPropertyName("avg_response_time_ns")>]
        AvgResponseTimeNs: float option
        [<JsonPropertyName("avg_service_time")>]
        AvgServiceTime: Duration option
        [<JsonPropertyName("avg_service_time_ns")>]
        AvgServiceTimeNs: float option
        [<JsonPropertyName("outgoing_searches")>]
        OutgoingSearches: float option
        [<JsonPropertyName("rank")>]
        Rank: string option
    }

    and TypesBreaker = {
        [<JsonPropertyName("estimated_size")>]
        EstimatedSize: string option
        [<JsonPropertyName("estimated_size_in_bytes")>]
        EstimatedSizeInBytes: float option
        [<JsonPropertyName("limit_size")>]
        LimitSize: string option
        [<JsonPropertyName("limit_size_in_bytes")>]
        LimitSizeInBytes: float option
        [<JsonPropertyName("overhead")>]
        Overhead: float option
        [<JsonPropertyName("tripped")>]
        Tripped: float option
    }

    and TypesRecording = {
        [<JsonPropertyName("name")>]
        Name: string option
        [<JsonPropertyName("cumulative_execution_count")>]
        CumulativeExecutionCount: float option
        [<JsonPropertyName("cumulative_execution_time")>]
        CumulativeExecutionTime: Duration option
        [<JsonPropertyName("cumulative_execution_time_millis")>]
        CumulativeExecutionTimeMillis: DurationValueUnitMillis option
    }

    and TypesClusterAppliedStats = {
        [<JsonPropertyName("recordings")>]
        Recordings: TypesRecording array option
    }

    and TypesClusterStateQueue = {
        [<JsonPropertyName("total")>]
        Total: float option
        [<JsonPropertyName("pending")>]
        Pending: float option
        [<JsonPropertyName("committed")>]
        Committed: float option
    }

    and TypesClusterStateUpdate = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("computation_time")>]
        ComputationTime: Duration option
        [<JsonPropertyName("computation_time_millis")>]
        ComputationTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("publication_time")>]
        PublicationTime: Duration option
        [<JsonPropertyName("publication_time_millis")>]
        PublicationTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("context_construction_time")>]
        ContextConstructionTime: Duration option
        [<JsonPropertyName("context_construction_time_millis")>]
        ContextConstructionTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("commit_time")>]
        CommitTime: Duration option
        [<JsonPropertyName("commit_time_millis")>]
        CommitTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("completion_time")>]
        CompletionTime: Duration option
        [<JsonPropertyName("completion_time_millis")>]
        CompletionTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("master_apply_time")>]
        MasterApplyTime: Duration option
        [<JsonPropertyName("master_apply_time_millis")>]
        MasterApplyTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("notification_time")>]
        NotificationTime: Duration option
        [<JsonPropertyName("notification_time_millis")>]
        NotificationTimeMillis: DurationValueUnitMillis option
    }

    and TypesPublishedClusterStates = {
        [<JsonPropertyName("full_states")>]
        FullStates: float option
        [<JsonPropertyName("incompatible_diffs")>]
        IncompatibleDiffs: float option
        [<JsonPropertyName("compatible_diffs")>]
        CompatibleDiffs: float option
    }

    and TypesSerializedClusterStateDetail = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("uncompressed_size")>]
        UncompressedSize: string option
        [<JsonPropertyName("uncompressed_size_in_bytes")>]
        UncompressedSizeInBytes: float option
        [<JsonPropertyName("compressed_size")>]
        CompressedSize: string option
        [<JsonPropertyName("compressed_size_in_bytes")>]
        CompressedSizeInBytes: float option
    }

    and TypesSerializedClusterState = {
        [<JsonPropertyName("full_states")>]
        FullStates: TypesSerializedClusterStateDetail option
        [<JsonPropertyName("diffs")>]
        Diffs: TypesSerializedClusterStateDetail option
    }

    and TypesDiscovery = {
        [<JsonPropertyName("cluster_state_queue")>]
        ClusterStateQueue: TypesClusterStateQueue option
        [<JsonPropertyName("published_cluster_states")>]
        PublishedClusterStates: TypesPublishedClusterStates option
        [<JsonPropertyName("cluster_state_update")>]
        ClusterStateUpdate: Map<string, TypesClusterStateUpdate> option
        [<JsonPropertyName("serialized_cluster_states")>]
        SerializedClusterStates: TypesSerializedClusterState option
        [<JsonPropertyName("cluster_applier_stats")>]
        ClusterApplierStats: TypesClusterAppliedStats option
    }

    and TypesDataPathStats = {
        [<JsonPropertyName("available")>]
        Available: string option
        [<JsonPropertyName("available_in_bytes")>]
        AvailableInBytes: float option
        [<JsonPropertyName("disk_queue")>]
        DiskQueue: string option
        [<JsonPropertyName("disk_reads")>]
        DiskReads: float option
        [<JsonPropertyName("disk_read_size")>]
        DiskReadSize: string option
        [<JsonPropertyName("disk_read_size_in_bytes")>]
        DiskReadSizeInBytes: float option
        [<JsonPropertyName("disk_writes")>]
        DiskWrites: float option
        [<JsonPropertyName("disk_write_size")>]
        DiskWriteSize: string option
        [<JsonPropertyName("disk_write_size_in_bytes")>]
        DiskWriteSizeInBytes: float option
        [<JsonPropertyName("free")>]
        Free: string option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float option
        [<JsonPropertyName("mount")>]
        Mount: string option
        [<JsonPropertyName("path")>]
        Path: string option
        [<JsonPropertyName("total")>]
        Total: string option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float option
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesFileSystemTotal = {
        [<JsonPropertyName("available")>]
        Available: string option
        [<JsonPropertyName("available_in_bytes")>]
        AvailableInBytes: float option
        [<JsonPropertyName("free")>]
        Free: string option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float option
        [<JsonPropertyName("total")>]
        Total: string option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float option
    }

    and TypesIoStatDevice = {
        [<JsonPropertyName("device_name")>]
        DeviceName: string option
        [<JsonPropertyName("operations")>]
        Operations: float option
        [<JsonPropertyName("read_kilobytes")>]
        ReadKilobytes: float option
        [<JsonPropertyName("read_operations")>]
        ReadOperations: float option
        [<JsonPropertyName("write_kilobytes")>]
        WriteKilobytes: float option
        [<JsonPropertyName("write_operations")>]
        WriteOperations: float option
    }

    and TypesIoStats = {
        [<JsonPropertyName("devices")>]
        Devices: TypesIoStatDevice array option
        [<JsonPropertyName("total")>]
        Total: TypesIoStatDevice option
    }

    and TypesFileSystem = {
        [<JsonPropertyName("data")>]
        Data: TypesDataPathStats array option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
        [<JsonPropertyName("total")>]
        Total: TypesFileSystemTotal option
        [<JsonPropertyName("io_stats")>]
        IoStats: TypesIoStats option
    }

    and TypesGarbageCollectorTotal = {
        [<JsonPropertyName("collection_count")>]
        CollectionCount: float option
        [<JsonPropertyName("collection_time")>]
        CollectionTime: string option
        [<JsonPropertyName("collection_time_in_millis")>]
        CollectionTimeInMillis: float option
    }

    and TypesGarbageCollector = {
        [<JsonPropertyName("collectors")>]
        Collectors: Map<string, TypesGarbageCollectorTotal> option
    }

    and TypesJvmClasses = {
        [<JsonPropertyName("current_loaded_count")>]
        CurrentLoadedCount: float option
        [<JsonPropertyName("total_loaded_count")>]
        TotalLoadedCount: float option
        [<JsonPropertyName("total_unloaded_count")>]
        TotalUnloadedCount: float option
    }

    and TypesPool = {
        [<JsonPropertyName("used_in_bytes")>]
        UsedInBytes: float option
        [<JsonPropertyName("max_in_bytes")>]
        MaxInBytes: float option
        [<JsonPropertyName("peak_used_in_bytes")>]
        PeakUsedInBytes: float option
        [<JsonPropertyName("peak_max_in_bytes")>]
        PeakMaxInBytes: float option
    }

    and TypesJvmMemoryStats = {
        [<JsonPropertyName("heap_used_in_bytes")>]
        HeapUsedInBytes: float option
        [<JsonPropertyName("heap_used_percent")>]
        HeapUsedPercent: float option
        [<JsonPropertyName("heap_committed_in_bytes")>]
        HeapCommittedInBytes: float option
        [<JsonPropertyName("heap_max_in_bytes")>]
        HeapMaxInBytes: float option
        [<JsonPropertyName("heap_max")>]
        HeapMax: ByteSize option
        [<JsonPropertyName("non_heap_used_in_bytes")>]
        NonHeapUsedInBytes: float option
        [<JsonPropertyName("non_heap_committed_in_bytes")>]
        NonHeapCommittedInBytes: float option
        [<JsonPropertyName("pools")>]
        Pools: Map<string, TypesPool> option
    }

    and TypesJvmThreads = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("peak_count")>]
        PeakCount: float option
    }

    and TypesNodeBufferPool = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("total_capacity")>]
        TotalCapacity: string option
        [<JsonPropertyName("total_capacity_in_bytes")>]
        TotalCapacityInBytes: float option
        [<JsonPropertyName("used")>]
        Used: string option
        [<JsonPropertyName("used_in_bytes")>]
        UsedInBytes: float option
    }

    and TypesJvm = {
        [<JsonPropertyName("buffer_pools")>]
        BufferPools: Map<string, TypesNodeBufferPool> option
        [<JsonPropertyName("classes")>]
        Classes: TypesJvmClasses option
        [<JsonPropertyName("gc")>]
        Gc: TypesGarbageCollector option
        [<JsonPropertyName("mem")>]
        Mem: TypesJvmMemoryStats option
        [<JsonPropertyName("threads")>]
        Threads: TypesJvmThreads option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
        [<JsonPropertyName("uptime")>]
        Uptime: string option
        [<JsonPropertyName("uptime_in_millis")>]
        UptimeInMillis: float option
    }

    and TypesCgroupCpuStat = {
        [<JsonPropertyName("number_of_elapsed_periods")>]
        NumberOfElapsedPeriods: float option
        [<JsonPropertyName("number_of_times_throttled")>]
        NumberOfTimesThrottled: float option
        [<JsonPropertyName("time_throttled_nanos")>]
        TimeThrottledNanos: DurationValueUnitNanos option
    }

    and TypesCgroupCpu = {
        [<JsonPropertyName("control_group")>]
        ControlGroup: string option
        [<JsonPropertyName("cfs_period_micros")>]
        CfsPeriodMicros: float option
        [<JsonPropertyName("cfs_quota_micros")>]
        CfsQuotaMicros: float option
        [<JsonPropertyName("stat")>]
        Stat: TypesCgroupCpuStat option
    }

    and TypesCgroupMemory = {
        [<JsonPropertyName("control_group")>]
        ControlGroup: string option
        [<JsonPropertyName("limit_in_bytes")>]
        LimitInBytes: string option
        [<JsonPropertyName("usage_in_bytes")>]
        UsageInBytes: string option
    }

    and TypesCpuAcct = {
        [<JsonPropertyName("control_group")>]
        ControlGroup: string option
        [<JsonPropertyName("usage_nanos")>]
        UsageNanos: DurationValueUnitNanos option
    }

    and TypesCgroup = {
        [<JsonPropertyName("cpuacct")>]
        Cpuacct: TypesCpuAcct option
        [<JsonPropertyName("cpu")>]
        Cpu: TypesCgroupCpu option
        [<JsonPropertyName("memory")>]
        Memory: TypesCgroupMemory option
    }

    and TypesCpu = {
        [<JsonPropertyName("percent")>]
        Percent: float option
        [<JsonPropertyName("sys")>]
        Sys: Duration option
        [<JsonPropertyName("sys_in_millis")>]
        SysInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("total")>]
        Total: Duration option
        [<JsonPropertyName("total_in_millis")>]
        TotalInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("user")>]
        User: Duration option
        [<JsonPropertyName("user_in_millis")>]
        UserInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("load_average")>]
        LoadAverage: Map<string, float> option
    }

    and TypesMemoryStats = {
        [<JsonPropertyName("adjusted_total_in_bytes")>]
        AdjustedTotalInBytes: float option
        [<JsonPropertyName("resident")>]
        Resident: string option
        [<JsonPropertyName("resident_in_bytes")>]
        ResidentInBytes: float option
        [<JsonPropertyName("share")>]
        Share: string option
        [<JsonPropertyName("share_in_bytes")>]
        ShareInBytes: float option
        [<JsonPropertyName("total_virtual")>]
        TotalVirtual: string option
        [<JsonPropertyName("total_virtual_in_bytes")>]
        TotalVirtualInBytes: float option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float option
        [<JsonPropertyName("used_in_bytes")>]
        UsedInBytes: float option
    }

    and TypesExtendedMemoryStats = {
        [<JsonPropertyName("adjusted_total_in_bytes")>]
        AdjustedTotalInBytes: float option
        [<JsonPropertyName("resident")>]
        Resident: string option
        [<JsonPropertyName("resident_in_bytes")>]
        ResidentInBytes: float option
        [<JsonPropertyName("share")>]
        Share: string option
        [<JsonPropertyName("share_in_bytes")>]
        ShareInBytes: float option
        [<JsonPropertyName("total_virtual")>]
        TotalVirtual: string option
        [<JsonPropertyName("total_virtual_in_bytes")>]
        TotalVirtualInBytes: float option
        [<JsonPropertyName("total_in_bytes")>]
        TotalInBytes: float option
        [<JsonPropertyName("free_in_bytes")>]
        FreeInBytes: float option
        [<JsonPropertyName("used_in_bytes")>]
        UsedInBytes: float option
        [<JsonPropertyName("free_percent")>]
        FreePercent: float option
        [<JsonPropertyName("used_percent")>]
        UsedPercent: float option
    }

    and TypesOperatingSystem = {
        [<JsonPropertyName("cpu")>]
        Cpu: TypesCpu option
        [<JsonPropertyName("mem")>]
        Mem: TypesExtendedMemoryStats option
        [<JsonPropertyName("swap")>]
        Swap: TypesMemoryStats option
        [<JsonPropertyName("cgroup")>]
        Cgroup: TypesCgroup option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
    }

    and TypesProcess = {
        [<JsonPropertyName("cpu")>]
        Cpu: TypesCpu option
        [<JsonPropertyName("mem")>]
        Mem: TypesMemoryStats option
        [<JsonPropertyName("open_file_descriptors")>]
        OpenFileDescriptors: float option
        [<JsonPropertyName("max_file_descriptors")>]
        MaxFileDescriptors: float option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
    }

    and TypesScriptCache = {
        [<JsonPropertyName("cache_evictions")>]
        CacheEvictions: float option
        [<JsonPropertyName("compilation_limit_triggered")>]
        CompilationLimitTriggered: float option
        [<JsonPropertyName("compilations")>]
        Compilations: float option
        [<JsonPropertyName("context")>]
        Context: string option
    }

    and TypesTransportHistogram = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("lt_millis")>]
        LtMillis: float option
        [<JsonPropertyName("ge_millis")>]
        GeMillis: float option
    }

    and TypesTransport = {
        [<JsonPropertyName("inbound_handling_time_histogram")>]
        InboundHandlingTimeHistogram: TypesTransportHistogram array option
        [<JsonPropertyName("outbound_handling_time_histogram")>]
        OutboundHandlingTimeHistogram: TypesTransportHistogram array option
        [<JsonPropertyName("rx_count")>]
        RxCount: float option
        [<JsonPropertyName("rx_size")>]
        RxSize: string option
        [<JsonPropertyName("rx_size_in_bytes")>]
        RxSizeInBytes: float option
        [<JsonPropertyName("server_open")>]
        ServerOpen: float option
        [<JsonPropertyName("tx_count")>]
        TxCount: float option
        [<JsonPropertyName("tx_size")>]
        TxSize: string option
        [<JsonPropertyName("tx_size_in_bytes")>]
        TxSizeInBytes: float option
        [<JsonPropertyName("total_outbound_connections")>]
        TotalOutboundConnections: float option
    }

    and TypesStats = {
        [<JsonPropertyName("adaptive_selection")>]
        AdaptiveSelection: Map<string, TypesAdaptiveSelection> option
        [<JsonPropertyName("breakers")>]
        Breakers: Map<string, TypesBreaker> option
        [<JsonPropertyName("fs")>]
        Fs: TypesFileSystem option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("http")>]
        Http: TypesHttp option
        [<JsonPropertyName("ingest")>]
        Ingest: TypesIngest option
        [<JsonPropertyName("ip")>]
        Ip: System.Text.Json.JsonElement option
        [<JsonPropertyName("jvm")>]
        Jvm: TypesJvm option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("os")>]
        Os: TypesOperatingSystem option
        [<JsonPropertyName("process")>]
        Process: TypesProcess option
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles option
        [<JsonPropertyName("script")>]
        Script: TypesScripting option
        [<JsonPropertyName("script_cache")>]
        ScriptCache: Map<string, System.Text.Json.JsonElement> option
        [<JsonPropertyName("thread_pool")>]
        ThreadPool: Map<string, TypesThreadCount> option
        [<JsonPropertyName("timestamp")>]
        Timestamp: float option
        [<JsonPropertyName("transport")>]
        Transport: TypesTransport option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress option
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string> option
        [<JsonPropertyName("discovery")>]
        Discovery: TypesDiscovery option
        [<JsonPropertyName("indexing_pressure")>]
        IndexingPressure: System.Text.Json.JsonElement option
        [<JsonPropertyName("indices")>]
        Indices: StatsShardStats option
    }

    and StatsResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name option
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, TypesStats>
    }

    and UsageNodesUsageMetricConverter() =
        inherit JsonConverter<UsageNodesUsageMetric>()

        override _.Write(writer: Utf8JsonWriter, value: UsageNodesUsageMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | UsageNodesUsageMetric.All -> "_all"
                | UsageNodesUsageMetric.RestActions -> "rest_actions"
                | UsageNodesUsageMetric.Aggregations -> "aggregations"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> UsageNodesUsageMetric.All
            | "rest_actions" -> UsageNodesUsageMetric.RestActions
            | "aggregations" -> UsageNodesUsageMetric.Aggregations
            | s -> failwith $"Unknown UsageNodesUsageMetric: {s}"

    and [<JsonConverter(typeof<UsageNodesUsageMetricConverter>)>]
        UsageNodesUsageMetric =
        | All
        | RestActions
        | Aggregations
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | RestActions -> "rest_actions"
            | Aggregations -> "aggregations"

    and UsageNodesUsageMetrics = obj

    and UsageNodeUsage = {
        [<JsonPropertyName("rest_actions")>]
        RestActions: Map<string, float>
        [<JsonPropertyName("since")>]
        Since: EpochTimeUnitMillis
        [<JsonPropertyName("timestamp")>]
        Timestamp: EpochTimeUnitMillis
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, obj>
    }

    and UsageResponseBase = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics option
        [<JsonPropertyName("cluster_name")>]
        ClusterName: Name
        [<JsonPropertyName("nodes")>]
        Nodes2: Map<string, UsageNodeUsage>
    }

    and TypesQueryRuleActions = {
        [<JsonPropertyName("ids")>]
        Ids: Id array option
        [<JsonPropertyName("docs")>]
        Docs: QueryDslPinnedDoc array option
    }

    and TypesQueryRuleCriteriaTypeConverter() =
        inherit JsonConverter<TypesQueryRuleCriteriaType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesQueryRuleCriteriaType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesQueryRuleCriteriaType.Global -> "global"
                | TypesQueryRuleCriteriaType.Exact -> "exact"
                | TypesQueryRuleCriteriaType.ExactFuzzy -> "exact_fuzzy"
                | TypesQueryRuleCriteriaType.Fuzzy -> "fuzzy"
                | TypesQueryRuleCriteriaType.Prefix -> "prefix"
                | TypesQueryRuleCriteriaType.Suffix -> "suffix"
                | TypesQueryRuleCriteriaType.Contains -> "contains"
                | TypesQueryRuleCriteriaType.Lt -> "lt"
                | TypesQueryRuleCriteriaType.Lte -> "lte"
                | TypesQueryRuleCriteriaType.Gt -> "gt"
                | TypesQueryRuleCriteriaType.Gte -> "gte"
                | TypesQueryRuleCriteriaType.Always -> "always"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "global" -> TypesQueryRuleCriteriaType.Global
            | "exact" -> TypesQueryRuleCriteriaType.Exact
            | "exact_fuzzy" -> TypesQueryRuleCriteriaType.ExactFuzzy
            | "fuzzy" -> TypesQueryRuleCriteriaType.Fuzzy
            | "prefix" -> TypesQueryRuleCriteriaType.Prefix
            | "suffix" -> TypesQueryRuleCriteriaType.Suffix
            | "contains" -> TypesQueryRuleCriteriaType.Contains
            | "lt" -> TypesQueryRuleCriteriaType.Lt
            | "lte" -> TypesQueryRuleCriteriaType.Lte
            | "gt" -> TypesQueryRuleCriteriaType.Gt
            | "gte" -> TypesQueryRuleCriteriaType.Gte
            | "always" -> TypesQueryRuleCriteriaType.Always
            | s -> failwith $"Unknown TypesQueryRuleCriteriaType: {s}"

    and [<JsonConverter(typeof<TypesQueryRuleCriteriaTypeConverter>)>]
        TypesQueryRuleCriteriaType =
        | Global
        | Exact
        | ExactFuzzy
        | Fuzzy
        | Prefix
        | Suffix
        | Contains
        | Lt
        | Lte
        | Gt
        | Gte
        | Always
        with
        override this.ToString() =
            match this with
            | Global -> "global"
            | Exact -> "exact"
            | ExactFuzzy -> "exact_fuzzy"
            | Fuzzy -> "fuzzy"
            | Prefix -> "prefix"
            | Suffix -> "suffix"
            | Contains -> "contains"
            | Lt -> "lt"
            | Lte -> "lte"
            | Gt -> "gt"
            | Gte -> "gte"
            | Always -> "always"

    and TypesQueryRuleCriteria = {
        [<JsonPropertyName("type")>]
        Type: TypesQueryRuleCriteriaType
        [<JsonPropertyName("metadata")>]
        Metadata: string option
        [<JsonPropertyName("values")>]
        Values: obj array option
    }

    and TypesQueryRuleTypeConverter() =
        inherit JsonConverter<TypesQueryRuleType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesQueryRuleType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesQueryRuleType.Pinned -> "pinned"
                | TypesQueryRuleType.Exclude -> "exclude"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "pinned" -> TypesQueryRuleType.Pinned
            | "exclude" -> TypesQueryRuleType.Exclude
            | s -> failwith $"Unknown TypesQueryRuleType: {s}"

    and [<JsonConverter(typeof<TypesQueryRuleTypeConverter>)>]
        TypesQueryRuleType =
        | Pinned
        | Exclude
        with
        override this.ToString() =
            match this with
            | Pinned -> "pinned"
            | Exclude -> "exclude"

    and TypesQueryRule = {
        [<JsonPropertyName("rule_id")>]
        RuleId: Id
        [<JsonPropertyName("type")>]
        Type: TypesQueryRuleType
        [<JsonPropertyName("criteria")>]
        Criteria: System.Text.Json.JsonElement
        [<JsonPropertyName("actions")>]
        Actions: TypesQueryRuleActions
        [<JsonPropertyName("priority")>]
        Priority: float option
    }

    and TypesQueryRuleset = {
        [<JsonPropertyName("ruleset_id")>]
        RulesetId: Id
        [<JsonPropertyName("rules")>]
        Rules: TypesQueryRule array
    }

    and ListRulesetsQueryRulesetListItem = {
        [<JsonPropertyName("ruleset_id")>]
        RulesetId: Id
        [<JsonPropertyName("rule_total_count")>]
        RuleTotalCount: float
        [<JsonPropertyName("rule_criteria_types_counts")>]
        RuleCriteriaTypesCounts: Map<string, float>
        [<JsonPropertyName("rule_type_counts")>]
        RuleTypeCounts: Map<string, float>
    }

    and TestQueryRulesetMatchedRule = {
        [<JsonPropertyName("ruleset_id")>]
        RulesetId: Id
        [<JsonPropertyName("rule_id")>]
        RuleId: Id
    }

    and RankEvalDocumentRating = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("rating")>]
        Rating: float
    }

    and RankEvalRankEvalQuery = {
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
        [<JsonPropertyName("size")>]
        Size: float option
    }

    and RankEvalRankEvalRequestItem = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("request")>]
        Request: RankEvalRankEvalQuery option
        [<JsonPropertyName("ratings")>]
        Ratings: RankEvalDocumentRating array
        [<JsonPropertyName("template_id")>]
        TemplateId: Id option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
    }

    and RankEvalRankEvalMetricBase = {
        [<JsonPropertyName("k")>]
        K: float option
    }

    /// <summary>
    /// Discounted cumulative gain (DCG)
    /// </summary>
    and RankEvalRankEvalMetricDiscountedCumulativeGain = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("normalize")>]
        Normalize: bool option
    }

    /// <summary>
    /// Expected Reciprocal Rank (ERR)
    /// </summary>
    and RankEvalRankEvalMetricExpectedReciprocalRank = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("maximum_relevance")>]
        MaximumRelevance: float
    }

    and RankEvalRankEvalMetricRatingTreshold = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("relevant_rating_threshold")>]
        RelevantRatingThreshold: float option
    }

    /// <summary>
    /// Mean Reciprocal Rank
    /// </summary>
    and RankEvalRankEvalMetricMeanReciprocalRank = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("relevant_rating_threshold")>]
        RelevantRatingThreshold: float option
    }

    /// <summary>
    /// Precision at K (P@k)
    /// </summary>
    and RankEvalRankEvalMetricPrecision = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("relevant_rating_threshold")>]
        RelevantRatingThreshold: float option
        [<JsonPropertyName("ignore_unlabeled")>]
        IgnoreUnlabeled: bool option
    }

    /// <summary>
    /// Recall at K (R@k)
    /// </summary>
    and RankEvalRankEvalMetricRecall = {
        [<JsonPropertyName("k")>]
        K: float option
        [<JsonPropertyName("relevant_rating_threshold")>]
        RelevantRatingThreshold: float option
    }

    and RankEvalRankEvalMetric = {
        [<JsonPropertyName("precision")>]
        Precision: RankEvalRankEvalMetricPrecision option
        [<JsonPropertyName("recall")>]
        Recall: RankEvalRankEvalMetricRecall option
        [<JsonPropertyName("mean_reciprocal_rank")>]
        MeanReciprocalRank: RankEvalRankEvalMetricMeanReciprocalRank option
        [<JsonPropertyName("dcg")>]
        Dcg: RankEvalRankEvalMetricDiscountedCumulativeGain option
        [<JsonPropertyName("expected_reciprocal_rank")>]
        ExpectedReciprocalRank: RankEvalRankEvalMetricExpectedReciprocalRank option
    }

    and RankEvalRankEvalHit = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_score")>]
        Score: float
    }

    and RankEvalRankEvalHitItem = {
        [<JsonPropertyName("hit")>]
        Hit: RankEvalRankEvalHit
        [<JsonPropertyName("rating")>]
        Rating: System.Text.Json.JsonElement option
    }

    and RankEvalUnratedDocument = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
    }

    and RankEvalRankEvalMetricDetail = {
        [<JsonPropertyName("metric_score")>]
        MetricScore: float
        [<JsonPropertyName("unrated_docs")>]
        UnratedDocs: RankEvalUnratedDocument array
        [<JsonPropertyName("hits")>]
        Hits: RankEvalRankEvalHitItem array
        [<JsonPropertyName("metric_details")>]
        MetricDetails: Map<string, Map<string, obj>>
    }

    and ReindexDestination = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("op_type")>]
        OpType: OpType option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
        [<JsonPropertyName("routing")>]
        Routing: Routing option
        [<JsonPropertyName("version_type")>]
        VersionType: VersionType option
    }

    and Username = string

    and ReindexRemoteSource = {
        [<JsonPropertyName("connect_timeout")>]
        ConnectTimeout: Duration option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string> option
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("username")>]
        Username: Username option
        [<JsonPropertyName("password")>]
        Password: Password option
        [<JsonPropertyName("api_key")>]
        ApiKey: string option
        [<JsonPropertyName("socket_timeout")>]
        SocketTimeout: Duration option
    }

    and ReindexSource = {
        [<JsonPropertyName("index")>]
        Index: Indices
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
        [<JsonPropertyName("remote")>]
        Remote: ReindexRemoteSource option
        [<JsonPropertyName("size")>]
        Size: float option
        [<JsonPropertyName("slice")>]
        Slice: SlicedScroll option
        [<JsonPropertyName("sort")>]
        Sort: Sort option
        [<JsonPropertyName("_source")>]
        Source: SearchTypesSourceConfig option
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
    }

    and ReindexRethrottleReindexStatus = {
        [<JsonPropertyName("batches")>]
        Batches: float
        [<JsonPropertyName("created")>]
        Created: float
        [<JsonPropertyName("deleted")>]
        Deleted: float
        [<JsonPropertyName("noops")>]
        Noops: float
        [<JsonPropertyName("requests_per_second")>]
        RequestsPerSecond: float
        [<JsonPropertyName("retries")>]
        Retries: Retries
        [<JsonPropertyName("throttled")>]
        Throttled: Duration option
        [<JsonPropertyName("throttled_millis")>]
        ThrottledMillis: DurationValueUnitMillis
        [<JsonPropertyName("throttled_until")>]
        ThrottledUntil: Duration option
        [<JsonPropertyName("throttled_until_millis")>]
        ThrottledUntilMillis: DurationValueUnitMillis
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("updated")>]
        Updated: float
        [<JsonPropertyName("version_conflicts")>]
        VersionConflicts: float
    }

    and ReindexRethrottleReindexTask = {
        [<JsonPropertyName("action")>]
        Action: string
        [<JsonPropertyName("cancellable")>]
        Cancellable: bool
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("id")>]
        Id: float
        [<JsonPropertyName("node")>]
        Node: Name
        [<JsonPropertyName("running_time_in_nanos")>]
        RunningTimeInNanos: DurationValueUnitNanos
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("status")>]
        Status: ReindexRethrottleReindexStatus
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("headers")>]
        Headers: HttpHeaders
    }

    and BaseNode = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("ip")>]
        Ip: Ip
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
    }

    and ReindexRethrottleReindexNode = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("ip")>]
        Ip: Ip
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("tasks")>]
        Tasks: Map<string, ReindexRethrottleReindexTask>
    }

    and TypesMetricConverter() =
        inherit JsonConverter<TypesMetric>()

        override _.Write(writer: Utf8JsonWriter, value: TypesMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesMetric.Min -> "min"
                | TypesMetric.Max -> "max"
                | TypesMetric.Sum -> "sum"
                | TypesMetric.Avg -> "avg"
                | TypesMetric.ValueCount -> "value_count"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "min" -> TypesMetric.Min
            | "max" -> TypesMetric.Max
            | "sum" -> TypesMetric.Sum
            | "avg" -> TypesMetric.Avg
            | "value_count" -> TypesMetric.ValueCount
            | s -> failwith $"Unknown TypesMetric: {s}"

    and [<JsonConverter(typeof<TypesMetricConverter>)>]
        TypesMetric =
        | Min
        | Max
        | Sum
        | Avg
        | ValueCount
        with
        override this.ToString() =
            match this with
            | Min -> "min"
            | Max -> "max"
            | Sum -> "sum"
            | Avg -> "avg"
            | ValueCount -> "value_count"

    and TypesFieldMetric = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("metrics")>]
        Metrics: TypesMetric array
    }

    and TypesDateHistogramGrouping = {
        [<JsonPropertyName("delay")>]
        Delay: Duration option
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("format")>]
        Format: string option
        [<JsonPropertyName("interval")>]
        Interval: Duration option
        [<JsonPropertyName("calendar_interval")>]
        CalendarInterval: Duration option
        [<JsonPropertyName("fixed_interval")>]
        FixedInterval: Duration option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and TypesHistogramGrouping = {
        [<JsonPropertyName("fields")>]
        Fields: Fields
        [<JsonPropertyName("interval")>]
        Interval: float
    }

    and TypesTermsGrouping = {
        [<JsonPropertyName("fields")>]
        Fields: Fields
    }

    and TypesGroupings = {
        [<JsonPropertyName("date_histogram")>]
        DateHistogram: TypesDateHistogramGrouping option
        [<JsonPropertyName("histogram")>]
        Histogram: TypesHistogramGrouping option
        [<JsonPropertyName("terms")>]
        Terms: TypesTermsGrouping option
    }

    and GetJobsRollupJobConfiguration = {
        [<JsonPropertyName("cron")>]
        Cron: string
        [<JsonPropertyName("groups")>]
        Groups: TypesGroupings
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("index_pattern")>]
        IndexPattern: string
        [<JsonPropertyName("metrics")>]
        Metrics: TypesFieldMetric array
        [<JsonPropertyName("page_size")>]
        PageSize: float
        [<JsonPropertyName("rollup_index")>]
        RollupIndex: IndexName
        [<JsonPropertyName("timeout")>]
        Timeout: Duration
    }

    and GetJobsRollupJobStats = {
        [<JsonPropertyName("documents_processed")>]
        DocumentsProcessed: float
        [<JsonPropertyName("index_failures")>]
        IndexFailures: float
        [<JsonPropertyName("index_time_in_ms")>]
        IndexTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("index_total")>]
        IndexTotal: float
        [<JsonPropertyName("pages_processed")>]
        PagesProcessed: float
        [<JsonPropertyName("rollups_indexed")>]
        RollupsIndexed: float
        [<JsonPropertyName("search_failures")>]
        SearchFailures: float
        [<JsonPropertyName("search_time_in_ms")>]
        SearchTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("search_total")>]
        SearchTotal: float
        [<JsonPropertyName("trigger_count")>]
        TriggerCount: float
        [<JsonPropertyName("processing_time_in_ms")>]
        ProcessingTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("processing_total")>]
        ProcessingTotal: float
    }

    and GetJobsIndexingJobStateConverter() =
        inherit JsonConverter<GetJobsIndexingJobState>()

        override _.Write(writer: Utf8JsonWriter, value: GetJobsIndexingJobState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GetJobsIndexingJobState.Started -> "started"
                | GetJobsIndexingJobState.Indexing -> "indexing"
                | GetJobsIndexingJobState.Stopping -> "stopping"
                | GetJobsIndexingJobState.Stopped -> "stopped"
                | GetJobsIndexingJobState.Aborting -> "aborting"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "started" -> GetJobsIndexingJobState.Started
            | "indexing" -> GetJobsIndexingJobState.Indexing
            | "stopping" -> GetJobsIndexingJobState.Stopping
            | "stopped" -> GetJobsIndexingJobState.Stopped
            | "aborting" -> GetJobsIndexingJobState.Aborting
            | s -> failwith $"Unknown GetJobsIndexingJobState: {s}"

    and [<JsonConverter(typeof<GetJobsIndexingJobStateConverter>)>]
        GetJobsIndexingJobState =
        | Started
        | Indexing
        | Stopping
        | Stopped
        | Aborting
        with
        override this.ToString() =
            match this with
            | Started -> "started"
            | Indexing -> "indexing"
            | Stopping -> "stopping"
            | Stopped -> "stopped"
            | Aborting -> "aborting"

    and GetJobsRollupJobStatus = {
        [<JsonPropertyName("current_position")>]
        CurrentPosition: Map<string, obj> option
        [<JsonPropertyName("job_state")>]
        JobState: GetJobsIndexingJobState
        [<JsonPropertyName("upgraded_doc_id")>]
        UpgradedDocId: bool option
    }

    and GetJobsRollupJob = {
        [<JsonPropertyName("config")>]
        Config: GetJobsRollupJobConfiguration
        [<JsonPropertyName("stats")>]
        Stats: GetJobsRollupJobStats
        [<JsonPropertyName("status")>]
        Status: GetJobsRollupJobStatus
    }

    and GetRollupCapsRollupFieldSummary = {
        [<JsonPropertyName("agg")>]
        Agg: string
        [<JsonPropertyName("calendar_interval")>]
        CalendarInterval: Duration option
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
    }

    and GetRollupCapsRollupCapabilitySummary = {
        [<JsonPropertyName("fields")>]
        Fields: Map<string, GetRollupCapsRollupFieldSummary array>
        [<JsonPropertyName("index_pattern")>]
        IndexPattern: string
        [<JsonPropertyName("job_id")>]
        JobId: string
        [<JsonPropertyName("rollup_index")>]
        RollupIndex: string
    }

    and GetRollupCapsRollupCapabilities = {
        [<JsonPropertyName("rollup_jobs")>]
        RollupJobs: GetRollupCapsRollupCapabilitySummary array
    }

    and GetRollupIndexCapsRollupJobSummaryField = {
        [<JsonPropertyName("agg")>]
        Agg: string
        [<JsonPropertyName("time_zone")>]
        TimeZone: TimeZone option
        [<JsonPropertyName("calendar_interval")>]
        CalendarInterval: Duration option
    }

    and GetRollupIndexCapsRollupJobSummary = {
        [<JsonPropertyName("fields")>]
        Fields: Map<string, GetRollupIndexCapsRollupJobSummaryField array>
        [<JsonPropertyName("index_pattern")>]
        IndexPattern: string
        [<JsonPropertyName("job_id")>]
        JobId: Id
        [<JsonPropertyName("rollup_index")>]
        RollupIndex: IndexName
    }

    and GetRollupIndexCapsIndexCapabilities = {
        [<JsonPropertyName("rollup_jobs")>]
        RollupJobs: GetRollupIndexCapsRollupJobSummary array
    }

    and ScriptsPainlessExecutePainlessContextConverter() =
        inherit JsonConverter<ScriptsPainlessExecutePainlessContext>()

        override _.Write(writer: Utf8JsonWriter, value: ScriptsPainlessExecutePainlessContext, _options: JsonSerializerOptions) =
            let str =
                match value with
                | ScriptsPainlessExecutePainlessContext.PainlessTest -> "painless_test"
                | ScriptsPainlessExecutePainlessContext.Filter -> "filter"
                | ScriptsPainlessExecutePainlessContext.Score -> "score"
                | ScriptsPainlessExecutePainlessContext.BooleanField -> "boolean_field"
                | ScriptsPainlessExecutePainlessContext.DateField -> "date_field"
                | ScriptsPainlessExecutePainlessContext.DoubleField -> "double_field"
                | ScriptsPainlessExecutePainlessContext.GeoPointField -> "geo_point_field"
                | ScriptsPainlessExecutePainlessContext.IpField -> "ip_field"
                | ScriptsPainlessExecutePainlessContext.KeywordField -> "keyword_field"
                | ScriptsPainlessExecutePainlessContext.LongField -> "long_field"
                | ScriptsPainlessExecutePainlessContext.CompositeField -> "composite_field"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "painless_test" -> ScriptsPainlessExecutePainlessContext.PainlessTest
            | "filter" -> ScriptsPainlessExecutePainlessContext.Filter
            | "score" -> ScriptsPainlessExecutePainlessContext.Score
            | "boolean_field" -> ScriptsPainlessExecutePainlessContext.BooleanField
            | "date_field" -> ScriptsPainlessExecutePainlessContext.DateField
            | "double_field" -> ScriptsPainlessExecutePainlessContext.DoubleField
            | "geo_point_field" -> ScriptsPainlessExecutePainlessContext.GeoPointField
            | "ip_field" -> ScriptsPainlessExecutePainlessContext.IpField
            | "keyword_field" -> ScriptsPainlessExecutePainlessContext.KeywordField
            | "long_field" -> ScriptsPainlessExecutePainlessContext.LongField
            | "composite_field" -> ScriptsPainlessExecutePainlessContext.CompositeField
            | s -> failwith $"Unknown ScriptsPainlessExecutePainlessContext: {s}"

    and [<JsonConverter(typeof<ScriptsPainlessExecutePainlessContextConverter>)>]
        ScriptsPainlessExecutePainlessContext =
        | PainlessTest
        | Filter
        | Score
        | BooleanField
        | DateField
        | DoubleField
        | GeoPointField
        | IpField
        | KeywordField
        | LongField
        | CompositeField
        with
        override this.ToString() =
            match this with
            | PainlessTest -> "painless_test"
            | Filter -> "filter"
            | Score -> "score"
            | BooleanField -> "boolean_field"
            | DateField -> "date_field"
            | DoubleField -> "double_field"
            | GeoPointField -> "geo_point_field"
            | IpField -> "ip_field"
            | KeywordField -> "keyword_field"
            | LongField -> "long_field"
            | CompositeField -> "composite_field"

    and ScriptsPainlessExecutePainlessContextSetup = {
        [<JsonPropertyName("document")>]
        Document: obj
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer option
    }

    and TypesSearchApplicationTemplate = {
        [<JsonPropertyName("script")>]
        Script: Script
    }

    and TypesSearchApplicationParameters = {
        [<JsonPropertyName("indices")>]
        Indices: IndexName array
        [<JsonPropertyName("analytics_collection_name")>]
        AnalyticsCollectionName: Name option
        [<JsonPropertyName("template")>]
        Template: TypesSearchApplicationTemplate option
    }

    and TypesSearchApplication = {
        [<JsonPropertyName("indices")>]
        Indices: IndexName array
        [<JsonPropertyName("analytics_collection_name")>]
        AnalyticsCollectionName: Name option
        [<JsonPropertyName("template")>]
        Template: TypesSearchApplicationTemplate option
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("updated_at_millis")>]
        UpdatedAtMillis: EpochTimeUnitMillis
    }

    and TypesEventDataStream = {
        [<JsonPropertyName("name")>]
        Name: IndexName
    }

    and TypesAnalyticsCollection = {
        [<JsonPropertyName("event_data_stream")>]
        EventDataStream: TypesEventDataStream
    }

    and TypesEventTypeConverter() =
        inherit JsonConverter<TypesEventType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesEventType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesEventType.PageView -> "page_view"
                | TypesEventType.Search -> "search"
                | TypesEventType.SearchClick -> "search_click"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "page_view" -> TypesEventType.PageView
            | "search" -> TypesEventType.Search
            | "search_click" -> TypesEventType.SearchClick
            | s -> failwith $"Unknown TypesEventType: {s}"

    and [<JsonConverter(typeof<TypesEventTypeConverter>)>]
        TypesEventType =
        | PageView
        | Search
        | SearchClick
        with
        override this.ToString() =
            match this with
            | PageView -> "page_view"
            | Search -> "search"
            | SearchClick -> "search_click"

    and PutBehavioralAnalyticsAnalyticsAcknowledgeResponseBase = {
        [<JsonPropertyName("acknowledged")>]
        Acknowledged: bool
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and SearchMvtTypesZoomLevel = float

    and SearchMvtTypesCoordinate = float

    and SearchMvtTypesGridAggregationTypeConverter() =
        inherit JsonConverter<SearchMvtTypesGridAggregationType>()

        override _.Write(writer: Utf8JsonWriter, value: SearchMvtTypesGridAggregationType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchMvtTypesGridAggregationType.Geotile -> "geotile"
                | SearchMvtTypesGridAggregationType.Geohex -> "geohex"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "geotile" -> SearchMvtTypesGridAggregationType.Geotile
            | "geohex" -> SearchMvtTypesGridAggregationType.Geohex
            | s -> failwith $"Unknown SearchMvtTypesGridAggregationType: {s}"

    and [<JsonConverter(typeof<SearchMvtTypesGridAggregationTypeConverter>)>]
        SearchMvtTypesGridAggregationType =
        | Geotile
        | Geohex
        with
        override this.ToString() =
            match this with
            | Geotile -> "geotile"
            | Geohex -> "geohex"

    and SearchMvtTypesGridTypeConverter() =
        inherit JsonConverter<SearchMvtTypesGridType>()

        override _.Write(writer: Utf8JsonWriter, value: SearchMvtTypesGridType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | SearchMvtTypesGridType.Grid -> "grid"
                | SearchMvtTypesGridType.Point -> "point"
                | SearchMvtTypesGridType.Centroid -> "centroid"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "grid" -> SearchMvtTypesGridType.Grid
            | "point" -> SearchMvtTypesGridType.Point
            | "centroid" -> SearchMvtTypesGridType.Centroid
            | s -> failwith $"Unknown SearchMvtTypesGridType: {s}"

    and [<JsonConverter(typeof<SearchMvtTypesGridTypeConverter>)>]
        SearchMvtTypesGridType =
        | Grid
        | Point
        | Centroid
        with
        override this.ToString() =
            match this with
            | Grid -> "grid"
            | Point -> "point"
            | Centroid -> "centroid"

    and MapboxVectorTiles = obj

    and SearchShardsSearchShardsNodeAttributes = {
        [<JsonPropertyName("name")>]
        Name: NodeName
        [<JsonPropertyName("ephemeral_id")>]
        EphemeralId: Id
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("external_id")>]
        ExternalId: string
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles
        [<JsonPropertyName("version")>]
        Version: VersionString
        [<JsonPropertyName("min_index_version")>]
        MinIndexVersion: float
        [<JsonPropertyName("max_index_version")>]
        MaxIndexVersion: float
    }

    and RelocationFailureInfo = {
        [<JsonPropertyName("failed_attempts")>]
        FailedAttempts: float
    }

    and NodeShard = {
        [<JsonPropertyName("state")>]
        State: StatsShardRoutingState
        [<JsonPropertyName("primary")>]
        Primary: bool
        [<JsonPropertyName("node")>]
        Node: NodeName option
        [<JsonPropertyName("shard")>]
        Shard: float
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("allocation_id")>]
        AllocationId: Map<string, Id> option
        [<JsonPropertyName("recovery_source")>]
        RecoverySource: Map<string, Id> option
        [<JsonPropertyName("unassigned_info")>]
        UnassignedInfo: AllocationExplainUnassignedInformation option
        [<JsonPropertyName("relocating_node")>]
        RelocatingNode: System.Text.Json.JsonElement option
        [<JsonPropertyName("relocation_failure_info")>]
        RelocationFailureInfo: RelocationFailureInfo option
    }

    and SearchShardsShardStoreIndex = {
        [<JsonPropertyName("aliases")>]
        Aliases: Name array option
        [<JsonPropertyName("filter")>]
        Filter: QueryDslQueryContainer option
    }

    and CacheStatsShared = {
        [<JsonPropertyName("reads")>]
        Reads: float
        [<JsonPropertyName("bytes_read_in_bytes")>]
        BytesReadInBytes: ByteSize
        [<JsonPropertyName("writes")>]
        Writes: float
        [<JsonPropertyName("bytes_written_in_bytes")>]
        BytesWrittenInBytes: ByteSize
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("num_regions")>]
        NumRegions: float
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: ByteSize
        [<JsonPropertyName("region_size_in_bytes")>]
        RegionSizeInBytes: ByteSize
    }

    and CacheStatsNode = {
        [<JsonPropertyName("shared_cache")>]
        SharedCache: CacheStatsShared
    }

    and MountMountedSnapshot = {
        [<JsonPropertyName("snapshot")>]
        Snapshot: Name
        [<JsonPropertyName("indices")>]
        Indices: Indices
        [<JsonPropertyName("shards")>]
        Shards: ShardStatistics
    }

    and TypesStatsLevelConverter() =
        inherit JsonConverter<TypesStatsLevel>()

        override _.Write(writer: Utf8JsonWriter, value: TypesStatsLevel, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesStatsLevel.Cluster -> "cluster"
                | TypesStatsLevel.Indices -> "indices"
                | TypesStatsLevel.Shards -> "shards"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cluster" -> TypesStatsLevel.Cluster
            | "indices" -> TypesStatsLevel.Indices
            | "shards" -> TypesStatsLevel.Shards
            | s -> failwith $"Unknown TypesStatsLevel: {s}"

    and [<JsonConverter(typeof<TypesStatsLevelConverter>)>]
        TypesStatsLevel =
        | Cluster
        | Indices
        | Shards
        with
        override this.ToString() =
            match this with
            | Cluster -> "cluster"
            | Indices -> "indices"
            | Shards -> "shards"

    and TypesGrantTypeConverter() =
        inherit JsonConverter<TypesGrantType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGrantType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGrantType.Password -> "password"
                | TypesGrantType.AccessToken -> "access_token"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "password" -> TypesGrantType.Password
            | "access_token" -> TypesGrantType.AccessToken
            | s -> failwith $"Unknown TypesGrantType: {s}"

    and [<JsonConverter(typeof<TypesGrantTypeConverter>)>]
        TypesGrantType =
        | Password
        | AccessToken
        with
        override this.ToString() =
            match this with
            | Password -> "password"
            | AccessToken -> "access_token"

    and TypesUserProfileId = string

    and TypesUserProfileUser = {
        [<JsonPropertyName("email")>]
        Email: System.Text.Json.JsonElement option
        [<JsonPropertyName("full_name")>]
        FullName: System.Text.Json.JsonElement option
        [<JsonPropertyName("realm_name")>]
        RealmName: Name
        [<JsonPropertyName("realm_domain")>]
        RealmDomain: Name option
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("username")>]
        Username: Username
    }

    and TypesUserProfile = {
        [<JsonPropertyName("uid")>]
        Uid: TypesUserProfileId
        [<JsonPropertyName("user")>]
        User: TypesUserProfileUser
        [<JsonPropertyName("data")>]
        Data: Map<string, obj>
        [<JsonPropertyName("labels")>]
        Labels: Map<string, obj>
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
    }

    and TypesUserProfileHitMetadata = {
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber
    }

    and TypesUserProfileWithMetadata = {
        [<JsonPropertyName("uid")>]
        Uid: TypesUserProfileId
        [<JsonPropertyName("user")>]
        User: TypesUserProfileUser
        [<JsonPropertyName("data")>]
        Data: Map<string, obj>
        [<JsonPropertyName("labels")>]
        Labels: Map<string, obj>
        [<JsonPropertyName("enabled")>]
        Enabled: bool option
        [<JsonPropertyName("last_synchronized")>]
        LastSynchronized: float
        [<JsonPropertyName("_doc")>]
        Doc: TypesUserProfileHitMetadata
    }

    and TypesApiKeyManagedByConverter() =
        inherit JsonConverter<TypesApiKeyManagedBy>()

        override _.Write(writer: Utf8JsonWriter, value: TypesApiKeyManagedBy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesApiKeyManagedBy.Cloud -> "cloud"
                | TypesApiKeyManagedBy.Elasticsearch -> "elasticsearch"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "cloud" -> TypesApiKeyManagedBy.Cloud
            | "elasticsearch" -> TypesApiKeyManagedBy.Elasticsearch
            | s -> failwith $"Unknown TypesApiKeyManagedBy: {s}"

    and [<JsonConverter(typeof<TypesApiKeyManagedByConverter>)>]
        TypesApiKeyManagedBy =
        | Cloud
        | Elasticsearch
        with
        override this.ToString() =
            match this with
            | Cloud -> "cloud"
            | Elasticsearch -> "elasticsearch"

    and AuthenticateAuthenticateApiKey = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("managed_by")>]
        ManagedBy: TypesApiKeyManagedBy
        [<JsonPropertyName("internal")>]
        Internal: bool option
    }

    and TypesRealmInfo = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: string
    }

    and AuthenticateToken = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: string option
    }

    and TypesBulkError = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("details")>]
        Details: Map<string, ErrorCause>
    }

    and TypesApplicationPrivileges = {
        [<JsonPropertyName("application")>]
        Application: string
        [<JsonPropertyName("privileges")>]
        Privileges: string array
        [<JsonPropertyName("resources")>]
        Resources: string array
    }

    and TypesClusterPrivilege = obj

    and TypesManageUserPrivileges = {
        [<JsonPropertyName("applications")>]
        Applications: string array
    }

    and TypesApplicationGlobalUserPrivileges = {
        [<JsonPropertyName("manage")>]
        Manage: TypesManageUserPrivileges
    }

    and TypesGlobalPrivilege = {
        [<JsonPropertyName("application")>]
        Application: TypesApplicationGlobalUserPrivileges
    }

    and TypesFieldSecurity = {
        [<JsonPropertyName("except")>]
        Except: Fields option
        [<JsonPropertyName("grant")>]
        Grant: Fields option
    }

    and TypesIndexPrivilege = obj

    and TypesRoleTemplateInlineQuery = obj

    and TypesRoleTemplateScript = {
        [<JsonPropertyName("source")>]
        Source: TypesRoleTemplateInlineQuery option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("lang")>]
        Lang: ScriptLanguage option
        [<JsonPropertyName("options")>]
        Options: Map<string, string> option
    }

    and TypesRoleTemplateQuery = {
        [<JsonPropertyName("template")>]
        Template: TypesRoleTemplateScript option
    }

    /// <summary>
    /// While creating or updating a role you can provide either a JSON structure or a string to the API.
    /// However, the response provided by Elasticsearch will only be string with a json-as-text content.
    /// </summary>
    and TypesIndicesPrivilegesQuery = obj

    and TypesIndicesPrivileges = {
        [<JsonPropertyName("field_security")>]
        FieldSecurity: TypesFieldSecurity option
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("privileges")>]
        Privileges: TypesIndexPrivilege array
        [<JsonPropertyName("query")>]
        Query: TypesIndicesPrivilegesQuery option
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool option
    }

    and TypesRemoteClusterPrivilegeConverter() =
        inherit JsonConverter<TypesRemoteClusterPrivilege>()

        override _.Write(writer: Utf8JsonWriter, value: TypesRemoteClusterPrivilege, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesRemoteClusterPrivilege.MonitorEnrich -> "monitor_enrich"
                | TypesRemoteClusterPrivilege.MonitorStats -> "monitor_stats"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "monitor_enrich" -> TypesRemoteClusterPrivilege.MonitorEnrich
            | "monitor_stats" -> TypesRemoteClusterPrivilege.MonitorStats
            | s -> failwith $"Unknown TypesRemoteClusterPrivilege: {s}"

    and [<JsonConverter(typeof<TypesRemoteClusterPrivilegeConverter>)>]
        TypesRemoteClusterPrivilege =
        | MonitorEnrich
        | MonitorStats
        with
        override this.ToString() =
            match this with
            | MonitorEnrich -> "monitor_enrich"
            | MonitorStats -> "monitor_stats"

    /// <summary>
    /// The subset of cluster level privileges that can be defined for remote clusters.
    /// </summary>
    and TypesRemoteClusterPrivileges = {
        [<JsonPropertyName("clusters")>]
        Clusters: Names
        [<JsonPropertyName("privileges")>]
        Privileges: TypesRemoteClusterPrivilege array
    }

    /// <summary>
    /// The subset of index level privileges that can be defined for remote clusters.
    /// </summary>
    and TypesRemoteIndicesPrivileges = {
        [<JsonPropertyName("clusters")>]
        Clusters: Names
        [<JsonPropertyName("field_security")>]
        FieldSecurity: TypesFieldSecurity option
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("privileges")>]
        Privileges: TypesIndexPrivilege array
        [<JsonPropertyName("query")>]
        Query: TypesIndicesPrivilegesQuery option
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool option
    }

    and TypesRestrictionWorkflow = obj

    and TypesRestriction = {
        [<JsonPropertyName("workflows")>]
        Workflows: TypesRestrictionWorkflow array
    }

    and TypesRoleDescriptor = {
        [<JsonPropertyName("cluster")>]
        Cluster: TypesClusterPrivilege array option
        [<JsonPropertyName("indices")>]
        Indices: TypesIndicesPrivileges array option
        [<JsonPropertyName("remote_indices")>]
        RemoteIndices: TypesRemoteIndicesPrivileges array option
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: TypesRemoteClusterPrivileges array option
        [<JsonPropertyName("global")>]
        Global: System.Text.Json.JsonElement option
        [<JsonPropertyName("applications")>]
        Applications: TypesApplicationPrivileges array option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("run_as")>]
        RunAs: string array option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("restriction")>]
        Restriction: TypesRestriction option
        [<JsonPropertyName("transient_metadata")>]
        TransientMetadata: Map<string, obj> option
    }

    and TypesClusterNode = {
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and Namespace = string

    and Service = string

    and TypesReplicationAccess = {
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool option
    }

    and TypesSearchAccess = {
        [<JsonPropertyName("field_security")>]
        FieldSecurity: TypesFieldSecurity option
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("query")>]
        Query: TypesIndicesPrivilegesQuery option
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool option
    }

    and TypesAccess = {
        [<JsonPropertyName("replication")>]
        Replication: TypesReplicationAccess array option
        [<JsonPropertyName("search")>]
        Search: TypesSearchAccess array option
    }

    and CreateServiceTokenToken = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("value")>]
        Value: string
    }

    and DelegatePkiAuthenticationRealm = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("domain")>]
        Domain: string option
    }

    and DelegatePkiAuthentication = {
        [<JsonPropertyName("username")>]
        Username: string
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("full_name")>]
        FullName: System.Text.Json.JsonElement
        [<JsonPropertyName("email")>]
        Email: System.Text.Json.JsonElement
        [<JsonPropertyName("token")>]
        Token: Map<string, string> option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("authentication_realm")>]
        AuthenticationRealm: DelegatePkiAuthenticationRealm
        [<JsonPropertyName("lookup_realm")>]
        LookupRealm: DelegatePkiAuthenticationRealm
        [<JsonPropertyName("authentication_type")>]
        AuthenticationType: string
        [<JsonPropertyName("api_key")>]
        ApiKey: Map<string, string> option
    }

    and DeletePrivilegesFoundStatus = {
        [<JsonPropertyName("found")>]
        Found: bool
    }

    and EnrollKibanaToken = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("value")>]
        Value: string
    }

    and TypesApiKeyTypeConverter() =
        inherit JsonConverter<TypesApiKeyType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesApiKeyType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesApiKeyType.Rest -> "rest"
                | TypesApiKeyType.CrossCluster -> "cross_cluster"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "rest" -> TypesApiKeyType.Rest
            | "cross_cluster" -> TypesApiKeyType.CrossCluster
            | s -> failwith $"Unknown TypesApiKeyType: {s}"

    and [<JsonConverter(typeof<TypesApiKeyTypeConverter>)>]
        TypesApiKeyType =
        | Rest
        | CrossCluster
        with
        override this.ToString() =
            match this with
            | Rest -> "rest"
            | CrossCluster -> "cross_cluster"

    and TypesApiKey = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: TypesApiKeyType
        [<JsonPropertyName("creation")>]
        Creation: EpochTimeUnitMillis
        [<JsonPropertyName("expiration")>]
        Expiration: EpochTimeUnitMillis option
        [<JsonPropertyName("invalidated")>]
        Invalidated: bool
        [<JsonPropertyName("invalidation")>]
        Invalidation: EpochTimeUnitMillis option
        [<JsonPropertyName("username")>]
        Username: Username
        [<JsonPropertyName("realm")>]
        Realm: string
        [<JsonPropertyName("realm_type")>]
        RealmType: string option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("role_descriptors")>]
        RoleDescriptors: Map<string, TypesRoleDescriptor> option
        [<JsonPropertyName("limited_by")>]
        LimitedBy: Map<string, TypesRoleDescriptor> array option
        [<JsonPropertyName("access")>]
        Access: TypesAccess option
        [<JsonPropertyName("certificate_identity")>]
        CertificateIdentity: string option
        [<JsonPropertyName("profile_uid")>]
        ProfileUid: string option
        [<JsonPropertyName("_sort")>]
        Sort: SortResults option
    }

    and PutPrivilegesActions = {
        [<JsonPropertyName("actions")>]
        Actions: string array
        [<JsonPropertyName("application")>]
        Application: string option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
    }

    and TypesTemplateFormatConverter() =
        inherit JsonConverter<TypesTemplateFormat>()

        override _.Write(writer: Utf8JsonWriter, value: TypesTemplateFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesTemplateFormat.String -> "string"
                | TypesTemplateFormat.Json -> "json"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "string" -> TypesTemplateFormat.String
            | "json" -> TypesTemplateFormat.Json
            | s -> failwith $"Unknown TypesTemplateFormat: {s}"

    and [<JsonConverter(typeof<TypesTemplateFormatConverter>)>]
        TypesTemplateFormat =
        | String
        | Json
        with
        override this.ToString() =
            match this with
            | String -> "string"
            | Json -> "json"

    and TypesRoleTemplate = {
        [<JsonPropertyName("format")>]
        Format: TypesTemplateFormat option
        [<JsonPropertyName("template")>]
        Template: Script
    }

    and GetRoleRole = {
        [<JsonPropertyName("cluster")>]
        Cluster: TypesClusterPrivilege array
        [<JsonPropertyName("indices")>]
        Indices: TypesIndicesPrivileges array
        [<JsonPropertyName("remote_indices")>]
        RemoteIndices: TypesRemoteIndicesPrivileges array option
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: TypesRemoteClusterPrivileges array option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("run_as")>]
        RunAs: string array option
        [<JsonPropertyName("transient_metadata")>]
        TransientMetadata: Map<string, obj> option
        [<JsonPropertyName("applications")>]
        Applications: TypesApplicationPrivileges array
        [<JsonPropertyName("role_templates")>]
        RoleTemplates: TypesRoleTemplate array option
        [<JsonPropertyName("global")>]
        Global: Map<string, Map<string, Map<string, string array>>> option
    }

    and TypesRoleMappingRule = {
        [<JsonPropertyName("any")>]
        Any: TypesRoleMappingRule array option
        [<JsonPropertyName("all")>]
        All: TypesRoleMappingRule array option
        [<JsonPropertyName("field")>]
        Field: Map<string, System.Text.Json.JsonElement> option
        [<JsonPropertyName("except")>]
        Except: TypesRoleMappingRule option
    }

    and TypesRoleMapping = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("roles")>]
        Roles: string array option
        [<JsonPropertyName("role_templates")>]
        RoleTemplates: TypesRoleTemplate array option
        [<JsonPropertyName("rules")>]
        Rules: TypesRoleMappingRule
    }

    and TypesRoleDescriptorRead = {
        [<JsonPropertyName("cluster")>]
        Cluster: TypesClusterPrivilege array
        [<JsonPropertyName("indices")>]
        Indices: TypesIndicesPrivileges array
        [<JsonPropertyName("remote_indices")>]
        RemoteIndices: TypesRemoteIndicesPrivileges array option
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: TypesRemoteClusterPrivileges array option
        [<JsonPropertyName("global")>]
        Global: System.Text.Json.JsonElement option
        [<JsonPropertyName("applications")>]
        Applications: TypesApplicationPrivileges array option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("run_as")>]
        RunAs: string array option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("restriction")>]
        Restriction: TypesRestriction option
        [<JsonPropertyName("transient_metadata")>]
        TransientMetadata: Map<string, obj> option
    }

    and GetServiceAccountsRoleDescriptorWrapper = {
        [<JsonPropertyName("role_descriptor")>]
        RoleDescriptor: TypesRoleDescriptorRead
    }

    and GetServiceCredentialsNodesCredentialsFileToken = {
        [<JsonPropertyName("nodes")>]
        Nodes: string array
    }

    and GetServiceCredentialsNodesCredentials = {
        [<JsonPropertyName("_nodes")>]
        Nodes: NodeStatistics
        [<JsonPropertyName("file_tokens")>]
        FileTokens: Map<string, GetServiceCredentialsNodesCredentialsFileToken>
    }

    and TypesSecuritySettings = {
        [<JsonPropertyName("index")>]
        Index: TypesIndexSettings option
    }

    and UsageSecurityRolesDlsBitSetCache = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("memory")>]
        Memory: ByteSize option
        [<JsonPropertyName("memory_in_bytes")>]
        MemoryInBytes: Ulong
        [<JsonPropertyName("hits")>]
        Hits: float
        [<JsonPropertyName("misses")>]
        Misses: float
        [<JsonPropertyName("evictions")>]
        Evictions: float
        [<JsonPropertyName("hits_time_in_millis")>]
        HitsTimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("misses_time_in_millis")>]
        MissesTimeInMillis: DurationValueUnitMillis
    }

    and UsageSecurityRolesDls = {
        [<JsonPropertyName("bit_set_cache")>]
        BitSetCache: UsageSecurityRolesDlsBitSetCache
    }

    and TypesRolesStats = {
        [<JsonPropertyName("dls")>]
        Dls: UsageSecurityRolesDls
    }

    and TypesNodeSecurityStats = {
        [<JsonPropertyName("roles")>]
        Roles: TypesRolesStats
    }

    and GetTokenAccessTokenGrantTypeConverter() =
        inherit JsonConverter<GetTokenAccessTokenGrantType>()

        override _.Write(writer: Utf8JsonWriter, value: GetTokenAccessTokenGrantType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GetTokenAccessTokenGrantType.Password -> "password"
                | GetTokenAccessTokenGrantType.ClientCredentials -> "client_credentials"
                | GetTokenAccessTokenGrantType.Kerberos -> "_kerberos"
                | GetTokenAccessTokenGrantType.RefreshToken -> "refresh_token"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "password" -> GetTokenAccessTokenGrantType.Password
            | "client_credentials" -> GetTokenAccessTokenGrantType.ClientCredentials
            | "_kerberos" -> GetTokenAccessTokenGrantType.Kerberos
            | "refresh_token" -> GetTokenAccessTokenGrantType.RefreshToken
            | s -> failwith $"Unknown GetTokenAccessTokenGrantType: {s}"

    and [<JsonConverter(typeof<GetTokenAccessTokenGrantTypeConverter>)>]
        GetTokenAccessTokenGrantType =
        | Password
        | ClientCredentials
        | Kerberos
        | RefreshToken
        with
        override this.ToString() =
            match this with
            | Password -> "password"
            | ClientCredentials -> "client_credentials"
            | Kerberos -> "_kerberos"
            | RefreshToken -> "refresh_token"

    and TypesUser = {
        [<JsonPropertyName("email")>]
        Email: System.Text.Json.JsonElement option
        [<JsonPropertyName("full_name")>]
        FullName: System.Text.Json.JsonElement option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("username")>]
        Username: Username
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("profile_uid")>]
        ProfileUid: TypesUserProfileId option
    }

    and GetTokenAuthenticationProvider = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and GetTokenUserRealm = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: string
    }

    and GetTokenAuthenticatedUser = {
        [<JsonPropertyName("email")>]
        Email: System.Text.Json.JsonElement option
        [<JsonPropertyName("full_name")>]
        FullName: System.Text.Json.JsonElement option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("username")>]
        Username: Username
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("profile_uid")>]
        ProfileUid: TypesUserProfileId option
        [<JsonPropertyName("authentication_realm")>]
        AuthenticationRealm: GetTokenUserRealm
        [<JsonPropertyName("lookup_realm")>]
        LookupRealm: GetTokenUserRealm
        [<JsonPropertyName("authentication_provider")>]
        AuthenticationProvider: GetTokenAuthenticationProvider option
        [<JsonPropertyName("authentication_type")>]
        AuthenticationType: string
    }

    and TypesUserIndicesPrivileges = {
        [<JsonPropertyName("field_security")>]
        FieldSecurity: TypesFieldSecurity array option
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("privileges")>]
        Privileges: TypesIndexPrivilege array
        [<JsonPropertyName("query")>]
        Query: TypesIndicesPrivilegesQuery array option
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool
    }

    and TypesRemoteUserIndicesPrivileges = {
        [<JsonPropertyName("field_security")>]
        FieldSecurity: TypesFieldSecurity array option
        [<JsonPropertyName("names")>]
        Names: System.Text.Json.JsonElement
        [<JsonPropertyName("privileges")>]
        Privileges: TypesIndexPrivilege array
        [<JsonPropertyName("query")>]
        Query: TypesIndicesPrivilegesQuery array option
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool
        [<JsonPropertyName("clusters")>]
        Clusters: string array
    }

    and GetUserProfileGetUserProfileErrors = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("details")>]
        Details: Map<string, ErrorCause>
    }

    and GrantApiKeyGrantApiKey = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("expiration")>]
        Expiration: DurationLarge option
        [<JsonPropertyName("role_descriptors")>]
        RoleDescriptors: System.Text.Json.JsonElement option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
    }

    and GrantApiKeyApiKeyGrantTypeConverter() =
        inherit JsonConverter<GrantApiKeyApiKeyGrantType>()

        override _.Write(writer: Utf8JsonWriter, value: GrantApiKeyApiKeyGrantType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | GrantApiKeyApiKeyGrantType.AccessToken -> "access_token"
                | GrantApiKeyApiKeyGrantType.Password -> "password"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "access_token" -> GrantApiKeyApiKeyGrantType.AccessToken
            | "password" -> GrantApiKeyApiKeyGrantType.Password
            | s -> failwith $"Unknown GrantApiKeyApiKeyGrantType: {s}"

    and [<JsonConverter(typeof<GrantApiKeyApiKeyGrantTypeConverter>)>]
        GrantApiKeyApiKeyGrantType =
        | AccessToken
        | Password
        with
        override this.ToString() =
            match this with
            | AccessToken -> "access_token"
            | Password -> "password"

    and HasPrivilegesApplicationPrivilegesCheck = {
        [<JsonPropertyName("application")>]
        Application: string
        [<JsonPropertyName("privileges")>]
        Privileges: string array
        [<JsonPropertyName("resources")>]
        Resources: string array
    }

    and HasPrivilegesIndexPrivilegesCheck = {
        [<JsonPropertyName("names")>]
        Names: Indices
        [<JsonPropertyName("privileges")>]
        Privileges: TypesIndexPrivilege array
        [<JsonPropertyName("allow_restricted_indices")>]
        AllowRestrictedIndices: bool option
    }

    and HasPrivilegesPrivileges = Map<string, bool>

    and HasPrivilegesResourcePrivileges = Map<string, HasPrivilegesPrivileges>

    and HasPrivilegesApplicationsPrivileges = Map<string, HasPrivilegesResourcePrivileges>

    and HasPrivilegesUserProfilePrivilegesCheck = {
        [<JsonPropertyName("application")>]
        Application: HasPrivilegesApplicationPrivilegesCheck array option
        [<JsonPropertyName("cluster")>]
        Cluster: TypesClusterPrivilege array option
        [<JsonPropertyName("index")>]
        Index: HasPrivilegesIndexPrivilegesCheck array option
    }

    and HasPrivilegesUserProfileHasPrivilegesUserProfileErrors = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("details")>]
        Details: Map<string, ErrorCause>
    }

    and TypesCreatedStatus = {
        [<JsonPropertyName("created")>]
        Created: bool
    }

    and QueryApiKeysApiKeyQueryContainer = {
        [<JsonPropertyName("bool")>]
        Bool: QueryDslBoolQuery option
        [<JsonPropertyName("exists")>]
        Exists: QueryDslExistsQuery option
        [<JsonPropertyName("ids")>]
        Ids: QueryDslIdsQuery option
        [<JsonPropertyName("match")>]
        Match: Map<string, QueryDslMatchQuery> option
        [<JsonPropertyName("match_all")>]
        MatchAll: QueryDslMatchAllQuery option
        [<JsonPropertyName("prefix")>]
        Prefix: Map<string, QueryDslPrefixQuery> option
        [<JsonPropertyName("range")>]
        Range: Map<string, QueryDslRangeQuery> option
        [<JsonPropertyName("simple_query_string")>]
        SimpleQueryString: QueryDslSimpleQueryStringQuery option
        [<JsonPropertyName("term")>]
        Term: Map<string, QueryDslTermQuery> option
        [<JsonPropertyName("terms")>]
        Terms: QueryDslTermsQuery option
        [<JsonPropertyName("wildcard")>]
        Wildcard: Map<string, QueryDslWildcardQuery> option
    }

    /// <summary>
    /// Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
    /// the different buckets, the result is a dictionary.
    /// </summary>
    and AggregationsBucketsApiKeyQueryContainer = obj

    and QueryApiKeysApiKeyFiltersAggregation = {
        [<JsonPropertyName("filters")>]
        Filters: AggregationsBucketsApiKeyQueryContainer option
        [<JsonPropertyName("other_bucket")>]
        OtherBucket: bool option
        [<JsonPropertyName("other_bucket_key")>]
        OtherBucketKey: string option
        [<JsonPropertyName("keyed")>]
        Keyed: bool option
    }

    and QueryApiKeysApiKeyAggregationContainer = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, QueryApiKeysApiKeyAggregationContainer> option
        [<JsonPropertyName("meta")>]
        Meta: Metadata option
        [<JsonPropertyName("cardinality")>]
        Cardinality: AggregationsCardinalityAggregation option
        [<JsonPropertyName("composite")>]
        Composite: AggregationsCompositeAggregation option
        [<JsonPropertyName("date_range")>]
        DateRange: AggregationsDateRangeAggregation option
        [<JsonPropertyName("filter")>]
        Filter: QueryApiKeysApiKeyQueryContainer option
        [<JsonPropertyName("filters")>]
        Filters: QueryApiKeysApiKeyFiltersAggregation option
        [<JsonPropertyName("missing")>]
        Missing: AggregationsMissingAggregation option
        [<JsonPropertyName("range")>]
        Range: AggregationsRangeAggregation option
        [<JsonPropertyName("terms")>]
        Terms: AggregationsTermsAggregation option
        [<JsonPropertyName("value_count")>]
        ValueCount: AggregationsValueCountAggregation option
    }

    and QueryApiKeysApiKeyAggregate = obj

    and QueryRoleRoleQueryContainer = {
        [<JsonPropertyName("bool")>]
        Bool: QueryDslBoolQuery option
        [<JsonPropertyName("exists")>]
        Exists: QueryDslExistsQuery option
        [<JsonPropertyName("ids")>]
        Ids: QueryDslIdsQuery option
        [<JsonPropertyName("match")>]
        Match: Map<string, QueryDslMatchQuery> option
        [<JsonPropertyName("match_all")>]
        MatchAll: QueryDslMatchAllQuery option
        [<JsonPropertyName("prefix")>]
        Prefix: Map<string, QueryDslPrefixQuery> option
        [<JsonPropertyName("range")>]
        Range: Map<string, QueryDslRangeQuery> option
        [<JsonPropertyName("simple_query_string")>]
        SimpleQueryString: QueryDslSimpleQueryStringQuery option
        [<JsonPropertyName("term")>]
        Term: Map<string, QueryDslTermQuery> option
        [<JsonPropertyName("terms")>]
        Terms: QueryDslTermsQuery option
        [<JsonPropertyName("wildcard")>]
        Wildcard: Map<string, QueryDslWildcardQuery> option
    }

    and QueryRoleQueryRole = {
        [<JsonPropertyName("cluster")>]
        Cluster: TypesClusterPrivilege array option
        [<JsonPropertyName("indices")>]
        Indices: TypesIndicesPrivileges array option
        [<JsonPropertyName("remote_indices")>]
        RemoteIndices: TypesRemoteIndicesPrivileges array option
        [<JsonPropertyName("remote_cluster")>]
        RemoteCluster: TypesRemoteClusterPrivileges array option
        [<JsonPropertyName("global")>]
        Global: System.Text.Json.JsonElement option
        [<JsonPropertyName("applications")>]
        Applications: TypesApplicationPrivileges array option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("run_as")>]
        RunAs: string array option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("restriction")>]
        Restriction: TypesRestriction option
        [<JsonPropertyName("transient_metadata")>]
        TransientMetadata: Map<string, obj> option
        [<JsonPropertyName("_sort")>]
        Sort: SortResults option
        [<JsonPropertyName("name")>]
        Name: string
    }

    and QueryUserUserQueryContainer = {
        [<JsonPropertyName("ids")>]
        Ids: QueryDslIdsQuery option
        [<JsonPropertyName("bool")>]
        Bool: QueryDslBoolQuery option
        [<JsonPropertyName("exists")>]
        Exists: QueryDslExistsQuery option
        [<JsonPropertyName("match")>]
        Match: Map<string, QueryDslMatchQuery> option
        [<JsonPropertyName("match_all")>]
        MatchAll: QueryDslMatchAllQuery option
        [<JsonPropertyName("prefix")>]
        Prefix: Map<string, QueryDslPrefixQuery> option
        [<JsonPropertyName("range")>]
        Range: Map<string, QueryDslRangeQuery> option
        [<JsonPropertyName("simple_query_string")>]
        SimpleQueryString: QueryDslSimpleQueryStringQuery option
        [<JsonPropertyName("term")>]
        Term: Map<string, QueryDslTermQuery> option
        [<JsonPropertyName("terms")>]
        Terms: QueryDslTermsQuery option
        [<JsonPropertyName("wildcard")>]
        Wildcard: Map<string, QueryDslWildcardQuery> option
    }

    and QueryUserQueryUser = {
        [<JsonPropertyName("email")>]
        Email: System.Text.Json.JsonElement option
        [<JsonPropertyName("full_name")>]
        FullName: System.Text.Json.JsonElement option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata
        [<JsonPropertyName("roles")>]
        Roles: string array
        [<JsonPropertyName("username")>]
        Username: Username
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("profile_uid")>]
        ProfileUid: TypesUserProfileId option
        [<JsonPropertyName("_sort")>]
        Sort: SortResults option
    }

    and SuggestUserProfilesHint = {
        [<JsonPropertyName("uids")>]
        Uids: TypesUserProfileId array option
        [<JsonPropertyName("labels")>]
        Labels: Map<string, System.Text.Json.JsonElement> option
    }

    and SuggestUserProfilesTotalUserProfiles = {
        [<JsonPropertyName("value")>]
        Value: float
        [<JsonPropertyName("relation")>]
        Relation: RelationName
    }

    and IngestMergeTypeConverter() =
        inherit JsonConverter<IngestMergeType>()

        override _.Write(writer: Utf8JsonWriter, value: IngestMergeType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | IngestMergeType.Index -> "index"
                | IngestMergeType.Template -> "template"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "index" -> IngestMergeType.Index
            | "template" -> IngestMergeType.Template
            | s -> failwith $"Unknown IngestMergeType: {s}"

    and [<JsonConverter(typeof<IngestMergeTypeConverter>)>]
        IngestMergeType =
        | Index
        | Template
        with
        override this.ToString() =
            match this with
            | Index -> "index"
            | Template -> "template"

    /// <summary>
    /// The results of ingest simulation on a single document. The _source of the document contains
    /// the results after running all pipelines listed in executed_pipelines on the document. The
    /// list of executed pipelines is derived from the pipelines that would be executed if this
    /// </summary>
    and IngestIngestDocumentSimulation = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_source")>]
        Source: Map<string, obj>
        [<JsonPropertyName("_version")>]
        Version: StringifiedVersionNumber
        [<JsonPropertyName("executed_pipelines")>]
        ExecutedPipelines: string array
        [<JsonPropertyName("ignored_fields")>]
        IgnoredFields: Map<string, string> array option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
        [<JsonPropertyName("effective_mapping")>]
        EffectiveMapping: MappingTypeMapping option
    }

    and IngestSimulateIngestDocumentResult = {
        [<JsonPropertyName("doc")>]
        Doc: IngestIngestDocumentSimulation option
    }

    and TypesInProgress = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("start_time_millis")>]
        StartTimeMillis: EpochTimeUnitMillis
        [<JsonPropertyName("state")>]
        State: string
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid
    }

    and TypesInvocation = {
        [<JsonPropertyName("snapshot_name")>]
        SnapshotName: Name
        [<JsonPropertyName("time")>]
        Time: DateTime
    }

    and TypesStatistics = {
        [<JsonPropertyName("retention_deletion_time")>]
        RetentionDeletionTime: Duration option
        [<JsonPropertyName("retention_deletion_time_millis")>]
        RetentionDeletionTimeMillis: DurationValueUnitMillis option
        [<JsonPropertyName("retention_failed")>]
        RetentionFailed: float option
        [<JsonPropertyName("retention_runs")>]
        RetentionRuns: float option
        [<JsonPropertyName("retention_timed_out")>]
        RetentionTimedOut: float option
        [<JsonPropertyName("policy")>]
        Policy: Id option
        [<JsonPropertyName("total_snapshots_deleted")>]
        TotalSnapshotsDeleted: float option
        [<JsonPropertyName("total_snapshot_deletion_failures")>]
        TotalSnapshotDeletionFailures: float option
        [<JsonPropertyName("total_snapshots_failed")>]
        TotalSnapshotsFailed: float option
        [<JsonPropertyName("total_snapshots_taken")>]
        TotalSnapshotsTaken: float option
    }

    and TypesSnapshotLifecycle = {
        [<JsonPropertyName("in_progress")>]
        InProgress: TypesInProgress option
        [<JsonPropertyName("last_failure")>]
        LastFailure: TypesInvocation option
        [<JsonPropertyName("last_success")>]
        LastSuccess: TypesInvocation option
        [<JsonPropertyName("modified_date")>]
        ModifiedDate: DateTime option
        [<JsonPropertyName("modified_date_millis")>]
        ModifiedDateMillis: EpochTimeUnitMillis
        [<JsonPropertyName("next_execution")>]
        NextExecution: DateTime option
        [<JsonPropertyName("next_execution_millis")>]
        NextExecutionMillis: EpochTimeUnitMillis
        [<JsonPropertyName("policy")>]
        Policy: System.Text.Json.JsonElement
        [<JsonPropertyName("version")>]
        Version: VersionNumber
        [<JsonPropertyName("stats")>]
        Stats: TypesStatistics
    }

    and TypesConfiguration = {
        [<JsonPropertyName("ignore_unavailable")>]
        IgnoreUnavailable: bool option
        [<JsonPropertyName("indices")>]
        Indices: Indices option
        [<JsonPropertyName("include_global_state")>]
        IncludeGlobalState: bool option
        [<JsonPropertyName("feature_states")>]
        FeatureStates: string array option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("partial")>]
        Partial: bool option
    }

    and TypesRetention = {
        [<JsonPropertyName("expire_after")>]
        ExpireAfter: Duration
        [<JsonPropertyName("max_count")>]
        MaxCount: float
        [<JsonPropertyName("min_count")>]
        MinCount: float
    }

    and TypesCronExpression = string

    and TypesSnapshotPolicyStats = {
        [<JsonPropertyName("policy")>]
        Policy: string
        [<JsonPropertyName("snapshots_taken")>]
        SnapshotsTaken: float
        [<JsonPropertyName("snapshots_failed")>]
        SnapshotsFailed: float
        [<JsonPropertyName("snapshots_deleted")>]
        SnapshotsDeleted: float
        [<JsonPropertyName("snapshot_deletion_failures")>]
        SnapshotDeletionFailures: float
    }

    and CleanupRepositoryCleanupRepositoryResults = {
        [<JsonPropertyName("deleted_blobs")>]
        DeletedBlobs: float
        [<JsonPropertyName("deleted_bytes")>]
        DeletedBytes: float
    }

    and TypesIndexDetails = {
        [<JsonPropertyName("shard_count")>]
        ShardCount: float
        [<JsonPropertyName("size")>]
        Size: ByteSize option
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
        [<JsonPropertyName("max_segments_per_shard")>]
        MaxSegmentsPerShard: float
    }

    and TypesInfoFeatureState = {
        [<JsonPropertyName("feature_name")>]
        FeatureName: string
        [<JsonPropertyName("indices")>]
        Indices: Indices
    }

    and TypesSnapshotShardFailure = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("node_id")>]
        NodeId: Id option
        [<JsonPropertyName("reason")>]
        Reason: string
        [<JsonPropertyName("shard_id")>]
        ShardId: float
        [<JsonPropertyName("index_uuid")>]
        IndexUuid: Id
        [<JsonPropertyName("status")>]
        Status: string
    }

    and TypesSnapshotInfo = {
        [<JsonPropertyName("data_streams")>]
        DataStreams: string array
        [<JsonPropertyName("duration")>]
        Duration: Duration option
        [<JsonPropertyName("duration_in_millis")>]
        DurationInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("end_time")>]
        EndTime: DateTime option
        [<JsonPropertyName("end_time_in_millis")>]
        EndTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("failures")>]
        Failures: TypesSnapshotShardFailure array option
        [<JsonPropertyName("include_global_state")>]
        IncludeGlobalState: bool option
        [<JsonPropertyName("indices")>]
        Indices: IndexName array option
        [<JsonPropertyName("index_details")>]
        IndexDetails: Map<string, TypesIndexDetails> option
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("repository")>]
        Repository: Name option
        [<JsonPropertyName("snapshot")>]
        Snapshot: Name
        [<JsonPropertyName("shards")>]
        Shards: ShardStatistics option
        [<JsonPropertyName("start_time")>]
        StartTime: DateTime option
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("state")>]
        State: string option
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("version_id")>]
        VersionId: VersionNumber option
        [<JsonPropertyName("feature_states")>]
        FeatureStates: TypesInfoFeatureState array option
    }

    and TypesRepositorySettingsBase = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
    }

    and TypesAzureRepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("base_path")>]
        BasePath: string option
        [<JsonPropertyName("client")>]
        Client: string option
        [<JsonPropertyName("container")>]
        Container: string option
        [<JsonPropertyName("delete_objects_max_size")>]
        DeleteObjectsMaxSize: float option
        [<JsonPropertyName("location_mode")>]
        LocationMode: string option
        [<JsonPropertyName("max_concurrent_batch_deletes")>]
        MaxConcurrentBatchDeletes: float option
        [<JsonPropertyName("readonly")>]
        Readonly: bool option
    }

    and TypesRepositoryBase = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
    }

    and TypesAzureRepository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesAzureRepositorySettings option
    }

    and TypesGcsRepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("bucket")>]
        Bucket: string
        [<JsonPropertyName("application_name")>]
        ApplicationName: string option
        [<JsonPropertyName("base_path")>]
        BasePath: string option
        [<JsonPropertyName("client")>]
        Client: string option
        [<JsonPropertyName("readonly")>]
        Readonly: bool option
    }

    and TypesGcsRepository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesGcsRepositorySettings
    }

    and TypesReadOnlyUrlRepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("http_max_retries")>]
        HttpMaxRetries: float option
        [<JsonPropertyName("http_socket_timeout")>]
        HttpSocketTimeout: Duration option
        [<JsonPropertyName("max_number_of_snapshots")>]
        MaxNumberOfSnapshots: float option
        [<JsonPropertyName("url")>]
        Url: string
    }

    and TypesReadOnlyUrlRepository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesReadOnlyUrlRepositorySettings
    }

    and TypesS3RepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("bucket")>]
        Bucket: string
        [<JsonPropertyName("base_path")>]
        BasePath: string option
        [<JsonPropertyName("buffer_size")>]
        BufferSize: ByteSize option
        [<JsonPropertyName("canned_acl")>]
        CannedAcl: string option
        [<JsonPropertyName("client")>]
        Client: string option
        [<JsonPropertyName("delete_objects_max_size")>]
        DeleteObjectsMaxSize: float option
        [<JsonPropertyName("get_register_retry_delay")>]
        GetRegisterRetryDelay: Duration option
        [<JsonPropertyName("max_multipart_parts")>]
        MaxMultipartParts: float option
        [<JsonPropertyName("max_multipart_upload_cleanup_size")>]
        MaxMultipartUploadCleanupSize: float option
        [<JsonPropertyName("readonly")>]
        Readonly: bool option
        [<JsonPropertyName("server_side_encryption")>]
        ServerSideEncryption: bool option
        [<JsonPropertyName("storage_class")>]
        StorageClass: string option
        [<JsonPropertyName("throttled_delete_retry.delay_increment")>]
        ThrottledDeleteRetryDelayIncrement: Duration option
        [<JsonPropertyName("throttled_delete_retry.maximum_delay")>]
        ThrottledDeleteRetryMaximumDelay: Duration option
        [<JsonPropertyName("throttled_delete_retry.maximum_number_of_retries")>]
        ThrottledDeleteRetryMaximumNumberOfRetries: float option
    }

    and TypesS3Repository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesS3RepositorySettings
    }

    and TypesSharedFileSystemRepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("location")>]
        Location: string
        [<JsonPropertyName("max_number_of_snapshots")>]
        MaxNumberOfSnapshots: float option
        [<JsonPropertyName("readonly")>]
        Readonly: bool option
    }

    and TypesSharedFileSystemRepository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesSharedFileSystemRepositorySettings
    }

    and TypesSourceOnlyRepositorySettings = {
        [<JsonPropertyName("chunk_size")>]
        ChunkSize: ByteSize option
        [<JsonPropertyName("compress")>]
        Compress: bool option
        [<JsonPropertyName("max_restore_bytes_per_sec")>]
        MaxRestoreBytesPerSec: ByteSize option
        [<JsonPropertyName("max_snapshot_bytes_per_sec")>]
        MaxSnapshotBytesPerSec: ByteSize option
        [<JsonPropertyName("delegate_type")>]
        DelegateType: string option
        [<JsonPropertyName("max_number_of_snapshots")>]
        MaxNumberOfSnapshots: float option
        [<JsonPropertyName("read_only")>]
        ReadOnly: bool option
    }

    and TypesSourceOnlyRepository = {
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid option
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("settings")>]
        Settings: TypesSourceOnlyRepositorySettings
    }

    and TypesRepositoryConverter() =
        inherit JsonConverter<TypesRepository>()

        override _.Write(writer: Utf8JsonWriter, value: TypesRepository, options: JsonSerializerOptions) =
            match value with
            | TypesRepository.Azure v -> JsonSerializer.Serialize(writer, v, options)
            | TypesRepository.Fs v -> JsonSerializer.Serialize(writer, v, options)
            | TypesRepository.Gcs v -> JsonSerializer.Serialize(writer, v, options)
            | TypesRepository.S3 v -> JsonSerializer.Serialize(writer, v, options)
            | TypesRepository.Source v -> JsonSerializer.Serialize(writer, v, options)
            | TypesRepository.Url v -> JsonSerializer.Serialize(writer, v, options)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, options: JsonSerializerOptions) =
            use doc = JsonDocument.ParseValue(&reader)
            let root = doc.RootElement
            let discValue =
                match root.TryGetProperty("type") with
                | true, prop -> prop.GetString()
                | false, _ -> ""
            let json = root.GetRawText()
            match discValue with
            | "azure" -> TypesRepository.Azure (JsonSerializer.Deserialize<TypesAzureRepository>(json, options))
            | "fs" -> TypesRepository.Fs (JsonSerializer.Deserialize<TypesSharedFileSystemRepository>(json, options))
            | "gcs" -> TypesRepository.Gcs (JsonSerializer.Deserialize<TypesGcsRepository>(json, options))
            | "s3" -> TypesRepository.S3 (JsonSerializer.Deserialize<TypesS3Repository>(json, options))
            | "source" -> TypesRepository.Source (JsonSerializer.Deserialize<TypesSourceOnlyRepository>(json, options))
            | "url" -> TypesRepository.Url (JsonSerializer.Deserialize<TypesReadOnlyUrlRepository>(json, options))
            | s -> failwith $"Unknown TypesRepository type: {s}"

    and [<JsonConverter(typeof<TypesRepositoryConverter>)>]
        TypesRepository =
        | Azure of TypesAzureRepository
        | Fs of TypesSharedFileSystemRepository
        | Gcs of TypesGcsRepository
        | S3 of TypesS3Repository
        | Source of TypesSourceOnlyRepository
        | Url of TypesReadOnlyUrlRepository

    and TypesRepositoryTypeConverter() =
        inherit JsonConverter<TypesRepositoryType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesRepositoryType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesRepositoryType.Azure -> "azure"
                | TypesRepositoryType.Fs -> "fs"
                | TypesRepositoryType.Gcs -> "gcs"
                | TypesRepositoryType.S3 -> "s3"
                | TypesRepositoryType.Source -> "source"
                | TypesRepositoryType.Url -> "url"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "azure" -> TypesRepositoryType.Azure
            | "fs" -> TypesRepositoryType.Fs
            | "gcs" -> TypesRepositoryType.Gcs
            | "s3" -> TypesRepositoryType.S3
            | "source" -> TypesRepositoryType.Source
            | "url" -> TypesRepositoryType.Url
            | s -> failwith $"Unknown TypesRepositoryType: {s}"

    and [<JsonConverter(typeof<TypesRepositoryTypeConverter>)>]
        TypesRepositoryType =
        | Azure
        | Fs
        | Gcs
        | S3
        | Source
        | Url
        with
        override this.ToString() =
            match this with
            | Azure -> "azure"
            | Fs -> "fs"
            | Gcs -> "gcs"
            | S3 -> "s3"
            | Source -> "source"
            | Url -> "url"

    and TypesSnapshotSortConverter() =
        inherit JsonConverter<TypesSnapshotSort>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSnapshotSort, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSnapshotSort.StartTime -> "start_time"
                | TypesSnapshotSort.Duration -> "duration"
                | TypesSnapshotSort.Name -> "name"
                | TypesSnapshotSort.IndexCount -> "index_count"
                | TypesSnapshotSort.Repository -> "repository"
                | TypesSnapshotSort.ShardCount -> "shard_count"
                | TypesSnapshotSort.FailedShardCount -> "failed_shard_count"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "start_time" -> TypesSnapshotSort.StartTime
            | "duration" -> TypesSnapshotSort.Duration
            | "name" -> TypesSnapshotSort.Name
            | "index_count" -> TypesSnapshotSort.IndexCount
            | "repository" -> TypesSnapshotSort.Repository
            | "shard_count" -> TypesSnapshotSort.ShardCount
            | "failed_shard_count" -> TypesSnapshotSort.FailedShardCount
            | s -> failwith $"Unknown TypesSnapshotSort: {s}"

    and [<JsonConverter(typeof<TypesSnapshotSortConverter>)>]
        TypesSnapshotSort =
        | StartTime
        | Duration
        | Name
        | IndexCount
        | Repository
        | ShardCount
        | FailedShardCount
        with
        override this.ToString() =
            match this with
            | StartTime -> "start_time"
            | Duration -> "duration"
            | Name -> "name"
            | IndexCount -> "index_count"
            | Repository -> "repository"
            | ShardCount -> "shard_count"
            | FailedShardCount -> "failed_shard_count"

    and TypesSnapshotStateConverter() =
        inherit JsonConverter<TypesSnapshotState>()

        override _.Write(writer: Utf8JsonWriter, value: TypesSnapshotState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesSnapshotState.INPROGRESS -> "IN_PROGRESS"
                | TypesSnapshotState.SUCCESS -> "SUCCESS"
                | TypesSnapshotState.FAILED -> "FAILED"
                | TypesSnapshotState.PARTIAL -> "PARTIAL"
                | TypesSnapshotState.INCOMPATIBLE -> "INCOMPATIBLE"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "IN_PROGRESS" -> TypesSnapshotState.INPROGRESS
            | "SUCCESS" -> TypesSnapshotState.SUCCESS
            | "FAILED" -> TypesSnapshotState.FAILED
            | "PARTIAL" -> TypesSnapshotState.PARTIAL
            | "INCOMPATIBLE" -> TypesSnapshotState.INCOMPATIBLE
            | s -> failwith $"Unknown TypesSnapshotState: {s}"

    and [<JsonConverter(typeof<TypesSnapshotStateConverter>)>]
        TypesSnapshotState =
        | INPROGRESS
        | SUCCESS
        | FAILED
        | PARTIAL
        | INCOMPATIBLE
        with
        override this.ToString() =
            match this with
            | INPROGRESS -> "IN_PROGRESS"
            | SUCCESS -> "SUCCESS"
            | FAILED -> "FAILED"
            | PARTIAL -> "PARTIAL"
            | INCOMPATIBLE -> "INCOMPATIBLE"

    and GetSnapshotResponseItem = {
        [<JsonPropertyName("repository")>]
        Repository: Name
        [<JsonPropertyName("snapshots")>]
        Snapshots: TypesSnapshotInfo array option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
    }

    and RepositoryAnalyzeSnapshotNodeInfo = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and RepositoryAnalyzeReadBlobDetails = {
        [<JsonPropertyName("before_write_complete")>]
        BeforeWriteComplete: bool option
        [<JsonPropertyName("elapsed")>]
        Elapsed: Duration option
        [<JsonPropertyName("elapsed_nanos")>]
        ElapsedNanos: DurationValueUnitNanos option
        [<JsonPropertyName("first_byte_time")>]
        FirstByteTime: Duration option
        [<JsonPropertyName("first_byte_time_nanos")>]
        FirstByteTimeNanos: DurationValueUnitNanos
        [<JsonPropertyName("found")>]
        Found: bool
        [<JsonPropertyName("node")>]
        Node: RepositoryAnalyzeSnapshotNodeInfo
        [<JsonPropertyName("throttled")>]
        Throttled: Duration option
        [<JsonPropertyName("throttled_nanos")>]
        ThrottledNanos: DurationValueUnitNanos option
    }

    and RepositoryAnalyzeBlobDetails = {
        [<JsonPropertyName("name")>]
        Name: string
        [<JsonPropertyName("overwritten")>]
        Overwritten: bool
        [<JsonPropertyName("read_early")>]
        ReadEarly: bool
        [<JsonPropertyName("read_end")>]
        ReadEnd: float
        [<JsonPropertyName("read_start")>]
        ReadStart: float
        [<JsonPropertyName("reads")>]
        Reads: RepositoryAnalyzeReadBlobDetails
        [<JsonPropertyName("size")>]
        Size: ByteSize
        [<JsonPropertyName("size_bytes")>]
        SizeBytes: float
    }

    and RepositoryAnalyzeDetailsInfo = {
        [<JsonPropertyName("blob")>]
        Blob: RepositoryAnalyzeBlobDetails
        [<JsonPropertyName("overwrite_elapsed")>]
        OverwriteElapsed: Duration option
        [<JsonPropertyName("overwrite_elapsed_nanos")>]
        OverwriteElapsedNanos: DurationValueUnitNanos option
        [<JsonPropertyName("write_elapsed")>]
        WriteElapsed: Duration
        [<JsonPropertyName("write_elapsed_nanos")>]
        WriteElapsedNanos: DurationValueUnitNanos
        [<JsonPropertyName("write_throttled")>]
        WriteThrottled: Duration
        [<JsonPropertyName("write_throttled_nanos")>]
        WriteThrottledNanos: DurationValueUnitNanos
        [<JsonPropertyName("writer_node")>]
        WriterNode: RepositoryAnalyzeSnapshotNodeInfo
    }

    and RepositoryAnalyzeReadSummaryInfo = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("max_wait")>]
        MaxWait: Duration
        [<JsonPropertyName("max_wait_nanos")>]
        MaxWaitNanos: DurationValueUnitNanos
        [<JsonPropertyName("total_elapsed")>]
        TotalElapsed: Duration
        [<JsonPropertyName("total_elapsed_nanos")>]
        TotalElapsedNanos: DurationValueUnitNanos
        [<JsonPropertyName("total_size")>]
        TotalSize: ByteSize
        [<JsonPropertyName("total_size_bytes")>]
        TotalSizeBytes: float
        [<JsonPropertyName("total_throttled")>]
        TotalThrottled: Duration
        [<JsonPropertyName("total_throttled_nanos")>]
        TotalThrottledNanos: DurationValueUnitNanos
        [<JsonPropertyName("total_wait")>]
        TotalWait: Duration
        [<JsonPropertyName("total_wait_nanos")>]
        TotalWaitNanos: DurationValueUnitNanos
    }

    and RepositoryAnalyzeWriteSummaryInfo = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("total_elapsed")>]
        TotalElapsed: Duration
        [<JsonPropertyName("total_elapsed_nanos")>]
        TotalElapsedNanos: DurationValueUnitNanos
        [<JsonPropertyName("total_size")>]
        TotalSize: ByteSize
        [<JsonPropertyName("total_size_bytes")>]
        TotalSizeBytes: float
        [<JsonPropertyName("total_throttled")>]
        TotalThrottled: Duration
        [<JsonPropertyName("total_throttled_nanos")>]
        TotalThrottledNanos: float
    }

    and RepositoryAnalyzeSummaryInfo = {
        [<JsonPropertyName("read")>]
        Read: RepositoryAnalyzeReadSummaryInfo
        [<JsonPropertyName("write")>]
        Write: RepositoryAnalyzeWriteSummaryInfo
    }

    and RestoreSnapshotRestore = {
        [<JsonPropertyName("indices")>]
        Indices: IndexName array
        [<JsonPropertyName("snapshot")>]
        Snapshot: string
        [<JsonPropertyName("shards")>]
        Shards: ShardStatistics
    }

    and TypesShardsStats = {
        [<JsonPropertyName("done")>]
        Done: float
        [<JsonPropertyName("failed")>]
        Failed: float
        [<JsonPropertyName("finalizing")>]
        Finalizing: float
        [<JsonPropertyName("initializing")>]
        Initializing: float
        [<JsonPropertyName("started")>]
        Started: float
        [<JsonPropertyName("total")>]
        Total: float
    }

    and TypesShardsStatsStageConverter() =
        inherit JsonConverter<TypesShardsStatsStage>()

        override _.Write(writer: Utf8JsonWriter, value: TypesShardsStatsStage, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesShardsStatsStage.DONE -> "DONE"
                | TypesShardsStatsStage.FAILURE -> "FAILURE"
                | TypesShardsStatsStage.FINALIZE -> "FINALIZE"
                | TypesShardsStatsStage.INIT -> "INIT"
                | TypesShardsStatsStage.STARTED -> "STARTED"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "DONE" -> TypesShardsStatsStage.DONE
            | "FAILURE" -> TypesShardsStatsStage.FAILURE
            | "FINALIZE" -> TypesShardsStatsStage.FINALIZE
            | "INIT" -> TypesShardsStatsStage.INIT
            | "STARTED" -> TypesShardsStatsStage.STARTED
            | s -> failwith $"Unknown TypesShardsStatsStage: {s}"

    and [<JsonConverter(typeof<TypesShardsStatsStageConverter>)>]
        TypesShardsStatsStage =
        | DONE
        | FAILURE
        | FINALIZE
        | INIT
        | STARTED
        with
        override this.ToString() =
            match this with
            | DONE -> "DONE"
            | FAILURE -> "FAILURE"
            | FINALIZE -> "FINALIZE"
            | INIT -> "INIT"
            | STARTED -> "STARTED"

    and TypesShardsStatsSummaryItem = {
        [<JsonPropertyName("file_count")>]
        FileCount: float
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
    }

    and TypesShardsStatsSummary = {
        [<JsonPropertyName("incremental")>]
        Incremental: TypesShardsStatsSummaryItem
        [<JsonPropertyName("total")>]
        Total: TypesShardsStatsSummaryItem
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
    }

    and TypesSnapshotShardsStatus = {
        [<JsonPropertyName("stage")>]
        Stage: TypesShardsStatsStage
        [<JsonPropertyName("stats")>]
        Stats: TypesShardsStatsSummary
    }

    and TypesFileCountSnapshotStats = {
        [<JsonPropertyName("file_count")>]
        FileCount: float
        [<JsonPropertyName("size_in_bytes")>]
        SizeInBytes: float
    }

    and TypesSnapshotStats = {
        [<JsonPropertyName("incremental")>]
        Incremental: TypesFileCountSnapshotStats
        [<JsonPropertyName("start_time_in_millis")>]
        StartTimeInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("time")>]
        Time: Duration option
        [<JsonPropertyName("time_in_millis")>]
        TimeInMillis: DurationValueUnitMillis
        [<JsonPropertyName("total")>]
        Total: TypesFileCountSnapshotStats
    }

    and TypesSnapshotIndexStats = {
        [<JsonPropertyName("shards")>]
        Shards: Map<string, TypesSnapshotShardsStatus>
        [<JsonPropertyName("shards_stats")>]
        ShardsStats: TypesShardsStats
        [<JsonPropertyName("stats")>]
        Stats: TypesSnapshotStats
    }

    and TypesStatus = {
        [<JsonPropertyName("include_global_state")>]
        IncludeGlobalState: bool
        [<JsonPropertyName("indices")>]
        Indices: Map<string, TypesSnapshotIndexStats>
        [<JsonPropertyName("repository")>]
        Repository: string
        [<JsonPropertyName("shards_stats")>]
        ShardsStats: TypesShardsStats
        [<JsonPropertyName("snapshot")>]
        Snapshot: string
        [<JsonPropertyName("state")>]
        State: string
        [<JsonPropertyName("stats")>]
        Stats: TypesSnapshotStats
        [<JsonPropertyName("uuid")>]
        Uuid: Uuid
    }

    and VerifyRepositoryCompactNodeInfo = {
        [<JsonPropertyName("name")>]
        Name: Name
    }

    and TypesColumn = {
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("type")>]
        Type: string
    }

    and TypesRow = obj array

    and QuerySqlFormatConverter() =
        inherit JsonConverter<QuerySqlFormat>()

        override _.Write(writer: Utf8JsonWriter, value: QuerySqlFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | QuerySqlFormat.Csv -> "csv"
                | QuerySqlFormat.Json -> "json"
                | QuerySqlFormat.Tsv -> "tsv"
                | QuerySqlFormat.Txt -> "txt"
                | QuerySqlFormat.Yaml -> "yaml"
                | QuerySqlFormat.Cbor -> "cbor"
                | QuerySqlFormat.Smile -> "smile"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "csv" -> QuerySqlFormat.Csv
            | "json" -> QuerySqlFormat.Json
            | "tsv" -> QuerySqlFormat.Tsv
            | "txt" -> QuerySqlFormat.Txt
            | "yaml" -> QuerySqlFormat.Yaml
            | "cbor" -> QuerySqlFormat.Cbor
            | "smile" -> QuerySqlFormat.Smile
            | s -> failwith $"Unknown QuerySqlFormat: {s}"

    and [<JsonConverter(typeof<QuerySqlFormatConverter>)>]
        QuerySqlFormat =
        | Csv
        | Json
        | Tsv
        | Txt
        | Yaml
        | Cbor
        | Smile
        with
        override this.ToString() =
            match this with
            | Csv -> "csv"
            | Json -> "json"
            | Tsv -> "tsv"
            | Txt -> "txt"
            | Yaml -> "yaml"
            | Cbor -> "cbor"
            | Smile -> "smile"

    and CertificatesCertificateInformation = {
        [<JsonPropertyName("alias")>]
        Alias: System.Text.Json.JsonElement
        [<JsonPropertyName("expiry")>]
        Expiry: DateTime
        [<JsonPropertyName("format")>]
        Format: string
        [<JsonPropertyName("has_private_key")>]
        HasPrivateKey: bool
        [<JsonPropertyName("issuer")>]
        Issuer: string option
        [<JsonPropertyName("path")>]
        Path: string
        [<JsonPropertyName("serial_number")>]
        SerialNumber: string
        [<JsonPropertyName("subject_dn")>]
        SubjectDn: string
    }

    and TypesSynonymsUpdateResult = {
        [<JsonPropertyName("result")>]
        Result: Result
        [<JsonPropertyName("reload_analyzers_details")>]
        ReloadAnalyzersDetails: ReloadSearchAnalyzersReloadResult option
    }

    and TypesSynonymString = string

    and TypesSynonymRuleRead = {
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("synonyms")>]
        Synonyms: TypesSynonymString
    }

    and GetSynonymsSetsSynonymsSetItem = {
        [<JsonPropertyName("synonyms_set")>]
        SynonymsSet: Id
        [<JsonPropertyName("count")>]
        Count: float
    }

    and TypesSynonymRule = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("synonyms")>]
        Synonyms: TypesSynonymString
    }

    and TypesGroupByConverter() =
        inherit JsonConverter<TypesGroupBy>()

        override _.Write(writer: Utf8JsonWriter, value: TypesGroupBy, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesGroupBy.Nodes -> "nodes"
                | TypesGroupBy.Parents -> "parents"
                | TypesGroupBy.None -> "none"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "nodes" -> TypesGroupBy.Nodes
            | "parents" -> TypesGroupBy.Parents
            | "none" -> TypesGroupBy.None
            | s -> failwith $"Unknown TypesGroupBy: {s}"

    and [<JsonConverter(typeof<TypesGroupByConverter>)>]
        TypesGroupBy =
        | Nodes
        | Parents
        | None
        with
        override this.ToString() =
            match this with
            | Nodes -> "nodes"
            | Parents -> "parents"
            | None -> "none"

    and TypesEcsCompatibilityTypeConverter() =
        inherit JsonConverter<TypesEcsCompatibilityType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesEcsCompatibilityType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesEcsCompatibilityType.Disabled -> "disabled"
                | TypesEcsCompatibilityType.V1 -> "v1"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "disabled" -> TypesEcsCompatibilityType.Disabled
            | "v1" -> TypesEcsCompatibilityType.V1
            | s -> failwith $"Unknown TypesEcsCompatibilityType: {s}"

    and [<JsonConverter(typeof<TypesEcsCompatibilityTypeConverter>)>]
        TypesEcsCompatibilityType =
        | Disabled
        | V1
        with
        override this.ToString() =
            match this with
            | Disabled -> "disabled"
            | V1 -> "v1"

    and TypesFormatTypeConverter() =
        inherit JsonConverter<TypesFormatType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesFormatType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesFormatType.Delimited -> "delimited"
                | TypesFormatType.Ndjson -> "ndjson"
                | TypesFormatType.SemiStructuredText -> "semi_structured_text"
                | TypesFormatType.Xml -> "xml"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "delimited" -> TypesFormatType.Delimited
            | "ndjson" -> TypesFormatType.Ndjson
            | "semi_structured_text" -> TypesFormatType.SemiStructuredText
            | "xml" -> TypesFormatType.Xml
            | s -> failwith $"Unknown TypesFormatType: {s}"

    and [<JsonConverter(typeof<TypesFormatTypeConverter>)>]
        TypesFormatType =
        | Delimited
        | Ndjson
        | SemiStructuredText
        | Xml
        with
        override this.ToString() =
            match this with
            | Delimited -> "delimited"
            | Ndjson -> "ndjson"
            | SemiStructuredText -> "semi_structured_text"
            | Xml -> "xml"

    and TypesTopHit = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("value")>]
        Value: obj
    }

    and TypesFieldStat = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("cardinality")>]
        Cardinality: float
        [<JsonPropertyName("top_hits")>]
        TopHits: TypesTopHit array
        [<JsonPropertyName("mean_value")>]
        MeanValue: float option
        [<JsonPropertyName("median_value")>]
        MedianValue: float option
        [<JsonPropertyName("max_value")>]
        MaxValue: float option
        [<JsonPropertyName("min_value")>]
        MinValue: float option
        [<JsonPropertyName("earliest")>]
        Earliest: string option
        [<JsonPropertyName("latest")>]
        Latest: string option
    }

    and TypesPipelineConfig = {
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("version")>]
        Version: VersionNumber option
        [<JsonPropertyName("processors")>]
        Processors: TypesProcessorContainer array
    }

    and FindStructureFindStructureFormatConverter() =
        inherit JsonConverter<FindStructureFindStructureFormat>()

        override _.Write(writer: Utf8JsonWriter, value: FindStructureFindStructureFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | FindStructureFindStructureFormat.Ndjson -> "ndjson"
                | FindStructureFindStructureFormat.Xml -> "xml"
                | FindStructureFindStructureFormat.Delimited -> "delimited"
                | FindStructureFindStructureFormat.SemiStructuredText -> "semi_structured_text"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "ndjson" -> FindStructureFindStructureFormat.Ndjson
            | "xml" -> FindStructureFindStructureFormat.Xml
            | "delimited" -> FindStructureFindStructureFormat.Delimited
            | "semi_structured_text" -> FindStructureFindStructureFormat.SemiStructuredText
            | s -> failwith $"Unknown FindStructureFindStructureFormat: {s}"

    and [<JsonConverter(typeof<FindStructureFindStructureFormatConverter>)>]
        FindStructureFindStructureFormat =
        | Ndjson
        | Xml
        | Delimited
        | SemiStructuredText
        with
        override this.ToString() =
            match this with
            | Ndjson -> "ndjson"
            | Xml -> "xml"
            | Delimited -> "delimited"
            | SemiStructuredText -> "semi_structured_text"

    and TestGrokPatternMatchedField = {
        [<JsonPropertyName("match")>]
        Match: string
        [<JsonPropertyName("offset")>]
        Offset: float
        [<JsonPropertyName("length")>]
        Length: float
    }

    and TestGrokPatternMatchedText = {
        [<JsonPropertyName("matched")>]
        Matched: bool
        [<JsonPropertyName("fields")>]
        Fields: Map<string, TestGrokPatternMatchedField array> option
    }

    and GetNodeStatsTransformSchedulerStats = {
        [<JsonPropertyName("registered_transform_count")>]
        RegisteredTransformCount: float
        [<JsonPropertyName("peek_transform")>]
        PeekTransform: string option
    }

    and GetNodeStatsTransformNodeStats = {
        [<JsonPropertyName("scheduler")>]
        Scheduler: GetNodeStatsTransformSchedulerStats
    }

    and GetNodeStatsTransformNodeFullStats = {
        [<JsonPropertyName("total")>]
        Total: GetNodeStatsTransformNodeStats
    }

    and TypesTransformAuthorization = {
        [<JsonPropertyName("api_key")>]
        ApiKey: TypesApiKeyAuthorization option
        [<JsonPropertyName("roles")>]
        Roles: string array option
        [<JsonPropertyName("service_account")>]
        ServiceAccount: string option
    }

    and TypesLatest = {
        [<JsonPropertyName("sort")>]
        Sort: Field
        [<JsonPropertyName("unique_key")>]
        UniqueKey: Field array
    }

    and TypesPivotGroupByContainer = {
        [<JsonPropertyName("date_histogram")>]
        DateHistogram: AggregationsDateHistogramAggregation option
        [<JsonPropertyName("geotile_grid")>]
        GeotileGrid: AggregationsGeoTileGridAggregation option
        [<JsonPropertyName("histogram")>]
        Histogram: AggregationsHistogramAggregation option
        [<JsonPropertyName("terms")>]
        Terms: AggregationsTermsAggregation option
    }

    and TypesPivot = {
        [<JsonPropertyName("aggregations")>]
        Aggregations: Map<string, AggregationsAggregationContainer> option
        [<JsonPropertyName("group_by")>]
        GroupBy: Map<string, TypesPivotGroupByContainer> option
    }

    and TypesRetentionPolicy = {
        [<JsonPropertyName("field")>]
        Field: Field
        [<JsonPropertyName("max_age")>]
        MaxAge: Duration
    }

    and TypesRetentionPolicyContainer = {
        [<JsonPropertyName("time")>]
        Time: TypesRetentionPolicy option
    }

    /// <summary>
    /// The source of the data for the transform.
    /// </summary>
    and TypesSettings = {
        [<JsonPropertyName("align_checkpoints")>]
        AlignCheckpoints: bool option
        [<JsonPropertyName("dates_as_epoch_millis")>]
        DatesAsEpochMillis: bool option
        [<JsonPropertyName("deduce_mappings")>]
        DeduceMappings: bool option
        [<JsonPropertyName("docs_per_second")>]
        DocsPerSecond: float option
        [<JsonPropertyName("max_page_search_size")>]
        MaxPageSearchSize: float option
        [<JsonPropertyName("use_point_in_time")>]
        UsePointInTime: bool option
        [<JsonPropertyName("unattended")>]
        Unattended: bool option
    }

    and TypesSource = {
        [<JsonPropertyName("index")>]
        Index: Indices
        [<JsonPropertyName("runtime_mappings")>]
        RuntimeMappings: MappingRuntimeFields option
        [<JsonPropertyName("query")>]
        Query: obj option
    }

    and TypesTimeSync = {
        [<JsonPropertyName("delay")>]
        Delay: Duration option
        [<JsonPropertyName("field")>]
        Field: Field
    }

    and TypesSyncContainer = {
        [<JsonPropertyName("time")>]
        Time: TypesTimeSync option
    }

    and GetTransformTransformSummary = {
        [<JsonPropertyName("authorization")>]
        Authorization: TypesTransformAuthorization option
        [<JsonPropertyName("create_time")>]
        CreateTime: EpochTimeUnitMillis option
        [<JsonPropertyName("create_time_string")>]
        CreateTimeString: DateTime option
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("dest")>]
        Dest: ReindexDestination
        [<JsonPropertyName("frequency")>]
        Frequency: Duration option
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("latest")>]
        Latest: TypesLatest option
        [<JsonPropertyName("pivot")>]
        Pivot: TypesPivot option
        [<JsonPropertyName("retention_policy")>]
        RetentionPolicy: TypesRetentionPolicyContainer option
        [<JsonPropertyName("settings")>]
        Settings: TypesSettings option
        [<JsonPropertyName("source")>]
        Source: TypesSource
        [<JsonPropertyName("sync")>]
        Sync: TypesSyncContainer option
        [<JsonPropertyName("version")>]
        Version: VersionString option
        [<JsonPropertyName("_meta")>]
        Meta: Metadata option
    }

    and GetTransformStatsTransformProgress = {
        [<JsonPropertyName("docs_indexed")>]
        DocsIndexed: float
        [<JsonPropertyName("docs_processed")>]
        DocsProcessed: float
        [<JsonPropertyName("docs_remaining")>]
        DocsRemaining: float option
        [<JsonPropertyName("percent_complete")>]
        PercentComplete: float option
        [<JsonPropertyName("total_docs")>]
        TotalDocs: float option
    }

    and GetTransformStatsCheckpointStats = {
        [<JsonPropertyName("checkpoint")>]
        Checkpoint: float
        [<JsonPropertyName("checkpoint_progress")>]
        CheckpointProgress: GetTransformStatsTransformProgress option
        [<JsonPropertyName("timestamp")>]
        Timestamp: DateTime option
        [<JsonPropertyName("timestamp_millis")>]
        TimestampMillis: EpochTimeUnitMillis option
        [<JsonPropertyName("time_upper_bound")>]
        TimeUpperBound: DateTime option
        [<JsonPropertyName("time_upper_bound_millis")>]
        TimeUpperBoundMillis: EpochTimeUnitMillis option
    }

    and GetTransformStatsCheckpointing = {
        [<JsonPropertyName("changes_last_detected_at")>]
        ChangesLastDetectedAt: float option
        [<JsonPropertyName("changes_last_detected_at_string")>]
        ChangesLastDetectedAtString: DateTime option
        [<JsonPropertyName("last")>]
        Last: GetTransformStatsCheckpointStats
        [<JsonPropertyName("next")>]
        Next: GetTransformStatsCheckpointStats option
        [<JsonPropertyName("operations_behind")>]
        OperationsBehind: float option
        [<JsonPropertyName("last_search_time")>]
        LastSearchTime: float option
        [<JsonPropertyName("last_search_time_string")>]
        LastSearchTimeString: DateTime option
    }

    and GetTransformStatsTransformIndexerStats = {
        [<JsonPropertyName("delete_time_in_ms")>]
        DeleteTimeInMs: EpochTimeUnitMillis option
        [<JsonPropertyName("documents_indexed")>]
        DocumentsIndexed: float
        [<JsonPropertyName("documents_deleted")>]
        DocumentsDeleted: float option
        [<JsonPropertyName("documents_processed")>]
        DocumentsProcessed: float
        [<JsonPropertyName("exponential_avg_checkpoint_duration_ms")>]
        ExponentialAvgCheckpointDurationMs: DurationValueUnitFloatMillis
        [<JsonPropertyName("exponential_avg_documents_indexed")>]
        ExponentialAvgDocumentsIndexed: float
        [<JsonPropertyName("exponential_avg_documents_processed")>]
        ExponentialAvgDocumentsProcessed: float
        [<JsonPropertyName("index_failures")>]
        IndexFailures: float
        [<JsonPropertyName("index_time_in_ms")>]
        IndexTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("index_total")>]
        IndexTotal: float
        [<JsonPropertyName("pages_processed")>]
        PagesProcessed: float
        [<JsonPropertyName("processing_time_in_ms")>]
        ProcessingTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("processing_total")>]
        ProcessingTotal: float
        [<JsonPropertyName("search_failures")>]
        SearchFailures: float
        [<JsonPropertyName("search_time_in_ms")>]
        SearchTimeInMs: DurationValueUnitMillis
        [<JsonPropertyName("search_total")>]
        SearchTotal: float
        [<JsonPropertyName("trigger_count")>]
        TriggerCount: float
    }

    and GetTransformStatsTransformHealthIssue = {
        [<JsonPropertyName("type")>]
        Type: string
        [<JsonPropertyName("issue")>]
        Issue: string
        [<JsonPropertyName("details")>]
        Details: string option
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("first_occurrence")>]
        FirstOccurrence: EpochTimeUnitMillis option
        [<JsonPropertyName("first_occurence_string")>]
        FirstOccurenceString: DateTime option
    }

    and GetTransformStatsTransformStatsHealth = {
        [<JsonPropertyName("status")>]
        Status: HealthStatus
        [<JsonPropertyName("issues")>]
        Issues: GetTransformStatsTransformHealthIssue array option
    }

    and GetTransformStatsTransformStats = {
        [<JsonPropertyName("checkpointing")>]
        Checkpointing: GetTransformStatsCheckpointing
        [<JsonPropertyName("health")>]
        Health: GetTransformStatsTransformStatsHealth option
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("node")>]
        Node: NodeAttributes option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("state")>]
        State: string
        [<JsonPropertyName("stats")>]
        Stats: GetTransformStatsTransformIndexerStats
    }

    and TypesDestination = {
        [<JsonPropertyName("index")>]
        Index: IndexName option
        [<JsonPropertyName("pipeline")>]
        Pipeline: string option
    }

    and UpdateUpdateWriteResponseBase = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("_index")>]
        Index: IndexName
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("result")>]
        Result: Result
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
        [<JsonPropertyName("_shards")>]
        Shards: ShardStatistics
        [<JsonPropertyName("_version")>]
        Version: VersionNumber
        [<JsonPropertyName("failure_store")>]
        FailureStore: BulkFailureStoreStatus option
        [<JsonPropertyName("forced_refresh")>]
        ForcedRefresh: bool option
        [<JsonPropertyName("get")>]
        Get: InlineGet option
    }

    and UpdateByQueryRethrottleUpdateByQueryRethrottleNode = {
        [<JsonPropertyName("attributes")>]
        Attributes: Map<string, string>
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("ip")>]
        Ip: Ip
        [<JsonPropertyName("name")>]
        Name: Name
        [<JsonPropertyName("roles")>]
        Roles: NodeRoles option
        [<JsonPropertyName("transport_address")>]
        TransportAddress: TransportAddress
        [<JsonPropertyName("tasks")>]
        Tasks: Map<string, TypesTaskInfo>
    }

    and TypesActivationState = {
        [<JsonPropertyName("active")>]
        Active: bool
        [<JsonPropertyName("timestamp")>]
        Timestamp: DateTime
    }

    and TypesWatchStatus = {
        [<JsonPropertyName("actions")>]
        Actions: System.Text.Json.JsonElement
        [<JsonPropertyName("last_checked")>]
        LastChecked: DateTime option
        [<JsonPropertyName("last_met_condition")>]
        LastMetCondition: DateTime option
        [<JsonPropertyName("state")>]
        State: TypesActivationState
        [<JsonPropertyName("version")>]
        Version: VersionNumber
        [<JsonPropertyName("execution_state")>]
        ExecutionState: string option
    }

    and TypesAcknowledgementOptionsConverter() =
        inherit JsonConverter<TypesAcknowledgementOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesAcknowledgementOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesAcknowledgementOptions.AwaitsSuccessfulExecution -> "awaits_successful_execution"
                | TypesAcknowledgementOptions.Ackable -> "ackable"
                | TypesAcknowledgementOptions.Acked -> "acked"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "awaits_successful_execution" -> TypesAcknowledgementOptions.AwaitsSuccessfulExecution
            | "ackable" -> TypesAcknowledgementOptions.Ackable
            | "acked" -> TypesAcknowledgementOptions.Acked
            | s -> failwith $"Unknown TypesAcknowledgementOptions: {s}"

    and [<JsonConverter(typeof<TypesAcknowledgementOptionsConverter>)>]
        TypesAcknowledgementOptions =
        | AwaitsSuccessfulExecution
        | Ackable
        | Acked
        with
        override this.ToString() =
            match this with
            | AwaitsSuccessfulExecution -> "awaits_successful_execution"
            | Ackable -> "ackable"
            | Acked -> "acked"

    and TypesAcknowledgeState = {
        [<JsonPropertyName("state")>]
        State: TypesAcknowledgementOptions
        [<JsonPropertyName("timestamp")>]
        Timestamp: DateTime
    }

    and TypesExecutionState = {
        [<JsonPropertyName("successful")>]
        Successful: bool
        [<JsonPropertyName("timestamp")>]
        Timestamp: DateTime
        [<JsonPropertyName("reason")>]
        Reason: string option
    }

    and TypesThrottleState = {
        [<JsonPropertyName("reason")>]
        Reason: string
        [<JsonPropertyName("timestamp")>]
        Timestamp: DateTime
    }

    and TypesActionStatus = {
        [<JsonPropertyName("ack")>]
        Ack: TypesAcknowledgeState
        [<JsonPropertyName("last_execution")>]
        LastExecution: TypesExecutionState option
        [<JsonPropertyName("last_successful_execution")>]
        LastSuccessfulExecution: TypesExecutionState option
        [<JsonPropertyName("last_throttle")>]
        LastThrottle: TypesThrottleState option
    }

    and TypesActivationStatus = {
        [<JsonPropertyName("actions")>]
        Actions: System.Text.Json.JsonElement
        [<JsonPropertyName("state")>]
        State: TypesActivationState
        [<JsonPropertyName("version")>]
        Version: VersionNumber
    }

    and TypesActionExecutionModeConverter() =
        inherit JsonConverter<TypesActionExecutionMode>()

        override _.Write(writer: Utf8JsonWriter, value: TypesActionExecutionMode, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesActionExecutionMode.Simulate -> "simulate"
                | TypesActionExecutionMode.ForceSimulate -> "force_simulate"
                | TypesActionExecutionMode.Execute -> "execute"
                | TypesActionExecutionMode.ForceExecute -> "force_execute"
                | TypesActionExecutionMode.Skip -> "skip"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "simulate" -> TypesActionExecutionMode.Simulate
            | "force_simulate" -> TypesActionExecutionMode.ForceSimulate
            | "execute" -> TypesActionExecutionMode.Execute
            | "force_execute" -> TypesActionExecutionMode.ForceExecute
            | "skip" -> TypesActionExecutionMode.Skip
            | s -> failwith $"Unknown TypesActionExecutionMode: {s}"

    and [<JsonConverter(typeof<TypesActionExecutionModeConverter>)>]
        TypesActionExecutionMode =
        | Simulate
        | ForceSimulate
        | Execute
        | ForceExecute
        | Skip
        with
        override this.ToString() =
            match this with
            | Simulate -> "simulate"
            | ForceSimulate -> "force_simulate"
            | Execute -> "execute"
            | ForceExecute -> "force_execute"
            | Skip -> "skip"

    and TypesSimulatedActions = {
        [<JsonPropertyName("actions")>]
        Actions: string array
        [<JsonPropertyName("all")>]
        All: TypesSimulatedActions
        [<JsonPropertyName("use_all")>]
        UseAll: bool
    }

    and TypesScheduleTriggerEvent = {
        [<JsonPropertyName("scheduled_time")>]
        ScheduledTime: DateTime
        [<JsonPropertyName("triggered_time")>]
        TriggeredTime: DateTime option
    }

    and ScriptTransform = {
        [<JsonPropertyName("lang")>]
        Lang: string option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("source")>]
        Source: ScriptSource option
        [<JsonPropertyName("id")>]
        Id: string option
    }

    and TypesSearchInputRequestBody = {
        [<JsonPropertyName("query")>]
        Query: QueryDslQueryContainer
    }

    and TypesSearchTemplateRequestBody = {
        [<JsonPropertyName("explain")>]
        Explain: bool option
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("profile")>]
        Profile: bool option
        [<JsonPropertyName("source")>]
        Source: string option
    }

    and TypesSearchInputRequestDefinition = {
        [<JsonPropertyName("body")>]
        Body: TypesSearchInputRequestBody option
        [<JsonPropertyName("indices")>]
        Indices: IndexName array option
        [<JsonPropertyName("indices_options")>]
        IndicesOptions: IndicesOptions option
        [<JsonPropertyName("search_type")>]
        SearchType: SearchType option
        [<JsonPropertyName("template")>]
        Template: TypesSearchTemplateRequestBody option
        [<JsonPropertyName("rest_total_hits_as_int")>]
        RestTotalHitsAsInt: bool option
    }

    and SearchTransform = {
        [<JsonPropertyName("request")>]
        Request: TypesSearchInputRequestDefinition
        [<JsonPropertyName("timeout")>]
        Timeout: Duration
    }

    and TransformContainer = {
        [<JsonPropertyName("chain")>]
        Chain: TransformContainer array option
        [<JsonPropertyName("script")>]
        Script: ScriptTransform option
        [<JsonPropertyName("search")>]
        Search: SearchTransform option
    }

    and TypesActionTypeConverter() =
        inherit JsonConverter<TypesActionType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesActionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesActionType.Email -> "email"
                | TypesActionType.Webhook -> "webhook"
                | TypesActionType.Index -> "index"
                | TypesActionType.Logging -> "logging"
                | TypesActionType.Slack -> "slack"
                | TypesActionType.Pagerduty -> "pagerduty"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "email" -> TypesActionType.Email
            | "webhook" -> TypesActionType.Webhook
            | "index" -> TypesActionType.Index
            | "logging" -> TypesActionType.Logging
            | "slack" -> TypesActionType.Slack
            | "pagerduty" -> TypesActionType.Pagerduty
            | s -> failwith $"Unknown TypesActionType: {s}"

    and [<JsonConverter(typeof<TypesActionTypeConverter>)>]
        TypesActionType =
        | Email
        | Webhook
        | Index
        | Logging
        | Slack
        | Pagerduty
        with
        override this.ToString() =
            match this with
            | Email -> "email"
            | Webhook -> "webhook"
            | Index -> "index"
            | Logging -> "logging"
            | Slack -> "slack"
            | Pagerduty -> "pagerduty"

    and TypesAlwaysCondition = obj

    and TypesArrayCompareCondition = {
        [<JsonPropertyName("path")>]
        Path: string
    }

    and TypesNeverCondition = obj

    and TypesScriptCondition = {
        [<JsonPropertyName("lang")>]
        Lang: ScriptLanguage option
        [<JsonPropertyName("params")>]
        Params: Map<string, obj> option
        [<JsonPropertyName("source")>]
        Source: ScriptSource option
        [<JsonPropertyName("id")>]
        Id: string option
    }

    and TypesConditionContainer = {
        [<JsonPropertyName("always")>]
        Always: TypesAlwaysCondition option
        [<JsonPropertyName("array_compare")>]
        ArrayCompare: Map<string, TypesArrayCompareCondition> option
        [<JsonPropertyName("compare")>]
        Compare: Map<string, Map<string, FieldValue>> option
        [<JsonPropertyName("never")>]
        Never: TypesNeverCondition option
        [<JsonPropertyName("script")>]
        Script: TypesScriptCondition option
    }

    and TypesDataAttachmentFormatConverter() =
        inherit JsonConverter<TypesDataAttachmentFormat>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDataAttachmentFormat, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDataAttachmentFormat.Json -> "json"
                | TypesDataAttachmentFormat.Yaml -> "yaml"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "json" -> TypesDataAttachmentFormat.Json
            | "yaml" -> TypesDataAttachmentFormat.Yaml
            | s -> failwith $"Unknown TypesDataAttachmentFormat: {s}"

    and [<JsonConverter(typeof<TypesDataAttachmentFormatConverter>)>]
        TypesDataAttachmentFormat =
        | Json
        | Yaml
        with
        override this.ToString() =
            match this with
            | Json -> "json"
            | Yaml -> "yaml"

    and TypesDataEmailAttachment = {
        [<JsonPropertyName("format")>]
        Format: TypesDataAttachmentFormat option
    }

    and TypesConnectionSchemeConverter() =
        inherit JsonConverter<TypesConnectionScheme>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConnectionScheme, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConnectionScheme.Http -> "http"
                | TypesConnectionScheme.Https -> "https"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "http" -> TypesConnectionScheme.Http
            | "https" -> TypesConnectionScheme.Https
            | s -> failwith $"Unknown TypesConnectionScheme: {s}"

    and [<JsonConverter(typeof<TypesConnectionSchemeConverter>)>]
        TypesConnectionScheme =
        | Http
        | Https
        with
        override this.ToString() =
            match this with
            | Http -> "http"
            | Https -> "https"

    and TypesHttpInputBasicAuthentication = {
        [<JsonPropertyName("password")>]
        Password: Password
        [<JsonPropertyName("username")>]
        Username: Username
    }

    and TypesHttpInputAuthentication = {
        [<JsonPropertyName("basic")>]
        Basic: TypesHttpInputBasicAuthentication
    }

    and TypesHttpInputMethodConverter() =
        inherit JsonConverter<TypesHttpInputMethod>()

        override _.Write(writer: Utf8JsonWriter, value: TypesHttpInputMethod, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesHttpInputMethod.Head -> "head"
                | TypesHttpInputMethod.Get -> "get"
                | TypesHttpInputMethod.Post -> "post"
                | TypesHttpInputMethod.Put -> "put"
                | TypesHttpInputMethod.Delete -> "delete"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "head" -> TypesHttpInputMethod.Head
            | "get" -> TypesHttpInputMethod.Get
            | "post" -> TypesHttpInputMethod.Post
            | "put" -> TypesHttpInputMethod.Put
            | "delete" -> TypesHttpInputMethod.Delete
            | s -> failwith $"Unknown TypesHttpInputMethod: {s}"

    and [<JsonConverter(typeof<TypesHttpInputMethodConverter>)>]
        TypesHttpInputMethod =
        | Head
        | Get
        | Post
        | Put
        | Delete
        with
        override this.ToString() =
            match this with
            | Head -> "head"
            | Get -> "get"
            | Post -> "post"
            | Put -> "put"
            | Delete -> "delete"

    and TypesHttpInputProxy = {
        [<JsonPropertyName("host")>]
        Host: Host
        [<JsonPropertyName("port")>]
        Port: Uint
    }

    and TypesHttpInputRequestDefinition = {
        [<JsonPropertyName("auth")>]
        Auth: TypesHttpInputAuthentication option
        [<JsonPropertyName("body")>]
        Body: string option
        [<JsonPropertyName("connection_timeout")>]
        ConnectionTimeout: Duration option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string> option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("method")>]
        Method: TypesHttpInputMethod option
        [<JsonPropertyName("params")>]
        Params: Map<string, string> option
        [<JsonPropertyName("path")>]
        Path: string option
        [<JsonPropertyName("port")>]
        Port: Uint option
        [<JsonPropertyName("proxy")>]
        Proxy: TypesHttpInputProxy option
        [<JsonPropertyName("read_timeout")>]
        ReadTimeout: Duration option
        [<JsonPropertyName("scheme")>]
        Scheme: TypesConnectionScheme option
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesHttpEmailAttachment = {
        [<JsonPropertyName("content_type")>]
        ContentType: string option
        [<JsonPropertyName("inline")>]
        Inline: bool option
        [<JsonPropertyName("request")>]
        Request: TypesHttpInputRequestDefinition option
    }

    and TypesReportingEmailAttachment = {
        [<JsonPropertyName("url")>]
        Url: string
        [<JsonPropertyName("inline")>]
        Inline: bool option
        [<JsonPropertyName("retries")>]
        Retries: float option
        [<JsonPropertyName("interval")>]
        Interval: Duration option
        [<JsonPropertyName("request")>]
        Request: TypesHttpInputRequestDefinition option
    }

    and TypesEmailAttachmentContainer = {
        [<JsonPropertyName("http")>]
        Http: TypesHttpEmailAttachment option
        [<JsonPropertyName("reporting")>]
        Reporting: TypesReportingEmailAttachment option
        [<JsonPropertyName("data")>]
        Data: TypesDataEmailAttachment option
    }

    and TypesEmailBody = {
        [<JsonPropertyName("html")>]
        Html: string option
        [<JsonPropertyName("text")>]
        Text: string option
    }

    and TypesEmailPriorityConverter() =
        inherit JsonConverter<TypesEmailPriority>()

        override _.Write(writer: Utf8JsonWriter, value: TypesEmailPriority, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesEmailPriority.Lowest -> "lowest"
                | TypesEmailPriority.Low -> "low"
                | TypesEmailPriority.Normal -> "normal"
                | TypesEmailPriority.High -> "high"
                | TypesEmailPriority.Highest -> "highest"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "lowest" -> TypesEmailPriority.Lowest
            | "low" -> TypesEmailPriority.Low
            | "normal" -> TypesEmailPriority.Normal
            | "high" -> TypesEmailPriority.High
            | "highest" -> TypesEmailPriority.Highest
            | s -> failwith $"Unknown TypesEmailPriority: {s}"

    and [<JsonConverter(typeof<TypesEmailPriorityConverter>)>]
        TypesEmailPriority =
        | Lowest
        | Low
        | Normal
        | High
        | Highest
        with
        override this.ToString() =
            match this with
            | Lowest -> "lowest"
            | Low -> "low"
            | Normal -> "normal"
            | High -> "high"
            | Highest -> "highest"

    and TypesEmail = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("bcc")>]
        Bcc: System.Text.Json.JsonElement option
        [<JsonPropertyName("body")>]
        Body: TypesEmailBody option
        [<JsonPropertyName("cc")>]
        Cc: System.Text.Json.JsonElement option
        [<JsonPropertyName("from")>]
        From: string option
        [<JsonPropertyName("priority")>]
        Priority: TypesEmailPriority option
        [<JsonPropertyName("reply_to")>]
        ReplyTo: System.Text.Json.JsonElement option
        [<JsonPropertyName("sent_date")>]
        SentDate: DateTime option
        [<JsonPropertyName("subject")>]
        Subject: string
        [<JsonPropertyName("to")>]
        To: System.Text.Json.JsonElement
        [<JsonPropertyName("attachments")>]
        Attachments: Map<string, TypesEmailAttachmentContainer> option
    }

    and TypesEmailAction = {
        [<JsonPropertyName("id")>]
        Id: Id option
        [<JsonPropertyName("bcc")>]
        Bcc: System.Text.Json.JsonElement option
        [<JsonPropertyName("body")>]
        Body: TypesEmailBody option
        [<JsonPropertyName("cc")>]
        Cc: System.Text.Json.JsonElement option
        [<JsonPropertyName("from")>]
        From: string option
        [<JsonPropertyName("priority")>]
        Priority: TypesEmailPriority option
        [<JsonPropertyName("reply_to")>]
        ReplyTo: System.Text.Json.JsonElement option
        [<JsonPropertyName("sent_date")>]
        SentDate: DateTime option
        [<JsonPropertyName("subject")>]
        Subject: string
        [<JsonPropertyName("to")>]
        To: System.Text.Json.JsonElement
        [<JsonPropertyName("attachments")>]
        Attachments: Map<string, TypesEmailAttachmentContainer> option
    }

    and TypesIndexAction = {
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("doc_id")>]
        DocId: Id option
        [<JsonPropertyName("refresh")>]
        Refresh: Refresh option
        [<JsonPropertyName("op_type")>]
        OpType: OpType option
        [<JsonPropertyName("timeout")>]
        Timeout: Duration option
        [<JsonPropertyName("execution_time_field")>]
        ExecutionTimeField: Field option
    }

    and TypesLoggingAction = {
        [<JsonPropertyName("level")>]
        Level: string option
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("category")>]
        Category: string option
    }

    and TypesPagerDutyContextTypeConverter() =
        inherit JsonConverter<TypesPagerDutyContextType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesPagerDutyContextType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesPagerDutyContextType.Link -> "link"
                | TypesPagerDutyContextType.Image -> "image"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "link" -> TypesPagerDutyContextType.Link
            | "image" -> TypesPagerDutyContextType.Image
            | s -> failwith $"Unknown TypesPagerDutyContextType: {s}"

    and [<JsonConverter(typeof<TypesPagerDutyContextTypeConverter>)>]
        TypesPagerDutyContextType =
        | Link
        | Image
        with
        override this.ToString() =
            match this with
            | Link -> "link"
            | Image -> "image"

    and TypesPagerDutyContext = {
        [<JsonPropertyName("href")>]
        Href: string option
        [<JsonPropertyName("src")>]
        Src: string option
        [<JsonPropertyName("type")>]
        Type: TypesPagerDutyContextType
    }

    and TypesPagerDutyEventProxy = {
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("port")>]
        Port: float option
    }

    and TypesPagerDutyEventTypeConverter() =
        inherit JsonConverter<TypesPagerDutyEventType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesPagerDutyEventType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesPagerDutyEventType.Trigger -> "trigger"
                | TypesPagerDutyEventType.Resolve -> "resolve"
                | TypesPagerDutyEventType.Acknowledge -> "acknowledge"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "trigger" -> TypesPagerDutyEventType.Trigger
            | "resolve" -> TypesPagerDutyEventType.Resolve
            | "acknowledge" -> TypesPagerDutyEventType.Acknowledge
            | s -> failwith $"Unknown TypesPagerDutyEventType: {s}"

    and [<JsonConverter(typeof<TypesPagerDutyEventTypeConverter>)>]
        TypesPagerDutyEventType =
        | Trigger
        | Resolve
        | Acknowledge
        with
        override this.ToString() =
            match this with
            | Trigger -> "trigger"
            | Resolve -> "resolve"
            | Acknowledge -> "acknowledge"

    and TypesPagerDutyEvent = {
        [<JsonPropertyName("account")>]
        Account: string option
        [<JsonPropertyName("attach_payload")>]
        AttachPayload: bool
        [<JsonPropertyName("client")>]
        Client: string option
        [<JsonPropertyName("client_url")>]
        ClientUrl: string option
        [<JsonPropertyName("contexts")>]
        Contexts: TypesPagerDutyContext array option
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("event_type")>]
        EventType: TypesPagerDutyEventType option
        [<JsonPropertyName("incident_key")>]
        IncidentKey: string
        [<JsonPropertyName("proxy")>]
        Proxy: TypesPagerDutyEventProxy option
    }

    and TypesPagerDutyAction = {
        [<JsonPropertyName("account")>]
        Account: string option
        [<JsonPropertyName("attach_payload")>]
        AttachPayload: bool
        [<JsonPropertyName("client")>]
        Client: string option
        [<JsonPropertyName("client_url")>]
        ClientUrl: string option
        [<JsonPropertyName("contexts")>]
        Contexts: TypesPagerDutyContext array option
        [<JsonPropertyName("description")>]
        Description: string
        [<JsonPropertyName("event_type")>]
        EventType: TypesPagerDutyEventType option
        [<JsonPropertyName("incident_key")>]
        IncidentKey: string
        [<JsonPropertyName("proxy")>]
        Proxy: TypesPagerDutyEventProxy option
    }

    and TypesSlackAttachmentField = {
        [<JsonPropertyName("short")>]
        Short: bool
        [<JsonPropertyName("title")>]
        Title: string
        [<JsonPropertyName("value")>]
        Value: string
    }

    and TypesSlackAttachment = {
        [<JsonPropertyName("author_icon")>]
        AuthorIcon: string option
        [<JsonPropertyName("author_link")>]
        AuthorLink: string option
        [<JsonPropertyName("author_name")>]
        AuthorName: string
        [<JsonPropertyName("color")>]
        Color: string option
        [<JsonPropertyName("fallback")>]
        Fallback: string option
        [<JsonPropertyName("fields")>]
        Fields: TypesSlackAttachmentField array option
        [<JsonPropertyName("footer")>]
        Footer: string option
        [<JsonPropertyName("footer_icon")>]
        FooterIcon: string option
        [<JsonPropertyName("image_url")>]
        ImageUrl: string option
        [<JsonPropertyName("pretext")>]
        Pretext: string option
        [<JsonPropertyName("text")>]
        Text: string option
        [<JsonPropertyName("thumb_url")>]
        ThumbUrl: string option
        [<JsonPropertyName("title")>]
        Title: string
        [<JsonPropertyName("title_link")>]
        TitleLink: string option
        [<JsonPropertyName("ts")>]
        Ts: EpochTimeUnitSeconds option
    }

    and TypesSlackDynamicAttachment = {
        [<JsonPropertyName("attachment_template")>]
        AttachmentTemplate: TypesSlackAttachment
        [<JsonPropertyName("list_path")>]
        ListPath: string
    }

    and TypesSlackMessage = {
        [<JsonPropertyName("attachments")>]
        Attachments: TypesSlackAttachment array
        [<JsonPropertyName("dynamic_attachments")>]
        DynamicAttachments: TypesSlackDynamicAttachment option
        [<JsonPropertyName("from")>]
        From: string
        [<JsonPropertyName("icon")>]
        Icon: string option
        [<JsonPropertyName("text")>]
        Text: string
        [<JsonPropertyName("to")>]
        To: string array
    }

    and TypesSlackAction = {
        [<JsonPropertyName("account")>]
        Account: string option
        [<JsonPropertyName("message")>]
        Message: TypesSlackMessage
    }

    and TypesWebhookAction = {
        [<JsonPropertyName("auth")>]
        Auth: TypesHttpInputAuthentication option
        [<JsonPropertyName("body")>]
        Body: string option
        [<JsonPropertyName("connection_timeout")>]
        ConnectionTimeout: Duration option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string> option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("method")>]
        Method: TypesHttpInputMethod option
        [<JsonPropertyName("params")>]
        Params: Map<string, string> option
        [<JsonPropertyName("path")>]
        Path: string option
        [<JsonPropertyName("port")>]
        Port: Uint option
        [<JsonPropertyName("proxy")>]
        Proxy: TypesHttpInputProxy option
        [<JsonPropertyName("read_timeout")>]
        ReadTimeout: Duration option
        [<JsonPropertyName("scheme")>]
        Scheme: TypesConnectionScheme option
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesAction = {
        [<JsonPropertyName("action_type")>]
        ActionType: TypesActionType option
        [<JsonPropertyName("condition")>]
        Condition: TypesConditionContainer option
        [<JsonPropertyName("foreach")>]
        Foreach: string option
        [<JsonPropertyName("max_iterations")>]
        MaxIterations: float option
        [<JsonPropertyName("name")>]
        Name: Name option
        [<JsonPropertyName("throttle_period")>]
        ThrottlePeriod: Duration option
        [<JsonPropertyName("throttle_period_in_millis")>]
        ThrottlePeriodInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("transform")>]
        Transform: TransformContainer option
        [<JsonPropertyName("index")>]
        Index: TypesIndexAction option
        [<JsonPropertyName("logging")>]
        Logging: TypesLoggingAction option
        [<JsonPropertyName("email")>]
        Email: TypesEmailAction option
        [<JsonPropertyName("pagerduty")>]
        Pagerduty: TypesPagerDutyAction option
        [<JsonPropertyName("slack")>]
        Slack: TypesSlackAction option
        [<JsonPropertyName("webhook")>]
        Webhook: TypesWebhookAction option
    }

    and TypesChainInput = {
        [<JsonPropertyName("inputs")>]
        Inputs: Map<string, TypesInputContainer> array
    }

    and TypesResponseContentTypeConverter() =
        inherit JsonConverter<TypesResponseContentType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesResponseContentType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesResponseContentType.Json -> "json"
                | TypesResponseContentType.Yaml -> "yaml"
                | TypesResponseContentType.Text -> "text"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "json" -> TypesResponseContentType.Json
            | "yaml" -> TypesResponseContentType.Yaml
            | "text" -> TypesResponseContentType.Text
            | s -> failwith $"Unknown TypesResponseContentType: {s}"

    and [<JsonConverter(typeof<TypesResponseContentTypeConverter>)>]
        TypesResponseContentType =
        | Json
        | Yaml
        | Text
        with
        override this.ToString() =
            match this with
            | Json -> "json"
            | Yaml -> "yaml"
            | Text -> "text"

    and TypesHttpInput = {
        [<JsonPropertyName("extract")>]
        Extract: string array option
        [<JsonPropertyName("request")>]
        Request: TypesHttpInputRequestDefinition option
        [<JsonPropertyName("response_content_type")>]
        ResponseContentType: TypesResponseContentType option
    }

    and TypesSearchInput = {
        [<JsonPropertyName("extract")>]
        Extract: string array option
        [<JsonPropertyName("request")>]
        Request: TypesSearchInputRequestDefinition
        [<JsonPropertyName("timeout")>]
        Timeout: Duration option
    }

    and TypesInputContainer = {
        [<JsonPropertyName("chain")>]
        Chain: TypesChainInput option
        [<JsonPropertyName("http")>]
        Http: TypesHttpInput option
        [<JsonPropertyName("search")>]
        Search: TypesSearchInput option
        [<JsonPropertyName("simple")>]
        Simple: Map<string, obj> option
    }

    and TypesDailySchedule = {
        [<JsonPropertyName("at")>]
        At: TypesScheduleTimeOfDay array
    }

    and TypesHourlySchedule = {
        [<JsonPropertyName("minute")>]
        Minute: float array
    }

    and TypesTimeOfMonth = {
        [<JsonPropertyName("at")>]
        At: string array
        [<JsonPropertyName("on")>]
        On: float array
    }

    and TypesDayConverter() =
        inherit JsonConverter<TypesDay>()

        override _.Write(writer: Utf8JsonWriter, value: TypesDay, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesDay.Sunday -> "sunday"
                | TypesDay.Monday -> "monday"
                | TypesDay.Tuesday -> "tuesday"
                | TypesDay.Wednesday -> "wednesday"
                | TypesDay.Thursday -> "thursday"
                | TypesDay.Friday -> "friday"
                | TypesDay.Saturday -> "saturday"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "sunday" -> TypesDay.Sunday
            | "monday" -> TypesDay.Monday
            | "tuesday" -> TypesDay.Tuesday
            | "wednesday" -> TypesDay.Wednesday
            | "thursday" -> TypesDay.Thursday
            | "friday" -> TypesDay.Friday
            | "saturday" -> TypesDay.Saturday
            | s -> failwith $"Unknown TypesDay: {s}"

    and [<JsonConverter(typeof<TypesDayConverter>)>]
        TypesDay =
        | Sunday
        | Monday
        | Tuesday
        | Wednesday
        | Thursday
        | Friday
        | Saturday
        with
        override this.ToString() =
            match this with
            | Sunday -> "sunday"
            | Monday -> "monday"
            | Tuesday -> "tuesday"
            | Wednesday -> "wednesday"
            | Thursday -> "thursday"
            | Friday -> "friday"
            | Saturday -> "saturday"

    and TypesTimeOfWeek = {
        [<JsonPropertyName("at")>]
        At: string array
        [<JsonPropertyName("on")>]
        On: TypesDay array
    }

    and TypesMonthConverter() =
        inherit JsonConverter<TypesMonth>()

        override _.Write(writer: Utf8JsonWriter, value: TypesMonth, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesMonth.January -> "january"
                | TypesMonth.February -> "february"
                | TypesMonth.March -> "march"
                | TypesMonth.April -> "april"
                | TypesMonth.May -> "may"
                | TypesMonth.June -> "june"
                | TypesMonth.July -> "july"
                | TypesMonth.August -> "august"
                | TypesMonth.September -> "september"
                | TypesMonth.October -> "october"
                | TypesMonth.November -> "november"
                | TypesMonth.December -> "december"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "january" -> TypesMonth.January
            | "february" -> TypesMonth.February
            | "march" -> TypesMonth.March
            | "april" -> TypesMonth.April
            | "may" -> TypesMonth.May
            | "june" -> TypesMonth.June
            | "july" -> TypesMonth.July
            | "august" -> TypesMonth.August
            | "september" -> TypesMonth.September
            | "october" -> TypesMonth.October
            | "november" -> TypesMonth.November
            | "december" -> TypesMonth.December
            | s -> failwith $"Unknown TypesMonth: {s}"

    and [<JsonConverter(typeof<TypesMonthConverter>)>]
        TypesMonth =
        | January
        | February
        | March
        | April
        | May
        | June
        | July
        | August
        | September
        | October
        | November
        | December
        with
        override this.ToString() =
            match this with
            | January -> "january"
            | February -> "february"
            | March -> "march"
            | April -> "april"
            | May -> "may"
            | June -> "june"
            | July -> "july"
            | August -> "august"
            | September -> "september"
            | October -> "october"
            | November -> "november"
            | December -> "december"

    and TypesTimeOfYear = {
        [<JsonPropertyName("at")>]
        At: string array
        [<JsonPropertyName("int")>]
        Int: TypesMonth array
        [<JsonPropertyName("on")>]
        On: float array
    }

    and TypesScheduleContainer = {
        [<JsonPropertyName("timezone")>]
        Timezone: string option
        [<JsonPropertyName("cron")>]
        Cron: TypesCronExpression option
        [<JsonPropertyName("daily")>]
        Daily: TypesDailySchedule option
        [<JsonPropertyName("hourly")>]
        Hourly: TypesHourlySchedule option
        [<JsonPropertyName("interval")>]
        Interval: Duration option
        [<JsonPropertyName("monthly")>]
        Monthly: System.Text.Json.JsonElement option
        [<JsonPropertyName("weekly")>]
        Weekly: System.Text.Json.JsonElement option
        [<JsonPropertyName("yearly")>]
        Yearly: System.Text.Json.JsonElement option
    }

    and TypesTriggerContainer = {
        [<JsonPropertyName("schedule")>]
        Schedule: TypesScheduleContainer option
    }

    and TypesWatch = {
        [<JsonPropertyName("actions")>]
        Actions: Map<string, TypesAction>
        [<JsonPropertyName("condition")>]
        Condition: TypesConditionContainer
        [<JsonPropertyName("input")>]
        Input: TypesInputContainer
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("status")>]
        Status: TypesWatchStatus option
        [<JsonPropertyName("throttle_period")>]
        ThrottlePeriod: Duration option
        [<JsonPropertyName("throttle_period_in_millis")>]
        ThrottlePeriodInMillis: DurationValueUnitMillis option
        [<JsonPropertyName("transform")>]
        Transform: TransformContainer option
        [<JsonPropertyName("trigger")>]
        Trigger: TypesTriggerContainer
    }

    and TypesActionStatusOptionsConverter() =
        inherit JsonConverter<TypesActionStatusOptions>()

        override _.Write(writer: Utf8JsonWriter, value: TypesActionStatusOptions, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesActionStatusOptions.Success -> "success"
                | TypesActionStatusOptions.Failure -> "failure"
                | TypesActionStatusOptions.Simulated -> "simulated"
                | TypesActionStatusOptions.Throttled -> "throttled"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "success" -> TypesActionStatusOptions.Success
            | "failure" -> TypesActionStatusOptions.Failure
            | "simulated" -> TypesActionStatusOptions.Simulated
            | "throttled" -> TypesActionStatusOptions.Throttled
            | s -> failwith $"Unknown TypesActionStatusOptions: {s}"

    and [<JsonConverter(typeof<TypesActionStatusOptionsConverter>)>]
        TypesActionStatusOptions =
        | Success
        | Failure
        | Simulated
        | Throttled
        with
        override this.ToString() =
            match this with
            | Success -> "success"
            | Failure -> "failure"
            | Simulated -> "simulated"
            | Throttled -> "throttled"

    and TypesEmailResult = {
        [<JsonPropertyName("account")>]
        Account: string option
        [<JsonPropertyName("message")>]
        Message: TypesEmail
        [<JsonPropertyName("reason")>]
        Reason: string option
    }

    and TypesIndexResultSummary = {
        [<JsonPropertyName("created")>]
        Created: bool
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("index")>]
        Index: IndexName
        [<JsonPropertyName("result")>]
        Result: Result
        [<JsonPropertyName("version")>]
        Version: VersionNumber
    }

    and TypesIndexResult = {
        [<JsonPropertyName("response")>]
        Response: TypesIndexResultSummary
    }

    and TypesLoggingResult = {
        [<JsonPropertyName("logged_text")>]
        LoggedText: string
    }

    and TypesHttpInputRequestResult = {
        [<JsonPropertyName("auth")>]
        Auth: TypesHttpInputAuthentication option
        [<JsonPropertyName("body")>]
        Body: string option
        [<JsonPropertyName("connection_timeout")>]
        ConnectionTimeout: Duration option
        [<JsonPropertyName("headers")>]
        Headers: Map<string, string> option
        [<JsonPropertyName("host")>]
        Host: Host option
        [<JsonPropertyName("method")>]
        Method: TypesHttpInputMethod option
        [<JsonPropertyName("params")>]
        Params: Map<string, string> option
        [<JsonPropertyName("path")>]
        Path: string option
        [<JsonPropertyName("port")>]
        Port: Uint option
        [<JsonPropertyName("proxy")>]
        Proxy: TypesHttpInputProxy option
        [<JsonPropertyName("read_timeout")>]
        ReadTimeout: Duration option
        [<JsonPropertyName("scheme")>]
        Scheme: TypesConnectionScheme option
        [<JsonPropertyName("url")>]
        Url: string option
    }

    and TypesHttpInputResponseResult = {
        [<JsonPropertyName("body")>]
        Body: string
        [<JsonPropertyName("headers")>]
        Headers: HttpHeaders
        [<JsonPropertyName("status")>]
        Status: float
    }

    and TypesPagerDutyResult = {
        [<JsonPropertyName("event")>]
        Event: TypesPagerDutyEvent
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("request")>]
        Request: TypesHttpInputRequestResult option
        [<JsonPropertyName("response")>]
        Response: TypesHttpInputResponseResult option
    }

    and TypesSlackResult = {
        [<JsonPropertyName("account")>]
        Account: string option
        [<JsonPropertyName("message")>]
        Message: TypesSlackMessage
    }

    and TypesWebhookResult = {
        [<JsonPropertyName("request")>]
        Request: TypesHttpInputRequestResult
        [<JsonPropertyName("response")>]
        Response: TypesHttpInputResponseResult option
    }

    and TypesExecutionResultAction = {
        [<JsonPropertyName("email")>]
        Email: TypesEmailResult option
        [<JsonPropertyName("id")>]
        Id: Id
        [<JsonPropertyName("index")>]
        Index: TypesIndexResult option
        [<JsonPropertyName("logging")>]
        Logging: TypesLoggingResult option
        [<JsonPropertyName("pagerduty")>]
        Pagerduty: TypesPagerDutyResult option
        [<JsonPropertyName("reason")>]
        Reason: string option
        [<JsonPropertyName("slack")>]
        Slack: TypesSlackResult option
        [<JsonPropertyName("status")>]
        Status: TypesActionStatusOptions
        [<JsonPropertyName("type")>]
        Type: TypesActionType
        [<JsonPropertyName("webhook")>]
        Webhook: TypesWebhookResult option
        [<JsonPropertyName("error")>]
        Error: ErrorCause option
    }

    and TypesConditionTypeConverter() =
        inherit JsonConverter<TypesConditionType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesConditionType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesConditionType.Always -> "always"
                | TypesConditionType.Never -> "never"
                | TypesConditionType.Script -> "script"
                | TypesConditionType.Compare -> "compare"
                | TypesConditionType.ArrayCompare -> "array_compare"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "always" -> TypesConditionType.Always
            | "never" -> TypesConditionType.Never
            | "script" -> TypesConditionType.Script
            | "compare" -> TypesConditionType.Compare
            | "array_compare" -> TypesConditionType.ArrayCompare
            | s -> failwith $"Unknown TypesConditionType: {s}"

    and [<JsonConverter(typeof<TypesConditionTypeConverter>)>]
        TypesConditionType =
        | Always
        | Never
        | Script
        | Compare
        | ArrayCompare
        with
        override this.ToString() =
            match this with
            | Always -> "always"
            | Never -> "never"
            | Script -> "script"
            | Compare -> "compare"
            | ArrayCompare -> "array_compare"

    and TypesExecutionResultCondition = {
        [<JsonPropertyName("met")>]
        Met: bool
        [<JsonPropertyName("status")>]
        Status: TypesActionStatusOptions
        [<JsonPropertyName("type")>]
        Type: TypesConditionType
    }

    and TypesInputTypeConverter() =
        inherit JsonConverter<TypesInputType>()

        override _.Write(writer: Utf8JsonWriter, value: TypesInputType, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesInputType.Http -> "http"
                | TypesInputType.Search -> "search"
                | TypesInputType.Simple -> "simple"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "http" -> TypesInputType.Http
            | "search" -> TypesInputType.Search
            | "simple" -> TypesInputType.Simple
            | s -> failwith $"Unknown TypesInputType: {s}"

    and [<JsonConverter(typeof<TypesInputTypeConverter>)>]
        TypesInputType =
        | Http
        | Search
        | Simple
        with
        override this.ToString() =
            match this with
            | Http -> "http"
            | Search -> "search"
            | Simple -> "simple"

    and TypesExecutionResultInput = {
        [<JsonPropertyName("payload")>]
        Payload: Map<string, obj>
        [<JsonPropertyName("status")>]
        Status: TypesActionStatusOptions
        [<JsonPropertyName("type")>]
        Type: TypesInputType
    }

    and TypesExecutionResult = {
        [<JsonPropertyName("actions")>]
        Actions: TypesExecutionResultAction array
        [<JsonPropertyName("condition")>]
        Condition: TypesExecutionResultCondition
        [<JsonPropertyName("execution_duration")>]
        ExecutionDuration: DurationValueUnitMillis
        [<JsonPropertyName("execution_time")>]
        ExecutionTime: DateTime
        [<JsonPropertyName("input")>]
        Input: TypesExecutionResultInput
    }

    and TypesExecutionStatusConverter() =
        inherit JsonConverter<TypesExecutionStatus>()

        override _.Write(writer: Utf8JsonWriter, value: TypesExecutionStatus, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesExecutionStatus.AwaitsExecution -> "awaits_execution"
                | TypesExecutionStatus.Checking -> "checking"
                | TypesExecutionStatus.ExecutionNotNeeded -> "execution_not_needed"
                | TypesExecutionStatus.Throttled -> "throttled"
                | TypesExecutionStatus.Executed -> "executed"
                | TypesExecutionStatus.Failed -> "failed"
                | TypesExecutionStatus.DeletedWhileQueued -> "deleted_while_queued"
                | TypesExecutionStatus.NotExecutedAlreadyQueued -> "not_executed_already_queued"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "awaits_execution" -> TypesExecutionStatus.AwaitsExecution
            | "checking" -> TypesExecutionStatus.Checking
            | "execution_not_needed" -> TypesExecutionStatus.ExecutionNotNeeded
            | "throttled" -> TypesExecutionStatus.Throttled
            | "executed" -> TypesExecutionStatus.Executed
            | "failed" -> TypesExecutionStatus.Failed
            | "deleted_while_queued" -> TypesExecutionStatus.DeletedWhileQueued
            | "not_executed_already_queued" -> TypesExecutionStatus.NotExecutedAlreadyQueued
            | s -> failwith $"Unknown TypesExecutionStatus: {s}"

    and [<JsonConverter(typeof<TypesExecutionStatusConverter>)>]
        TypesExecutionStatus =
        | AwaitsExecution
        | Checking
        | ExecutionNotNeeded
        | Throttled
        | Executed
        | Failed
        | DeletedWhileQueued
        | NotExecutedAlreadyQueued
        with
        override this.ToString() =
            match this with
            | AwaitsExecution -> "awaits_execution"
            | Checking -> "checking"
            | ExecutionNotNeeded -> "execution_not_needed"
            | Throttled -> "throttled"
            | Executed -> "executed"
            | Failed -> "failed"
            | DeletedWhileQueued -> "deleted_while_queued"
            | NotExecutedAlreadyQueued -> "not_executed_already_queued"

    and TypesTriggerEventContainer = {
        [<JsonPropertyName("schedule")>]
        Schedule: TypesScheduleTriggerEvent option
    }

    and TypesTriggerEventResult = {
        [<JsonPropertyName("manual")>]
        Manual: TypesTriggerEventContainer
        [<JsonPropertyName("triggered_time")>]
        TriggeredTime: DateTime
        [<JsonPropertyName("type")>]
        Type: string
    }

    and ExecuteWatchWatchRecord = {
        [<JsonPropertyName("condition")>]
        Condition: TypesConditionContainer
        [<JsonPropertyName("input")>]
        Input: TypesInputContainer
        [<JsonPropertyName("messages")>]
        Messages: string array
        [<JsonPropertyName("metadata")>]
        Metadata: Metadata option
        [<JsonPropertyName("node")>]
        Node: string
        [<JsonPropertyName("result")>]
        Result: TypesExecutionResult
        [<JsonPropertyName("state")>]
        State: TypesExecutionStatus
        [<JsonPropertyName("trigger_event")>]
        TriggerEvent: TypesTriggerEventResult
        [<JsonPropertyName("user")>]
        User: Username
        [<JsonPropertyName("watch_id")>]
        WatchId: Id
        [<JsonPropertyName("status")>]
        Status: TypesWatchStatus option
    }

    and TypesQueryWatch = {
        [<JsonPropertyName("_id")>]
        Id: Id
        [<JsonPropertyName("status")>]
        Status: TypesWatchStatus option
        [<JsonPropertyName("watch")>]
        Watch: TypesWatch option
        [<JsonPropertyName("_primary_term")>]
        PrimaryTerm: float option
        [<JsonPropertyName("_seq_no")>]
        SeqNo: SequenceNumber option
    }

    and StatsWatcherMetricConverter() =
        inherit JsonConverter<StatsWatcherMetric>()

        override _.Write(writer: Utf8JsonWriter, value: StatsWatcherMetric, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StatsWatcherMetric.All -> "_all"
                | StatsWatcherMetric.QueuedWatches -> "queued_watches"
                | StatsWatcherMetric.CurrentWatches -> "current_watches"
                | StatsWatcherMetric.PendingWatches -> "pending_watches"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "_all" -> StatsWatcherMetric.All
            | "queued_watches" -> StatsWatcherMetric.QueuedWatches
            | "current_watches" -> StatsWatcherMetric.CurrentWatches
            | "pending_watches" -> StatsWatcherMetric.PendingWatches
            | s -> failwith $"Unknown StatsWatcherMetric: {s}"

    and [<JsonConverter(typeof<StatsWatcherMetricConverter>)>]
        StatsWatcherMetric =
        | All
        | QueuedWatches
        | CurrentWatches
        | PendingWatches
        with
        override this.ToString() =
            match this with
            | All -> "_all"
            | QueuedWatches -> "queued_watches"
            | CurrentWatches -> "current_watches"
            | PendingWatches -> "pending_watches"

    and TypesExecutionThreadPool = {
        [<JsonPropertyName("max_size")>]
        MaxSize: float
        [<JsonPropertyName("queue_size")>]
        QueueSize: float
    }

    and StatsWatchRecordQueuedStats = {
        [<JsonPropertyName("execution_time")>]
        ExecutionTime: DateTime
    }

    and TypesExecutionPhaseConverter() =
        inherit JsonConverter<TypesExecutionPhase>()

        override _.Write(writer: Utf8JsonWriter, value: TypesExecutionPhase, _options: JsonSerializerOptions) =
            let str =
                match value with
                | TypesExecutionPhase.AwaitsExecution -> "awaits_execution"
                | TypesExecutionPhase.Started -> "started"
                | TypesExecutionPhase.Input -> "input"
                | TypesExecutionPhase.Condition -> "condition"
                | TypesExecutionPhase.Actions -> "actions"
                | TypesExecutionPhase.WatchTransform -> "watch_transform"
                | TypesExecutionPhase.Aborted -> "aborted"
                | TypesExecutionPhase.Finished -> "finished"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "awaits_execution" -> TypesExecutionPhase.AwaitsExecution
            | "started" -> TypesExecutionPhase.Started
            | "input" -> TypesExecutionPhase.Input
            | "condition" -> TypesExecutionPhase.Condition
            | "actions" -> TypesExecutionPhase.Actions
            | "watch_transform" -> TypesExecutionPhase.WatchTransform
            | "aborted" -> TypesExecutionPhase.Aborted
            | "finished" -> TypesExecutionPhase.Finished
            | s -> failwith $"Unknown TypesExecutionPhase: {s}"

    and [<JsonConverter(typeof<TypesExecutionPhaseConverter>)>]
        TypesExecutionPhase =
        | AwaitsExecution
        | Started
        | Input
        | Condition
        | Actions
        | WatchTransform
        | Aborted
        | Finished
        with
        override this.ToString() =
            match this with
            | AwaitsExecution -> "awaits_execution"
            | Started -> "started"
            | Input -> "input"
            | Condition -> "condition"
            | Actions -> "actions"
            | WatchTransform -> "watch_transform"
            | Aborted -> "aborted"
            | Finished -> "finished"

    and StatsWatchRecordStats = {
        [<JsonPropertyName("execution_time")>]
        ExecutionTime: DateTime
        [<JsonPropertyName("execution_phase")>]
        ExecutionPhase: TypesExecutionPhase
        [<JsonPropertyName("triggered_time")>]
        TriggeredTime: DateTime
        [<JsonPropertyName("executed_actions")>]
        ExecutedActions: string array option
        [<JsonPropertyName("watch_id")>]
        WatchId: Id
        [<JsonPropertyName("watch_record_id")>]
        WatchRecordId: Id
    }

    and StatsWatcherStateConverter() =
        inherit JsonConverter<StatsWatcherState>()

        override _.Write(writer: Utf8JsonWriter, value: StatsWatcherState, _options: JsonSerializerOptions) =
            let str =
                match value with
                | StatsWatcherState.Stopped -> "stopped"
                | StatsWatcherState.Starting -> "starting"
                | StatsWatcherState.Started -> "started"
                | StatsWatcherState.Stopping -> "stopping"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "stopped" -> StatsWatcherState.Stopped
            | "starting" -> StatsWatcherState.Starting
            | "started" -> StatsWatcherState.Started
            | "stopping" -> StatsWatcherState.Stopping
            | s -> failwith $"Unknown StatsWatcherState: {s}"

    and [<JsonConverter(typeof<StatsWatcherStateConverter>)>]
        StatsWatcherState =
        | Stopped
        | Starting
        | Started
        | Stopping
        with
        override this.ToString() =
            match this with
            | Stopped -> "stopped"
            | Starting -> "starting"
            | Started -> "started"
            | Stopping -> "stopping"

    and StatsWatcherNodeStats = {
        [<JsonPropertyName("current_watches")>]
        CurrentWatches: StatsWatchRecordStats array option
        [<JsonPropertyName("execution_thread_pool")>]
        ExecutionThreadPool: TypesExecutionThreadPool
        [<JsonPropertyName("queued_watches")>]
        QueuedWatches: StatsWatchRecordQueuedStats array option
        [<JsonPropertyName("watch_count")>]
        WatchCount: float
        [<JsonPropertyName("watcher_state")>]
        WatcherState: StatsWatcherState
        [<JsonPropertyName("node_id")>]
        NodeId: Id
    }

    and InfoXPackCategoryConverter() =
        inherit JsonConverter<InfoXPackCategory>()

        override _.Write(writer: Utf8JsonWriter, value: InfoXPackCategory, _options: JsonSerializerOptions) =
            let str =
                match value with
                | InfoXPackCategory.Build -> "build"
                | InfoXPackCategory.Features -> "features"
                | InfoXPackCategory.License -> "license"
            writer.WriteStringValue(str)

        override _.Read(reader: byref<Utf8JsonReader>, _typeToConvert: Type, _options: JsonSerializerOptions) =
            match reader.GetString() with
            | "build" -> InfoXPackCategory.Build
            | "features" -> InfoXPackCategory.Features
            | "license" -> InfoXPackCategory.License
            | s -> failwith $"Unknown InfoXPackCategory: {s}"

    and [<JsonConverter(typeof<InfoXPackCategoryConverter>)>]
        InfoXPackCategory =
        | Build
        | Features
        | License
        with
        override this.ToString() =
            match this with
            | Build -> "build"
            | Features -> "features"
            | License -> "license"

    and InfoBuildInformation = {
        [<JsonPropertyName("date")>]
        Date: DateTime
        [<JsonPropertyName("hash")>]
        Hash: string
    }

    and InfoNativeCodeInformation = {
        [<JsonPropertyName("build_hash")>]
        BuildHash: string
        [<JsonPropertyName("version")>]
        Version: VersionString
    }

    and InfoFeature = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("description")>]
        Description: string option
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("native_code_info")>]
        NativeCodeInfo: InfoNativeCodeInformation option
    }

    and InfoFeatures = {
        [<JsonPropertyName("aggregate_metric")>]
        AggregateMetric: InfoFeature
        [<JsonPropertyName("analytics")>]
        Analytics: InfoFeature
        [<JsonPropertyName("ccr")>]
        Ccr: InfoFeature
        [<JsonPropertyName("data_streams")>]
        DataStreams: InfoFeature
        [<JsonPropertyName("data_tiers")>]
        DataTiers: InfoFeature
        [<JsonPropertyName("enrich")>]
        Enrich: InfoFeature
        [<JsonPropertyName("enterprise_search")>]
        EnterpriseSearch: InfoFeature
        [<JsonPropertyName("eql")>]
        Eql: InfoFeature
        [<JsonPropertyName("esql")>]
        Esql: InfoFeature
        [<JsonPropertyName("graph")>]
        Graph: InfoFeature
        [<JsonPropertyName("ilm")>]
        Ilm: InfoFeature
        [<JsonPropertyName("logstash")>]
        Logstash: InfoFeature
        [<JsonPropertyName("logsdb")>]
        Logsdb: InfoFeature
        [<JsonPropertyName("ml")>]
        Ml: InfoFeature
        [<JsonPropertyName("monitoring")>]
        Monitoring: InfoFeature
        [<JsonPropertyName("rollup")>]
        Rollup: InfoFeature
        [<JsonPropertyName("runtime_fields")>]
        RuntimeFields: InfoFeature option
        [<JsonPropertyName("searchable_snapshots")>]
        SearchableSnapshots: InfoFeature
        [<JsonPropertyName("security")>]
        Security: InfoFeature
        [<JsonPropertyName("slm")>]
        Slm: InfoFeature
        [<JsonPropertyName("spatial")>]
        Spatial: InfoFeature
        [<JsonPropertyName("sql")>]
        Sql: InfoFeature
        [<JsonPropertyName("transform")>]
        Transform: InfoFeature
        [<JsonPropertyName("universal_profiling")>]
        UniversalProfiling: InfoFeature
        [<JsonPropertyName("voting_only")>]
        VotingOnly: InfoFeature
        [<JsonPropertyName("watcher")>]
        Watcher: InfoFeature
        [<JsonPropertyName("archive")>]
        Archive: InfoFeature
    }

    and InfoMinimalLicenseInformation = {
        [<JsonPropertyName("expiry_date_in_millis")>]
        ExpiryDateInMillis: EpochTimeUnitMillis
        [<JsonPropertyName("mode")>]
        Mode: TypesLicenseType
        [<JsonPropertyName("status")>]
        Status: TypesLicenseStatus
        [<JsonPropertyName("type")>]
        Type: TypesLicenseType
        [<JsonPropertyName("uid")>]
        Uid: string
    }

    and UsageBase = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and UsageAnalyticsStatistics = {
        [<JsonPropertyName("boxplot_usage")>]
        BoxplotUsage: float
        [<JsonPropertyName("cumulative_cardinality_usage")>]
        CumulativeCardinalityUsage: float
        [<JsonPropertyName("string_stats_usage")>]
        StringStatsUsage: float
        [<JsonPropertyName("top_metrics_usage")>]
        TopMetricsUsage: float
        [<JsonPropertyName("t_test_usage")>]
        TTestUsage: float
        [<JsonPropertyName("moving_percentiles_usage")>]
        MovingPercentilesUsage: float
        [<JsonPropertyName("normalize_usage")>]
        NormalizeUsage: float
        [<JsonPropertyName("rate_usage")>]
        RateUsage: float
        [<JsonPropertyName("multi_terms_usage")>]
        MultiTermsUsage: float option
    }

    and UsageAnalytics = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("stats")>]
        Stats: UsageAnalyticsStatistics
    }

    and UsageArchive = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("indices_count")>]
        IndicesCount: float
    }

    and UsageCounter = {
        [<JsonPropertyName("active")>]
        Active: float
        [<JsonPropertyName("total")>]
        Total: float
    }

    and UsageWatcherActionTotals = {
        [<JsonPropertyName("total")>]
        Total: Duration
        [<JsonPropertyName("total_time_in_ms")>]
        TotalTimeInMs: DurationValueUnitMillis
    }

    and UsageWatcherActions = {
        [<JsonPropertyName("actions")>]
        Actions: Map<string, UsageWatcherActionTotals>
    }

    and UsageWatcherWatchTriggerSchedule = {
        [<JsonPropertyName("active")>]
        Active: float
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("cron")>]
        Cron: UsageCounter
        [<JsonPropertyName("_all")>]
        All: UsageCounter
    }

    and UsageWatcherWatchTrigger = {
        [<JsonPropertyName("schedule")>]
        Schedule: UsageWatcherWatchTriggerSchedule option
        [<JsonPropertyName("_all")>]
        All: UsageCounter
    }

    and UsageWatcherWatch = {
        [<JsonPropertyName("input")>]
        Input: Map<string, UsageCounter>
        [<JsonPropertyName("condition")>]
        Condition: Map<string, UsageCounter> option
        [<JsonPropertyName("action")>]
        Action: Map<string, UsageCounter> option
        [<JsonPropertyName("trigger")>]
        Trigger: UsageWatcherWatchTrigger
    }

    and UsageWatcher = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("execution")>]
        Execution: UsageWatcherActions
        [<JsonPropertyName("watch")>]
        Watch: UsageWatcherWatch
        [<JsonPropertyName("count")>]
        Count: UsageCounter
    }

    and UsageCcr = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("auto_follow_patterns_count")>]
        AutoFollowPatternsCount: float
        [<JsonPropertyName("follower_indices_count")>]
        FollowerIndicesCount: float
    }

    and UsageDataStreams = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("data_streams")>]
        DataStreams: float
        [<JsonPropertyName("indices_count")>]
        IndicesCount: float
    }

    and UsageDataTierPhaseStatistics = {
        [<JsonPropertyName("node_count")>]
        NodeCount: float
        [<JsonPropertyName("index_count")>]
        IndexCount: float
        [<JsonPropertyName("total_shard_count")>]
        TotalShardCount: float
        [<JsonPropertyName("primary_shard_count")>]
        PrimaryShardCount: float
        [<JsonPropertyName("doc_count")>]
        DocCount: float
        [<JsonPropertyName("total_size_bytes")>]
        TotalSizeBytes: float
        [<JsonPropertyName("primary_size_bytes")>]
        PrimarySizeBytes: float
        [<JsonPropertyName("primary_shard_size_avg_bytes")>]
        PrimaryShardSizeAvgBytes: float
        [<JsonPropertyName("primary_shard_size_median_bytes")>]
        PrimaryShardSizeMedianBytes: float
        [<JsonPropertyName("primary_shard_size_mad_bytes")>]
        PrimaryShardSizeMadBytes: float
    }

    and UsageDataTiers = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("data_warm")>]
        DataWarm: UsageDataTierPhaseStatistics
        [<JsonPropertyName("data_frozen")>]
        DataFrozen: UsageDataTierPhaseStatistics option
        [<JsonPropertyName("data_cold")>]
        DataCold: UsageDataTierPhaseStatistics
        [<JsonPropertyName("data_content")>]
        DataContent: UsageDataTierPhaseStatistics
        [<JsonPropertyName("data_hot")>]
        DataHot: UsageDataTierPhaseStatistics
    }

    and UsageEqlFeaturesJoin = {
        [<JsonPropertyName("join_queries_two")>]
        JoinQueriesTwo: Uint
        [<JsonPropertyName("join_queries_three")>]
        JoinQueriesThree: Uint
        [<JsonPropertyName("join_until")>]
        JoinUntil: Uint
        [<JsonPropertyName("join_queries_five_or_more")>]
        JoinQueriesFiveOrMore: Uint
        [<JsonPropertyName("join_queries_four")>]
        JoinQueriesFour: Uint
    }

    and UsageEqlFeaturesKeys = {
        [<JsonPropertyName("join_keys_two")>]
        JoinKeysTwo: Uint
        [<JsonPropertyName("join_keys_one")>]
        JoinKeysOne: Uint
        [<JsonPropertyName("join_keys_three")>]
        JoinKeysThree: Uint
        [<JsonPropertyName("join_keys_five_or_more")>]
        JoinKeysFiveOrMore: Uint
        [<JsonPropertyName("join_keys_four")>]
        JoinKeysFour: Uint
    }

    and UsageEqlFeaturesPipes = {
        [<JsonPropertyName("pipe_tail")>]
        PipeTail: Uint
        [<JsonPropertyName("pipe_head")>]
        PipeHead: Uint
    }

    and UsageEqlFeaturesSequences = {
        [<JsonPropertyName("sequence_queries_three")>]
        SequenceQueriesThree: Uint
        [<JsonPropertyName("sequence_queries_four")>]
        SequenceQueriesFour: Uint
        [<JsonPropertyName("sequence_queries_two")>]
        SequenceQueriesTwo: Uint
        [<JsonPropertyName("sequence_until")>]
        SequenceUntil: Uint
        [<JsonPropertyName("sequence_queries_five_or_more")>]
        SequenceQueriesFiveOrMore: Uint
        [<JsonPropertyName("sequence_maxspan")>]
        SequenceMaxspan: Uint
    }

    and UsageEqlFeatures = {
        [<JsonPropertyName("join")>]
        Join: Uint
        [<JsonPropertyName("joins")>]
        Joins: UsageEqlFeaturesJoin
        [<JsonPropertyName("keys")>]
        Keys: UsageEqlFeaturesKeys
        [<JsonPropertyName("event")>]
        Event: Uint
        [<JsonPropertyName("pipes")>]
        Pipes: UsageEqlFeaturesPipes
        [<JsonPropertyName("sequence")>]
        Sequence: Uint
        [<JsonPropertyName("sequences")>]
        Sequences: UsageEqlFeaturesSequences
    }

    and UsageQuery = {
        [<JsonPropertyName("count")>]
        Count: float option
        [<JsonPropertyName("failed")>]
        Failed: float option
        [<JsonPropertyName("paging")>]
        Paging: float option
        [<JsonPropertyName("total")>]
        Total: float option
    }

    and UsageEql = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("features")>]
        Features: UsageEqlFeatures
        [<JsonPropertyName("queries")>]
        Queries: Map<string, UsageQuery>
    }

    and UsageFlattened = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("field_count")>]
        FieldCount: float
    }

    and UsageInvocations = {
        [<JsonPropertyName("total")>]
        Total: float
    }

    and UsageHealthStatistics = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("invocations")>]
        Invocations: UsageInvocations
    }

    and UsagePhase = {
        [<JsonPropertyName("actions")>]
        Actions: string array
        [<JsonPropertyName("min_age")>]
        MinAge: DurationValueUnitMillis
    }

    and UsagePhases = {
        [<JsonPropertyName("cold")>]
        Cold: UsagePhase option
        [<JsonPropertyName("delete")>]
        Delete: UsagePhase option
        [<JsonPropertyName("frozen")>]
        Frozen: UsagePhase option
        [<JsonPropertyName("hot")>]
        Hot: UsagePhase option
        [<JsonPropertyName("warm")>]
        Warm: UsagePhase option
    }

    and UsageIlmPolicyStatistics = {
        [<JsonPropertyName("indices_managed")>]
        IndicesManaged: float
        [<JsonPropertyName("phases")>]
        Phases: UsagePhases
    }

    and UsageIlm = {
        [<JsonPropertyName("policy_count")>]
        PolicyCount: float
        [<JsonPropertyName("policy_stats")>]
        PolicyStats: UsageIlmPolicyStatistics array
    }

    and UsageDatafeed = {
        [<JsonPropertyName("count")>]
        Count: float
    }

    and UsageMlJobForecasts = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("forecasted_jobs")>]
        ForecastedJobs: float
    }

    and UsageJobUsage = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("created_by")>]
        CreatedBy: Map<string, float>
        [<JsonPropertyName("detectors")>]
        Detectors: TypesJobStatistics
        [<JsonPropertyName("forecasts")>]
        Forecasts: UsageMlJobForecasts
        [<JsonPropertyName("model_size")>]
        ModelSize: TypesJobStatistics
    }

    and UsageMlDataFrameAnalyticsJobsAnalysis = {
        [<JsonPropertyName("classification")>]
        Classification: float option
        [<JsonPropertyName("outlier_detection")>]
        OutlierDetection: float option
        [<JsonPropertyName("regression")>]
        Regression: float option
    }

    and UsageMlDataFrameAnalyticsJobsCount = {
        [<JsonPropertyName("count")>]
        Count: float
    }

    and UsageMlDataFrameAnalyticsJobsMemory = {
        [<JsonPropertyName("peak_usage_bytes")>]
        PeakUsageBytes: TypesJobStatistics
    }

    and UsageMlDataFrameAnalyticsJobs = {
        [<JsonPropertyName("memory_usage")>]
        MemoryUsage: UsageMlDataFrameAnalyticsJobsMemory option
        [<JsonPropertyName("_all")>]
        All: UsageMlDataFrameAnalyticsJobsCount
        [<JsonPropertyName("analysis_counts")>]
        AnalysisCounts: UsageMlDataFrameAnalyticsJobsAnalysis option
        [<JsonPropertyName("stopped")>]
        Stopped: UsageMlDataFrameAnalyticsJobsCount option
    }

    and UsageMlInferenceDeploymentsTimeMs = {
        [<JsonPropertyName("avg")>]
        Avg: float
    }

    and UsageMlInferenceDeployments = {
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("inference_counts")>]
        InferenceCounts: TypesJobStatistics
        [<JsonPropertyName("model_sizes_bytes")>]
        ModelSizesBytes: TypesJobStatistics
        [<JsonPropertyName("time_ms")>]
        TimeMs: UsageMlInferenceDeploymentsTimeMs
    }

    and UsageMlCounter = {
        [<JsonPropertyName("count")>]
        Count: float
    }

    and UsageMlInferenceIngestProcessorCount = {
        [<JsonPropertyName("max")>]
        Max: float
        [<JsonPropertyName("sum")>]
        Sum: float
        [<JsonPropertyName("min")>]
        Min: float
    }

    and UsageMlInferenceIngestProcessor = {
        [<JsonPropertyName("num_docs_processed")>]
        NumDocsProcessed: UsageMlInferenceIngestProcessorCount
        [<JsonPropertyName("pipelines")>]
        Pipelines: UsageMlCounter
        [<JsonPropertyName("num_failures")>]
        NumFailures: UsageMlInferenceIngestProcessorCount
        [<JsonPropertyName("time_ms")>]
        TimeMs: UsageMlInferenceIngestProcessorCount
    }

    and UsageMlInferenceTrainedModelsCount = {
        [<JsonPropertyName("total")>]
        Total: float
        [<JsonPropertyName("prepackaged")>]
        Prepackaged: float
        [<JsonPropertyName("other")>]
        Other: float
        [<JsonPropertyName("pass_through")>]
        PassThrough: float option
        [<JsonPropertyName("regression")>]
        Regression: float option
        [<JsonPropertyName("classification")>]
        Classification: float option
        [<JsonPropertyName("ner")>]
        Ner: float option
        [<JsonPropertyName("text_embedding")>]
        TextEmbedding: float option
    }

    and UsageMlInferenceTrainedModels = {
        [<JsonPropertyName("estimated_operations")>]
        EstimatedOperations: TypesJobStatistics option
        [<JsonPropertyName("estimated_heap_memory_usage_bytes")>]
        EstimatedHeapMemoryUsageBytes: TypesJobStatistics option
        [<JsonPropertyName("count")>]
        Count: UsageMlInferenceTrainedModelsCount option
        [<JsonPropertyName("_all")>]
        All: UsageMlCounter
        [<JsonPropertyName("model_size_bytes")>]
        ModelSizeBytes: TypesJobStatistics option
    }

    and UsageMlInference = {
        [<JsonPropertyName("ingest_processors")>]
        IngestProcessors: Map<string, UsageMlInferenceIngestProcessor>
        [<JsonPropertyName("trained_models")>]
        TrainedModels: UsageMlInferenceTrainedModels
        [<JsonPropertyName("deployments")>]
        Deployments: UsageMlInferenceDeployments option
    }

    and UsageMachineLearning = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("datafeeds")>]
        Datafeeds: Map<string, UsageDatafeed>
        [<JsonPropertyName("jobs")>]
        Jobs: Map<string, UsageJobUsage>
        [<JsonPropertyName("node_count")>]
        NodeCount: float
        [<JsonPropertyName("data_frame_analytics_jobs")>]
        DataFrameAnalyticsJobs: UsageMlDataFrameAnalyticsJobs
        [<JsonPropertyName("inference")>]
        Inference: UsageMlInference
    }

    and UsageMonitoring = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("collection_enabled")>]
        CollectionEnabled: bool
        [<JsonPropertyName("enabled_exporters")>]
        EnabledExporters: Map<string, float>
    }

    and UsageRuntimeFieldsType = {
        [<JsonPropertyName("chars_max")>]
        CharsMax: float
        [<JsonPropertyName("chars_total")>]
        CharsTotal: float
        [<JsonPropertyName("count")>]
        Count: float
        [<JsonPropertyName("doc_max")>]
        DocMax: float
        [<JsonPropertyName("doc_total")>]
        DocTotal: float
        [<JsonPropertyName("index_count")>]
        IndexCount: float
        [<JsonPropertyName("lang")>]
        Lang: string array
        [<JsonPropertyName("lines_max")>]
        LinesMax: float
        [<JsonPropertyName("lines_total")>]
        LinesTotal: float
        [<JsonPropertyName("name")>]
        Name: Field
        [<JsonPropertyName("scriptless_count")>]
        ScriptlessCount: float
        [<JsonPropertyName("shadowed_count")>]
        ShadowedCount: float
        [<JsonPropertyName("source_max")>]
        SourceMax: float
        [<JsonPropertyName("source_total")>]
        SourceTotal: float
    }

    and UsageRuntimeFieldTypes = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("field_types")>]
        FieldTypes: UsageRuntimeFieldsType array
    }

    and UsageSearchableSnapshots = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("indices_count")>]
        IndicesCount: float
        [<JsonPropertyName("full_copy_indices_count")>]
        FullCopyIndicesCount: float option
        [<JsonPropertyName("shared_cache_indices_count")>]
        SharedCacheIndicesCount: float option
    }

    and UsageFeatureToggle = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
    }

    and UsageAudit = {
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("outputs")>]
        Outputs: string array option
    }

    and UsageIpFilter = {
        [<JsonPropertyName("http")>]
        Http: bool
        [<JsonPropertyName("transport")>]
        Transport: bool
    }

    and UsageRealmCache = {
        [<JsonPropertyName("size")>]
        Size: float
    }

    and UsageRealm = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("name")>]
        Name: string array option
        [<JsonPropertyName("order")>]
        Order: float array option
        [<JsonPropertyName("size")>]
        Size: float array option
        [<JsonPropertyName("cache")>]
        Cache: UsageRealmCache array option
        [<JsonPropertyName("has_authorization_realms")>]
        HasAuthorizationRealms: bool array option
        [<JsonPropertyName("has_default_username_pattern")>]
        HasDefaultUsernamePattern: bool array option
        [<JsonPropertyName("has_truststore")>]
        HasTruststore: bool array option
        [<JsonPropertyName("is_authentication_delegated")>]
        IsAuthenticationDelegated: bool array option
    }

    and UsageRoleMapping = {
        [<JsonPropertyName("enabled")>]
        Enabled: float
        [<JsonPropertyName("size")>]
        Size: float
    }

    and UsageSecurityRolesFile = {
        [<JsonPropertyName("dls")>]
        Dls: bool
        [<JsonPropertyName("fls")>]
        Fls: bool
        [<JsonPropertyName("size")>]
        Size: float
    }

    and UsageSecurityRolesNative = {
        [<JsonPropertyName("dls")>]
        Dls: bool
        [<JsonPropertyName("fls")>]
        Fls: bool
        [<JsonPropertyName("size")>]
        Size: float
    }

    and UsageSecurityRoles = {
        [<JsonPropertyName("native")>]
        Native: UsageSecurityRolesNative
        [<JsonPropertyName("dls")>]
        Dls: UsageSecurityRolesDls
        [<JsonPropertyName("file")>]
        File: UsageSecurityRolesFile
    }

    and UsageSsl = {
        [<JsonPropertyName("http")>]
        Http: UsageFeatureToggle
        [<JsonPropertyName("transport")>]
        Transport: UsageFeatureToggle
    }

    and UsageSecurity = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("api_key_service")>]
        ApiKeyService: UsageFeatureToggle
        [<JsonPropertyName("anonymous")>]
        Anonymous: UsageFeatureToggle
        [<JsonPropertyName("audit")>]
        Audit: UsageAudit
        [<JsonPropertyName("fips_140")>]
        Fips140: UsageFeatureToggle
        [<JsonPropertyName("ipfilter")>]
        Ipfilter: UsageIpFilter
        [<JsonPropertyName("realms")>]
        Realms: Map<string, UsageRealm>
        [<JsonPropertyName("role_mapping")>]
        RoleMapping: Map<string, UsageRoleMapping>
        [<JsonPropertyName("roles")>]
        Roles: UsageSecurityRoles
        [<JsonPropertyName("ssl")>]
        Ssl: UsageSsl
        [<JsonPropertyName("system_key")>]
        SystemKey: UsageFeatureToggle option
        [<JsonPropertyName("token_service")>]
        TokenService: UsageFeatureToggle
        [<JsonPropertyName("operator_privileges")>]
        OperatorPrivileges: UsageBase
    }

    and UsageSlm = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("policy_count")>]
        PolicyCount: float option
        [<JsonPropertyName("policy_stats")>]
        PolicyStats: TypesStatistics option
    }

    and UsageSql = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("features")>]
        Features: Map<string, float>
        [<JsonPropertyName("queries")>]
        Queries: Map<string, UsageQuery>
    }

    and UsageVector = {
        [<JsonPropertyName("available")>]
        Available: bool
        [<JsonPropertyName("enabled")>]
        Enabled: bool
        [<JsonPropertyName("dense_vector_dims_avg_count")>]
        DenseVectorDimsAvgCount: float
        [<JsonPropertyName("dense_vector_fields_count")>]
        DenseVectorFieldsCount: float
        [<JsonPropertyName("sparse_vector_fields_count")>]
        SparseVectorFieldsCount: float option
    }

    // ==========================================================================
    // Smart Constructors for Discriminated Unions
    // ==========================================================================

    /// Smart constructors for AggregationsMovingAverageAggregation
    [<RequireQualifiedAccess>]
    module AggregationsMovingAverageAggregationBuilders =
        /// Creates a Ewma with default values
        let ewma () : AggregationsMovingAverageAggregation =
            AggregationsMovingAverageAggregation.Ewma {
                BucketsPath = Option.None
                Format = Option.None
                GapPolicy = Option.None
                Minimize = Option.None
                Predict = Option.None
                Window = Option.None
                Model = "ewma"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Holt with default values
        let holt () : AggregationsMovingAverageAggregation =
            AggregationsMovingAverageAggregation.Holt {
                BucketsPath = Option.None
                Format = Option.None
                GapPolicy = Option.None
                Minimize = Option.None
                Predict = Option.None
                Window = Option.None
                Model = "holt"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a HoltWinters with default values
        let holtWinters () : AggregationsMovingAverageAggregation =
            AggregationsMovingAverageAggregation.HoltWinters {
                BucketsPath = Option.None
                Format = Option.None
                GapPolicy = Option.None
                Minimize = Option.None
                Predict = Option.None
                Window = Option.None
                Model = "holt_winters"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Linear with default values
        let linear () : AggregationsMovingAverageAggregation =
            AggregationsMovingAverageAggregation.Linear {
                BucketsPath = Option.None
                Format = Option.None
                GapPolicy = Option.None
                Minimize = Option.None
                Predict = Option.None
                Window = Option.None
                Model = "linear"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Simple with default values
        let simple () : AggregationsMovingAverageAggregation =
            AggregationsMovingAverageAggregation.Simple {
                BucketsPath = Option.None
                Format = Option.None
                GapPolicy = Option.None
                Minimize = Option.None
                Predict = Option.None
                Window = Option.None
                Model = "simple"
                Settings = Unchecked.defaultof<_>
            }

    /// Smart constructors for AnalysisAnalyzer
    [<RequireQualifiedAccess>]
    module AnalysisAnalyzerBuilders =
        /// Creates a Arabic with default values
        let arabic () : AnalysisAnalyzer =
            AnalysisAnalyzer.Arabic {
                Type = "arabic"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Armenian with default values
        let armenian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Armenian {
                Type = "armenian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Basque with default values
        let basque () : AnalysisAnalyzer =
            AnalysisAnalyzer.Basque {
                Type = "basque"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Bengali with default values
        let bengali () : AnalysisAnalyzer =
            AnalysisAnalyzer.Bengali {
                Type = "bengali"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Brazilian with default values
        let brazilian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Brazilian {
                Type = "brazilian"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Bulgarian with default values
        let bulgarian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Bulgarian {
                Type = "bulgarian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Catalan with default values
        let catalan () : AnalysisAnalyzer =
            AnalysisAnalyzer.Catalan {
                Type = "catalan"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Chinese with default values
        let chinese () : AnalysisAnalyzer =
            AnalysisAnalyzer.Chinese {
                Type = "chinese"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Cjk with default values
        let cjk () : AnalysisAnalyzer =
            AnalysisAnalyzer.Cjk {
                Type = "cjk"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Custom with default values
        let custom () : AnalysisAnalyzer =
            AnalysisAnalyzer.Custom {
                Type = "custom"
                CharFilter = Option.None
                Filter = Option.None
                PositionIncrementGap = Option.None
                PositionOffsetGap = Option.None
                Tokenizer = ""
            }
        /// Creates a Czech with default values
        let czech () : AnalysisAnalyzer =
            AnalysisAnalyzer.Czech {
                Type = "czech"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Danish with default values
        let danish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Danish {
                Type = "danish"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Dutch with default values
        let dutch () : AnalysisAnalyzer =
            AnalysisAnalyzer.Dutch {
                Type = "dutch"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a English with default values
        let english () : AnalysisAnalyzer =
            AnalysisAnalyzer.English {
                Type = "english"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Estonian with default values
        let estonian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Estonian {
                Type = "estonian"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Fingerprint with default values
        let fingerprint () : AnalysisAnalyzer =
            AnalysisAnalyzer.Fingerprint {
                Type = "fingerprint"
                Version = Option.None
                MaxOutputSize = Option.None
                Separator = Option.None
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Finnish with default values
        let finnish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Finnish {
                Type = "finnish"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a French with default values
        let french () : AnalysisAnalyzer =
            AnalysisAnalyzer.French {
                Type = "french"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Galician with default values
        let galician () : AnalysisAnalyzer =
            AnalysisAnalyzer.Galician {
                Type = "galician"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a German with default values
        let german () : AnalysisAnalyzer =
            AnalysisAnalyzer.German {
                Type = "german"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Greek with default values
        let greek () : AnalysisAnalyzer =
            AnalysisAnalyzer.Greek {
                Type = "greek"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Hindi with default values
        let hindi () : AnalysisAnalyzer =
            AnalysisAnalyzer.Hindi {
                Type = "hindi"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Hungarian with default values
        let hungarian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Hungarian {
                Type = "hungarian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a IcuAnalyzer with default values
        let icuAnalyzer () : AnalysisAnalyzer =
            AnalysisAnalyzer.IcuAnalyzer {
                Type = "icu_analyzer"
                Method = Unchecked.defaultof<_>
                Mode = Unchecked.defaultof<_>
            }
        /// Creates a Indonesian with default values
        let indonesian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Indonesian {
                Type = "indonesian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Irish with default values
        let irish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Irish {
                Type = "irish"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Italian with default values
        let italian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Italian {
                Type = "italian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Keyword with default values
        let keyword () : AnalysisAnalyzer =
            AnalysisAnalyzer.Keyword {
                Type = "keyword"
                Version = Option.None
            }
        /// Creates a Kuromoji with default values
        let kuromoji () : AnalysisAnalyzer =
            AnalysisAnalyzer.Kuromoji {
                Type = "kuromoji"
                Mode = Option.None
                UserDictionary = Option.None
            }
        /// Creates a Latvian with default values
        let latvian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Latvian {
                Type = "latvian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Lithuanian with default values
        let lithuanian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Lithuanian {
                Type = "lithuanian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Nori with default values
        let nori () : AnalysisAnalyzer =
            AnalysisAnalyzer.Nori {
                Type = "nori"
                Version = Option.None
                DecompoundMode = Option.None
                Stoptags = Option.None
                UserDictionary = Option.None
            }
        /// Creates a Norwegian with default values
        let norwegian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Norwegian {
                Type = "norwegian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Pattern with default values
        let pattern () : AnalysisAnalyzer =
            AnalysisAnalyzer.Pattern {
                Type = "pattern"
                Version = Option.None
                Flags = Option.None
                Lowercase = Option.None
                Pattern = Option.None
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Persian with default values
        let persian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Persian {
                Type = "persian"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Portuguese with default values
        let portuguese () : AnalysisAnalyzer =
            AnalysisAnalyzer.Portuguese {
                Type = "portuguese"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Romanian with default values
        let romanian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Romanian {
                Type = "romanian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Russian with default values
        let russian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Russian {
                Type = "russian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Serbian with default values
        let serbian () : AnalysisAnalyzer =
            AnalysisAnalyzer.Serbian {
                Type = "serbian"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Simple with default values
        let simple () : AnalysisAnalyzer =
            AnalysisAnalyzer.Simple {
                Type = "simple"
                Version = Option.None
            }
        /// Creates a Snowball with default values
        let snowball () : AnalysisAnalyzer =
            AnalysisAnalyzer.Snowball {
                Type = "snowball"
                Version = Option.None
                Language = Unchecked.defaultof<_>
                Stopwords = Option.None
            }
        /// Creates a Sorani with default values
        let sorani () : AnalysisAnalyzer =
            AnalysisAnalyzer.Sorani {
                Type = "sorani"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Spanish with default values
        let spanish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Spanish {
                Type = "spanish"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Standard with default values
        let standard () : AnalysisAnalyzer =
            AnalysisAnalyzer.Standard {
                Type = "standard"
                MaxTokenLength = Option.None
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Stop with default values
        let stop () : AnalysisAnalyzer =
            AnalysisAnalyzer.Stop {
                Type = "stop"
                Version = Option.None
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Swedish with default values
        let swedish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Swedish {
                Type = "swedish"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Thai with default values
        let thai () : AnalysisAnalyzer =
            AnalysisAnalyzer.Thai {
                Type = "thai"
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Turkish with default values
        let turkish () : AnalysisAnalyzer =
            AnalysisAnalyzer.Turkish {
                Type = "turkish"
                Stopwords = Option.None
                StopwordsPath = Option.None
                StemExclusion = Option.None
            }
        /// Creates a Whitespace with default values
        let whitespace () : AnalysisAnalyzer =
            AnalysisAnalyzer.Whitespace {
                Type = "whitespace"
                Version = Option.None
            }

    /// Smart constructors for AnalysisNormalizer
    [<RequireQualifiedAccess>]
    module AnalysisNormalizerBuilders =
        /// Creates a Custom with default values
        let custom () : AnalysisNormalizer =
            AnalysisNormalizer.Custom {
                Type = "custom"
                CharFilter = Option.None
                Filter = Option.None
            }
        /// Creates a Lowercase with default values
        let lowercase () : AnalysisNormalizer =
            AnalysisNormalizer.Lowercase {
                Type = "lowercase"
            }

    /// Smart constructors for AnalysisCharFilterDefinition
    [<RequireQualifiedAccess>]
    module AnalysisCharFilterDefinitionBuilders =
        /// Creates a HtmlStrip with default values
        let htmlStrip () : AnalysisCharFilterDefinition =
            AnalysisCharFilterDefinition.HtmlStrip {
                Version = Option.None
                Type = "html_strip"
                EscapedTags = Option.None
            }
        /// Creates a IcuNormalizer with default values
        let icuNormalizer () : AnalysisCharFilterDefinition =
            AnalysisCharFilterDefinition.IcuNormalizer {
                Version = Option.None
                Type = "icu_normalizer"
                Mode = Option.None
                Name = Option.None
                UnicodeSetFilter = Option.None
            }
        /// Creates a KuromojiIterationMark with default values
        let kuromojiIterationMark () : AnalysisCharFilterDefinition =
            AnalysisCharFilterDefinition.KuromojiIterationMark {
                Version = Option.None
                Type = "kuromoji_iteration_mark"
                NormalizeKana = false
                NormalizeKanji = false
            }
        /// Creates a Mapping with default values
        let mapping () : AnalysisCharFilterDefinition =
            AnalysisCharFilterDefinition.Mapping {
                Version = Option.None
                Type = "mapping"
                Mappings = Option.None
                MappingsPath = Option.None
            }
        /// Creates a PatternReplace with default values
        let patternReplace () : AnalysisCharFilterDefinition =
            AnalysisCharFilterDefinition.PatternReplace {
                Version = Option.None
                Type = "pattern_replace"
                Flags = Option.None
                Pattern = ""
                Replacement = Option.None
            }

    /// Smart constructors for AnalysisTokenFilterDefinition
    [<RequireQualifiedAccess>]
    module AnalysisTokenFilterDefinitionBuilders =
        /// Creates a Apostrophe with default values
        let apostrophe () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Apostrophe {
                Version = Option.None
                Type = "apostrophe"
            }
        /// Creates a ArabicNormalization with default values
        let arabicNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.ArabicNormalization {
                Version = Option.None
                Type = "arabic_normalization"
            }
        /// Creates a ArabicStem with default values
        let arabicStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.ArabicStem {
                Version = Option.None
                Type = "arabic_stem"
            }
        /// Creates a Asciifolding with default values
        let asciifolding () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Asciifolding {
                Version = Option.None
                Type = "asciifolding"
                PreserveOriginal = Option.None
            }
        /// Creates a BengaliNormalization with default values
        let bengaliNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.BengaliNormalization {
                Version = Option.None
                Type = "bengali_normalization"
            }
        /// Creates a BrazilianStem with default values
        let brazilianStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.BrazilianStem {
                Version = Option.None
                Type = "brazilian_stem"
            }
        /// Creates a CjkBigram with default values
        let cjkBigram () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.CjkBigram {
                Version = Option.None
                Type = "cjk_bigram"
                IgnoredScripts = Option.None
                OutputUnigrams = Option.None
            }
        /// Creates a CjkWidth with default values
        let cjkWidth () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.CjkWidth {
                Version = Option.None
                Type = "cjk_width"
            }
        /// Creates a Classic with default values
        let classic () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Classic {
                Version = Option.None
                Type = "classic"
            }
        /// Creates a CommonGrams with default values
        let commonGrams () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.CommonGrams {
                Version = Option.None
                Type = "common_grams"
                CommonWords = Option.None
                CommonWordsPath = Option.None
                IgnoreCase = Option.None
                QueryMode = Option.None
            }
        /// Creates a Condition with default values
        let condition () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Condition {
                Version = Option.None
                Type = "condition"
                Filter = [||]
                Script = Unchecked.defaultof<_>
            }
        /// Creates a CzechStem with default values
        let czechStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.CzechStem {
                Version = Option.None
                Type = "czech_stem"
            }
        /// Creates a DecimalDigit with default values
        let decimalDigit () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.DecimalDigit {
                Version = Option.None
                Type = "decimal_digit"
            }
        /// Creates a DelimitedPayload with default values
        let delimitedPayload () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.DelimitedPayload {
                Version = Option.None
                Type = "delimited_payload"
                Delimiter = Option.None
                Encoding = Option.None
            }
        /// Creates a DictionaryDecompounder with default values
        let dictionaryDecompounder () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.DictionaryDecompounder {
                Version = Option.None
                MaxSubwordSize = Option.None
                MinSubwordSize = Option.None
                MinWordSize = Option.None
                OnlyLongestMatch = Option.None
                WordList = Option.None
                WordListPath = Option.None
                Type = "dictionary_decompounder"
            }
        /// Creates a DutchStem with default values
        let dutchStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.DutchStem {
                Version = Option.None
                Type = "dutch_stem"
            }
        /// Creates a EdgeNgram with default values
        let edgeNgram () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.EdgeNgram {
                Version = Option.None
                Type = "edge_ngram"
                MaxGram = Option.None
                MinGram = Option.None
                Side = Option.None
                PreserveOriginal = Option.None
            }
        /// Creates a Elision with default values
        let elision () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Elision {
                Version = Option.None
                Type = "elision"
                Articles = Option.None
                ArticlesPath = Option.None
                ArticlesCase = Option.None
            }
        /// Creates a Fingerprint with default values
        let fingerprint () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Fingerprint {
                Version = Option.None
                Type = "fingerprint"
                MaxOutputSize = Option.None
                Separator = Option.None
            }
        /// Creates a FlattenGraph with default values
        let flattenGraph () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.FlattenGraph {
                Version = Option.None
                Type = "flatten_graph"
            }
        /// Creates a FrenchStem with default values
        let frenchStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.FrenchStem {
                Version = Option.None
                Type = "french_stem"
            }
        /// Creates a GermanNormalization with default values
        let germanNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.GermanNormalization {
                Version = Option.None
                Type = "german_normalization"
            }
        /// Creates a GermanStem with default values
        let germanStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.GermanStem {
                Version = Option.None
                Type = "german_stem"
            }
        /// Creates a HindiNormalization with default values
        let hindiNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.HindiNormalization {
                Version = Option.None
                Type = "hindi_normalization"
            }
        /// Creates a Hunspell with default values
        let hunspell () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Hunspell {
                Version = Option.None
                Type = "hunspell"
                Dedup = Option.None
                Dictionary = Option.None
                Locale = ""
                LongestOnly = Option.None
            }
        /// Creates a HyphenationDecompounder with default values
        let hyphenationDecompounder () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.HyphenationDecompounder {
                Version = Option.None
                MaxSubwordSize = Option.None
                MinSubwordSize = Option.None
                MinWordSize = Option.None
                OnlyLongestMatch = Option.None
                WordList = Option.None
                WordListPath = Option.None
                Type = "hyphenation_decompounder"
                HyphenationPatternsPath = ""
                NoSubMatches = Option.None
                NoOverlappingMatches = Option.None
            }
        /// Creates a IcuCollation with default values
        let icuCollation () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.IcuCollation {
                Version = Option.None
                Type = "icu_collation"
                Alternate = Option.None
                CaseFirst = Option.None
                CaseLevel = Option.None
                Country = Option.None
                Decomposition = Option.None
                HiraganaQuaternaryMode = Option.None
                Language = Option.None
                Numeric = Option.None
                Rules = Option.None
                Strength = Option.None
                VariableTop = Option.None
                Variant = Option.None
            }
        /// Creates a IcuFolding with default values
        let icuFolding () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.IcuFolding {
                Version = Option.None
                Type = "icu_folding"
                UnicodeSetFilter = ""
            }
        /// Creates a IcuNormalizer with default values
        let icuNormalizer () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.IcuNormalizer {
                Version = Option.None
                Type = "icu_normalizer"
                Name = Unchecked.defaultof<_>
            }
        /// Creates a IcuTransform with default values
        let icuTransform () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.IcuTransform {
                Version = Option.None
                Type = "icu_transform"
                Dir = Option.None
                Id = ""
            }
        /// Creates a IndicNormalization with default values
        let indicNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.IndicNormalization {
                Version = Option.None
                Type = "indic_normalization"
            }
        /// Creates a JaStop with default values
        let jaStop () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.JaStop {
                Version = Option.None
                Type = "ja_stop"
                Stopwords = Option.None
            }
        /// Creates a Keep with default values
        let keep () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Keep {
                Version = Option.None
                Type = "keep"
                KeepWords = Option.None
                KeepWordsCase = Option.None
                KeepWordsPath = Option.None
            }
        /// Creates a KeepTypes with default values
        let keepTypes () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KeepTypes {
                Version = Option.None
                Type = "keep_types"
                Mode = Option.None
                Types = [||]
            }
        /// Creates a KeywordMarker with default values
        let keywordMarker () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KeywordMarker {
                Version = Option.None
                Type = "keyword_marker"
                IgnoreCase = Option.None
                Keywords = Option.None
                KeywordsPath = Option.None
                KeywordsPattern = Option.None
            }
        /// Creates a KeywordRepeat with default values
        let keywordRepeat () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KeywordRepeat {
                Version = Option.None
                Type = "keyword_repeat"
            }
        /// Creates a Kstem with default values
        let kstem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Kstem {
                Version = Option.None
                Type = "kstem"
            }
        /// Creates a KuromojiPartOfSpeech with default values
        let kuromojiPartOfSpeech () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KuromojiPartOfSpeech {
                Version = Option.None
                Type = "kuromoji_part_of_speech"
                Stoptags = [||]
            }
        /// Creates a KuromojiReadingform with default values
        let kuromojiReadingform () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KuromojiReadingform {
                Version = Option.None
                Type = "kuromoji_readingform"
                UseRomaji = false
            }
        /// Creates a KuromojiStemmer with default values
        let kuromojiStemmer () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.KuromojiStemmer {
                Version = Option.None
                Type = "kuromoji_stemmer"
                MinimumLength = 0.0
            }
        /// Creates a Length with default values
        let length () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Length {
                Version = Option.None
                Type = "length"
                Max = Option.None
                Min = Option.None
            }
        /// Creates a Limit with default values
        let limit () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Limit {
                Version = Option.None
                Type = "limit"
                ConsumeAllTokens = Option.None
                MaxTokenCount = Option.None
            }
        /// Creates a Lowercase with default values
        let lowercase () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Lowercase {
                Version = Option.None
                Type = "lowercase"
                Language = Option.None
            }
        /// Creates a MinHash with default values
        let minHash () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.MinHash {
                Version = Option.None
                Type = "min_hash"
                BucketCount = Option.None
                HashCount = Option.None
                HashSetSize = Option.None
                WithRotation = Option.None
            }
        /// Creates a Multiplexer with default values
        let multiplexer () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Multiplexer {
                Version = Option.None
                Type = "multiplexer"
                Filters = [||]
                PreserveOriginal = Option.None
            }
        /// Creates a Ngram with default values
        let ngram () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Ngram {
                Version = Option.None
                Type = "ngram"
                MaxGram = Option.None
                MinGram = Option.None
                PreserveOriginal = Option.None
            }
        /// Creates a NoriPartOfSpeech with default values
        let noriPartOfSpeech () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.NoriPartOfSpeech {
                Version = Option.None
                Type = "nori_part_of_speech"
                Stoptags = Option.None
            }
        /// Creates a PatternCapture with default values
        let patternCapture () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PatternCapture {
                Version = Option.None
                Type = "pattern_capture"
                Patterns = [||]
                PreserveOriginal = Option.None
            }
        /// Creates a PatternReplace with default values
        let patternReplace () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PatternReplace {
                Version = Option.None
                Type = "pattern_replace"
                All = Option.None
                Flags = Option.None
                Pattern = ""
                Replacement = Option.None
            }
        /// Creates a PersianNormalization with default values
        let persianNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PersianNormalization {
                Version = Option.None
                Type = "persian_normalization"
            }
        /// Creates a PersianStem with default values
        let persianStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PersianStem {
                Version = Option.None
                Type = "persian_stem"
            }
        /// Creates a Phonetic with default values
        let phonetic () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Phonetic {
                Version = Option.None
                Type = "phonetic"
                Encoder = Unchecked.defaultof<_>
                Languageset = Option.None
                MaxCodeLen = Option.None
                NameType = Option.None
                Replace = Option.None
                RuleType = Option.None
            }
        /// Creates a PorterStem with default values
        let porterStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PorterStem {
                Version = Option.None
                Type = "porter_stem"
            }
        /// Creates a PredicateTokenFilter with default values
        let predicateTokenFilter () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.PredicateTokenFilter {
                Version = Option.None
                Type = "predicate_token_filter"
                Script = Unchecked.defaultof<_>
            }
        /// Creates a RemoveDuplicates with default values
        let removeDuplicates () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.RemoveDuplicates {
                Version = Option.None
                Type = "remove_duplicates"
            }
        /// Creates a Reverse with default values
        let reverse () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Reverse {
                Version = Option.None
                Type = "reverse"
            }
        /// Creates a RussianStem with default values
        let russianStem () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.RussianStem {
                Version = Option.None
                Type = "russian_stem"
            }
        /// Creates a ScandinavianFolding with default values
        let scandinavianFolding () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.ScandinavianFolding {
                Version = Option.None
                Type = "scandinavian_folding"
            }
        /// Creates a ScandinavianNormalization with default values
        let scandinavianNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.ScandinavianNormalization {
                Version = Option.None
                Type = "scandinavian_normalization"
            }
        /// Creates a SerbianNormalization with default values
        let serbianNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.SerbianNormalization {
                Version = Option.None
                Type = "serbian_normalization"
            }
        /// Creates a Shingle with default values
        let shingle () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Shingle {
                Version = Option.None
                Type = "shingle"
                FillerToken = Option.None
                MaxShingleSize = Option.None
                MinShingleSize = Option.None
                OutputUnigrams = Option.None
                OutputUnigramsIfNoShingles = Option.None
                TokenSeparator = Option.None
            }
        /// Creates a Snowball with default values
        let snowball () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Snowball {
                Version = Option.None
                Type = "snowball"
                Language = Option.None
            }
        /// Creates a SoraniNormalization with default values
        let soraniNormalization () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.SoraniNormalization {
                Version = Option.None
                Type = "sorani_normalization"
            }
        /// Creates a Stemmer with default values
        let stemmer () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Stemmer {
                Version = Option.None
                Type = "stemmer"
                Language = Option.None
            }
        /// Creates a StemmerOverride with default values
        let stemmerOverride () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.StemmerOverride {
                Version = Option.None
                Type = "stemmer_override"
                Rules = Option.None
                RulesPath = Option.None
            }
        /// Creates a Stop with default values
        let stop () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Stop {
                Version = Option.None
                Type = "stop"
                IgnoreCase = Option.None
                RemoveTrailing = Option.None
                Stopwords = Option.None
                StopwordsPath = Option.None
            }
        /// Creates a Synonym with default values
        let synonym () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Synonym {
                Version = Option.None
                Expand = Option.None
                Format = Option.None
                Lenient = Option.None
                Synonyms = Option.None
                SynonymsPath = Option.None
                SynonymsSet = Option.None
                Tokenizer = Option.None
                Updateable = Option.None
                Type = "synonym"
            }
        /// Creates a SynonymGraph with default values
        let synonymGraph () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.SynonymGraph {
                Version = Option.None
                Expand = Option.None
                Format = Option.None
                Lenient = Option.None
                Synonyms = Option.None
                SynonymsPath = Option.None
                SynonymsSet = Option.None
                Tokenizer = Option.None
                Updateable = Option.None
                Type = "synonym_graph"
            }
        /// Creates a Trim with default values
        let trim () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Trim {
                Version = Option.None
                Type = "trim"
            }
        /// Creates a Truncate with default values
        let truncate () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Truncate {
                Version = Option.None
                Type = "truncate"
                Length = Option.None
            }
        /// Creates a Unique with default values
        let unique () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Unique {
                Version = Option.None
                Type = "unique"
                OnlyOnSamePosition = Option.None
            }
        /// Creates a Uppercase with default values
        let uppercase () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.Uppercase {
                Version = Option.None
                Type = "uppercase"
            }
        /// Creates a WordDelimiter with default values
        let wordDelimiter () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.WordDelimiter {
                Version = Option.None
                CatenateAll = Option.None
                CatenateNumbers = Option.None
                CatenateWords = Option.None
                GenerateNumberParts = Option.None
                GenerateWordParts = Option.None
                PreserveOriginal = Option.None
                ProtectedWords = Option.None
                ProtectedWordsPath = Option.None
                SplitOnCaseChange = Option.None
                SplitOnNumerics = Option.None
                StemEnglishPossessive = Option.None
                TypeTable = Option.None
                TypeTablePath = Option.None
                Type = "word_delimiter"
            }
        /// Creates a WordDelimiterGraph with default values
        let wordDelimiterGraph () : AnalysisTokenFilterDefinition =
            AnalysisTokenFilterDefinition.WordDelimiterGraph {
                Version = Option.None
                CatenateAll = Option.None
                CatenateNumbers = Option.None
                CatenateWords = Option.None
                GenerateNumberParts = Option.None
                GenerateWordParts = Option.None
                PreserveOriginal = Option.None
                ProtectedWords = Option.None
                ProtectedWordsPath = Option.None
                SplitOnCaseChange = Option.None
                SplitOnNumerics = Option.None
                StemEnglishPossessive = Option.None
                TypeTable = Option.None
                TypeTablePath = Option.None
                Type = "word_delimiter_graph"
                AdjustOffsets = Option.None
                IgnoreKeywords = Option.None
            }

    /// Smart constructors for AnalysisTokenizerDefinition
    [<RequireQualifiedAccess>]
    module AnalysisTokenizerDefinitionBuilders =
        /// Creates a CharGroup with default values
        let charGroup () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.CharGroup {
                Version = Option.None
                Type = "char_group"
                TokenizeOnChars = [||]
                MaxTokenLength = Option.None
            }
        /// Creates a Classic with default values
        let classic () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Classic {
                Version = Option.None
                Type = "classic"
                MaxTokenLength = Option.None
            }
        /// Creates a EdgeNgram with default values
        let edgeNgram () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.EdgeNgram {
                Version = Option.None
                Type = "edge_ngram"
                CustomTokenChars = Option.None
                MaxGram = Option.None
                MinGram = Option.None
                TokenChars = Option.None
            }
        /// Creates a IcuTokenizer with default values
        let icuTokenizer () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.IcuTokenizer {
                Version = Option.None
                Type = "icu_tokenizer"
                RuleFiles = ""
            }
        /// Creates a Keyword with default values
        let keyword () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Keyword {
                Version = Option.None
                Type = "keyword"
                BufferSize = Option.None
            }
        /// Creates a KuromojiTokenizer with default values
        let kuromojiTokenizer () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.KuromojiTokenizer {
                Version = Option.None
                Type = "kuromoji_tokenizer"
                DiscardPunctuation = Option.None
                Mode = Unchecked.defaultof<_>
                NbestCost = Option.None
                NbestExamples = Option.None
                UserDictionary = Option.None
                UserDictionaryRules = Option.None
                DiscardCompoundToken = Option.None
            }
        /// Creates a Letter with default values
        let letter () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Letter {
                Version = Option.None
                Type = "letter"
            }
        /// Creates a Lowercase with default values
        let lowercase () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Lowercase {
                Version = Option.None
                Type = "lowercase"
            }
        /// Creates a Ngram with default values
        let ngram () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Ngram {
                Version = Option.None
                Type = "ngram"
                CustomTokenChars = Option.None
                MaxGram = Option.None
                MinGram = Option.None
                TokenChars = Option.None
            }
        /// Creates a NoriTokenizer with default values
        let noriTokenizer () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.NoriTokenizer {
                Version = Option.None
                Type = "nori_tokenizer"
                DecompoundMode = Option.None
                DiscardPunctuation = Option.None
                UserDictionary = Option.None
                UserDictionaryRules = Option.None
            }
        /// Creates a PathHierarchy with default values
        let pathHierarchy () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.PathHierarchy {
                Version = Option.None
                Type = "path_hierarchy"
                BufferSize = Option.None
                Delimiter = Option.None
                Replacement = Option.None
                Reverse = Option.None
                Skip = Option.None
            }
        /// Creates a Pattern with default values
        let pattern () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Pattern {
                Version = Option.None
                Type = "pattern"
                Flags = Option.None
                Group = Option.None
                Pattern = Option.None
            }
        /// Creates a SimplePattern with default values
        let simplePattern () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.SimplePattern {
                Version = Option.None
                Type = "simple_pattern"
                Pattern = Option.None
            }
        /// Creates a SimplePatternSplit with default values
        let simplePatternSplit () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.SimplePatternSplit {
                Version = Option.None
                Type = "simple_pattern_split"
                Pattern = Option.None
            }
        /// Creates a Standard with default values
        let standard () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Standard {
                Version = Option.None
                Type = "standard"
                MaxTokenLength = Option.None
            }
        /// Creates a Thai with default values
        let thai () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Thai {
                Version = Option.None
                Type = "thai"
            }
        /// Creates a UaxUrlEmail with default values
        let uaxUrlEmail () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.UaxUrlEmail {
                Version = Option.None
                Type = "uax_url_email"
                MaxTokenLength = Option.None
            }
        /// Creates a Whitespace with default values
        let whitespace () : AnalysisTokenizerDefinition =
            AnalysisTokenizerDefinition.Whitespace {
                Version = Option.None
                Type = "whitespace"
                MaxTokenLength = Option.None
            }

    /// Smart constructors for TypesSettingsSimilarity
    [<RequireQualifiedAccess>]
    module TypesSettingsSimilarityBuilders =
        /// Creates a BM25 with default values
        let bM25 () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.BM25 {
                Type = "BM25"
                B = Option.None
                DiscountOverlaps = Option.None
                K1 = Option.None
            }
        /// Creates a DFI with default values
        let dFI () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.DFI {
                Type = "DFI"
                IndependenceMeasure = Unchecked.defaultof<_>
            }
        /// Creates a DFR with default values
        let dFR () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.DFR {
                Type = "DFR"
                AfterEffect = Unchecked.defaultof<_>
                BasicModel = Unchecked.defaultof<_>
                Normalization = Unchecked.defaultof<_>
            }
        /// Creates a IB with default values
        let iB () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.IB {
                Type = "IB"
                Distribution = Unchecked.defaultof<_>
                Lambda = Unchecked.defaultof<_>
                Normalization = Unchecked.defaultof<_>
            }
        /// Creates a LMDirichlet with default values
        let lMDirichlet () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.LMDirichlet {
                Type = "LMDirichlet"
                Mu = Option.None
            }
        /// Creates a LMJelinekMercer with default values
        let lMJelinekMercer () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.LMJelinekMercer {
                Type = "LMJelinekMercer"
                Lambda = Option.None
            }
        /// Creates a Boolean with default values
        let boolean () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.Boolean {
                Type = "boolean"
            }
        /// Creates a Scripted with default values
        let scripted () : TypesSettingsSimilarity =
            TypesSettingsSimilarity.Scripted {
                Type = "scripted"
                Script = Unchecked.defaultof<_>
                WeightScript = Option.None
            }

    /// Smart constructors for MappingProperty
    [<RequireQualifiedAccess>]
    module MappingPropertyBuilders =
        /// Creates a AggregateMetricDouble with default values
        let aggregateMetricDouble () : MappingProperty =
            MappingProperty.AggregateMetricDouble {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Type = "aggregate_metric_double"
                DefaultMetric = ""
                IgnoreMalformed = Option.None
                Metrics = [||]
                TimeSeriesMetric = Option.None
            }
        /// Creates a Alias with default values
        let alias () : MappingProperty =
            MappingProperty.Alias {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Path = Option.None
                Type = "alias"
            }
        /// Creates a Binary with default values
        let binary () : MappingProperty =
            MappingProperty.Binary {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Type = "binary"
            }
        /// Creates a Boolean with default values
        let boolean () : MappingProperty =
            MappingProperty.Boolean {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Fielddata = Option.None
                Index = Option.None
                NullValue = Option.None
                IgnoreMalformed = Option.None
                Script = Option.None
                OnScriptError = Option.None
                TimeSeriesDimension = Option.None
                Type = "boolean"
            }
        /// Creates a Byte with default values
        let byte () : MappingProperty =
            MappingProperty.Byte {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "byte"
                NullValue = Option.None
            }
        /// Creates a Completion with default values
        let completion () : MappingProperty =
            MappingProperty.Completion {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Analyzer = Option.None
                Contexts = Option.None
                MaxInputLength = Option.None
                PreservePositionIncrements = Option.None
                PreserveSeparators = Option.None
                SearchAnalyzer = Option.None
                Type = "completion"
            }
        /// Creates a ConstantKeyword with default values
        let constantKeyword () : MappingProperty =
            MappingProperty.ConstantKeyword {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Value = Option.None
                Type = "constant_keyword"
            }
        /// Creates a CountedKeyword with default values
        let countedKeyword () : MappingProperty =
            MappingProperty.CountedKeyword {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Type = "counted_keyword"
                Index = Option.None
            }
        /// Creates a Date with default values
        let date () : MappingProperty =
            MappingProperty.Date {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Fielddata = Option.None
                Format = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                Script = Option.None
                OnScriptError = Option.None
                NullValue = Option.None
                PrecisionStep = Option.None
                Locale = Option.None
                Type = "date"
            }
        /// Creates a DateNanos with default values
        let dateNanos () : MappingProperty =
            MappingProperty.DateNanos {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Format = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                Script = Option.None
                OnScriptError = Option.None
                NullValue = Option.None
                PrecisionStep = Option.None
                Type = "date_nanos"
            }
        /// Creates a DateRange with default values
        let dateRange () : MappingProperty =
            MappingProperty.DateRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Format = Option.None
                Type = "date_range"
            }
        /// Creates a DenseVector with default values
        let denseVector () : MappingProperty =
            MappingProperty.DenseVector {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Type = "dense_vector"
                Dims = Option.None
                ElementType = Option.None
                Index = Option.None
                IndexOptions = Option.None
                Similarity = Option.None
            }
        /// Creates a Double with default values
        let double () : MappingProperty =
            MappingProperty.Double {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "double"
                NullValue = Option.None
            }
        /// Creates a DoubleRange with default values
        let doubleRange () : MappingProperty =
            MappingProperty.DoubleRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Type = "double_range"
            }
        /// Creates a ExponentialHistogram with default values
        let exponentialHistogram () : MappingProperty =
            MappingProperty.ExponentialHistogram {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                TimeSeriesMetric = Option.None
                Type = "exponential_histogram"
            }
        /// Creates a Flattened with default values
        let flattened () : MappingProperty =
            MappingProperty.Flattened {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Boost = Option.None
                DepthLimit = Option.None
                DocValues = Option.None
                EagerGlobalOrdinals = Option.None
                Index = Option.None
                IndexOptions = Option.None
                NullValue = Option.None
                Similarity = Option.None
                SplitQueriesOnWhitespace = Option.None
                TimeSeriesDimensions = Option.None
                Type = "flattened"
            }
        /// Creates a Float with default values
        let float () : MappingProperty =
            MappingProperty.Float {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "float"
                NullValue = Option.None
            }
        /// Creates a FloatRange with default values
        let floatRange () : MappingProperty =
            MappingProperty.FloatRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Type = "float_range"
            }
        /// Creates a GeoPoint with default values
        let geoPoint () : MappingProperty =
            MappingProperty.GeoPoint {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                IgnoreMalformed = Option.None
                IgnoreZValue = Option.None
                NullValue = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                Type = "geo_point"
                TimeSeriesMetric = Option.None
            }
        /// Creates a GeoShape with default values
        let geoShape () : MappingProperty =
            MappingProperty.GeoShape {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                IgnoreZValue = Option.None
                Index = Option.None
                Orientation = Option.None
                Strategy = Option.None
                Type = "geo_shape"
            }
        /// Creates a HalfFloat with default values
        let halfFloat () : MappingProperty =
            MappingProperty.HalfFloat {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "half_float"
                NullValue = Option.None
            }
        /// Creates a Histogram with default values
        let histogram () : MappingProperty =
            MappingProperty.Histogram {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                IgnoreMalformed = Option.None
                TimeSeriesMetric = Option.None
                Type = "histogram"
            }
        /// Creates a IcuCollationKeyword with default values
        let icuCollationKeyword () : MappingProperty =
            MappingProperty.IcuCollationKeyword {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Type = "icu_collation_keyword"
                Norms = Option.None
                IndexOptions = Option.None
                Index = Option.None
                NullValue = Option.None
                Rules = Option.None
                Language = Option.None
                Country = Option.None
                Variant = Option.None
                Strength = Option.None
                Decomposition = Option.None
                Alternate = Option.None
                CaseLevel = Option.None
                CaseFirst = Option.None
                Numeric = Option.None
                VariableTop = Option.None
                HiraganaQuaternaryMode = Option.None
            }
        /// Creates a Integer with default values
        let integer () : MappingProperty =
            MappingProperty.Integer {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "integer"
                NullValue = Option.None
            }
        /// Creates a IntegerRange with default values
        let integerRange () : MappingProperty =
            MappingProperty.IntegerRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Type = "integer_range"
            }
        /// Creates a Ip with default values
        let ip () : MappingProperty =
            MappingProperty.Ip {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Index = Option.None
                IgnoreMalformed = Option.None
                NullValue = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesDimension = Option.None
                Type = "ip"
            }
        /// Creates a IpRange with default values
        let ipRange () : MappingProperty =
            MappingProperty.IpRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Type = "ip_range"
            }
        /// Creates a Join with default values
        let join () : MappingProperty =
            MappingProperty.Join {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Relations = Option.None
                EagerGlobalOrdinals = Option.None
                Type = "join"
            }
        /// Creates a Keyword with default values
        let keyword () : MappingProperty =
            MappingProperty.Keyword {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                EagerGlobalOrdinals = Option.None
                Index = Option.None
                IndexOptions = Option.None
                Script = Option.None
                OnScriptError = Option.None
                Normalizer = Option.None
                Norms = Option.None
                NullValue = Option.None
                Similarity = Option.None
                SplitQueriesOnWhitespace = Option.None
                TimeSeriesDimension = Option.None
                Type = "keyword"
            }
        /// Creates a Long with default values
        let long () : MappingProperty =
            MappingProperty.Long {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "long"
                NullValue = Option.None
            }
        /// Creates a LongRange with default values
        let longRange () : MappingProperty =
            MappingProperty.LongRange {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                Index = Option.None
                Type = "long_range"
            }
        /// Creates a MatchOnlyText with default values
        let matchOnlyText () : MappingProperty =
            MappingProperty.MatchOnlyText {
                Type = "match_only_text"
                Fields = Option.None
                Meta = Option.None
                CopyTo = Option.None
            }
        /// Creates a Murmur3 with default values
        let murmur3 () : MappingProperty =
            MappingProperty.Murmur3 {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Type = "murmur3"
            }
        /// Creates a Nested with default values
        let nested () : MappingProperty =
            MappingProperty.Nested {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                Enabled = Option.None
                IncludeInParent = Option.None
                IncludeInRoot = Option.None
                Type = "nested"
            }
        /// Creates a Object with default values
        let object () : MappingProperty =
            MappingProperty.Object {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                Enabled = Option.None
                Subobjects = Option.None
                Type = Some "object"
            }
        /// Creates a Passthrough with default values
        let passthrough () : MappingProperty =
            MappingProperty.Passthrough {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                Type = Some "passthrough"
                Enabled = Option.None
                Priority = Option.None
                TimeSeriesDimension = Option.None
            }
        /// Creates a Percolator with default values
        let percolator () : MappingProperty =
            MappingProperty.Percolator {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Type = "percolator"
            }
        /// Creates a Point with default values
        let point () : MappingProperty =
            MappingProperty.Point {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                IgnoreMalformed = Option.None
                IgnoreZValue = Option.None
                NullValue = Option.None
                Type = "point"
            }
        /// Creates a RankFeature with default values
        let rankFeature () : MappingProperty =
            MappingProperty.RankFeature {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                PositiveScoreImpact = Option.None
                Type = "rank_feature"
            }
        /// Creates a RankFeatures with default values
        let rankFeatures () : MappingProperty =
            MappingProperty.RankFeatures {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                PositiveScoreImpact = Option.None
                Type = "rank_features"
            }
        /// Creates a RankVectors with default values
        let rankVectors () : MappingProperty =
            MappingProperty.RankVectors {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Type = "rank_vectors"
                ElementType = Option.None
                Dims = Option.None
            }
        /// Creates a ScaledFloat with default values
        let scaledFloat () : MappingProperty =
            MappingProperty.ScaledFloat {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "scaled_float"
                NullValue = Option.None
                ScalingFactor = Option.None
            }
        /// Creates a SearchAsYouType with default values
        let searchAsYouType () : MappingProperty =
            MappingProperty.SearchAsYouType {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                Analyzer = Option.None
                Index = Option.None
                IndexOptions = Option.None
                MaxShingleSize = Option.None
                Norms = Option.None
                SearchAnalyzer = Option.None
                SearchQuoteAnalyzer = Option.None
                Similarity = Option.None
                TermVector = Option.None
                Type = "search_as_you_type"
            }
        /// Creates a SemanticText with default values
        let semanticText () : MappingProperty =
            MappingProperty.SemanticText {
                Type = "semantic_text"
                Meta = Option.None
                InferenceId = Option.None
                SearchInferenceId = Option.None
                IndexOptions = Option.None
                ChunkingSettings = Option.None
                Fields = Option.None
            }
        /// Creates a Shape with default values
        let shape () : MappingProperty =
            MappingProperty.Shape {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                IgnoreZValue = Option.None
                Orientation = Option.None
                Type = "shape"
            }
        /// Creates a Short with default values
        let short () : MappingProperty =
            MappingProperty.Short {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "short"
                NullValue = Option.None
            }
        /// Creates a SparseVector with default values
        let sparseVector () : MappingProperty =
            MappingProperty.SparseVector {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                Store = Option.None
                Type = "sparse_vector"
                IndexOptions = Option.None
            }
        /// Creates a Text with default values
        let text () : MappingProperty =
            MappingProperty.Text {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                Analyzer = Option.None
                Boost = Option.None
                EagerGlobalOrdinals = Option.None
                Fielddata = Option.None
                FielddataFrequencyFilter = Option.None
                Index = Option.None
                IndexOptions = Option.None
                IndexPhrases = Option.None
                IndexPrefixes = Option.None
                Norms = Option.None
                PositionIncrementGap = Option.None
                SearchAnalyzer = Option.None
                SearchQuoteAnalyzer = Option.None
                Similarity = Option.None
                TermVector = Option.None
                Type = "text"
            }
        /// Creates a TokenCount with default values
        let tokenCount () : MappingProperty =
            MappingProperty.TokenCount {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Analyzer = Option.None
                Boost = Option.None
                Index = Option.None
                NullValue = Option.None
                EnablePositionIncrements = Option.None
                Type = "token_count"
            }
        /// Creates a UnsignedLong with default values
        let unsignedLong () : MappingProperty =
            MappingProperty.UnsignedLong {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Boost = Option.None
                Coerce = Option.None
                IgnoreMalformed = Option.None
                Index = Option.None
                OnScriptError = Option.None
                Script = Option.None
                TimeSeriesMetric = Option.None
                TimeSeriesDimension = Option.None
                Type = "unsigned_long"
                NullValue = Option.None
            }
        /// Creates a Version with default values
        let version () : MappingProperty =
            MappingProperty.Version {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Type = "version"
            }
        /// Creates a Wildcard with default values
        let wildcard () : MappingProperty =
            MappingProperty.Wildcard {
                Meta = Option.None
                Properties = Option.None
                IgnoreAbove = Option.None
                Dynamic = Option.None
                Fields = Option.None
                SyntheticSourceKeep = Option.None
                CopyTo = Option.None
                Store = Option.None
                DocValues = Option.None
                Type = "wildcard"
                NullValue = Option.None
            }

    /// Smart constructors for RemoteInfoClusterRemoteInfo
    [<RequireQualifiedAccess>]
    module RemoteInfoClusterRemoteInfoBuilders =
        /// Creates a Proxy with default values
        let proxy () : RemoteInfoClusterRemoteInfo =
            RemoteInfoClusterRemoteInfo.Proxy {
                Mode = "proxy"
                Connected = false
                InitialConnectTimeout = Unchecked.defaultof<_>
                SkipUnavailable = false
                ProxyAddress = ""
                ServerName = ""
                NumProxySocketsConnected = 0.0
                MaxProxySocketConnections = 0.0
                ClusterCredentials = Option.None
            }
        /// Creates a Sniff with default values
        let sniff () : RemoteInfoClusterRemoteInfo =
            RemoteInfoClusterRemoteInfo.Sniff {
                Mode = "sniff"
                Connected = false
                MaxConnectionsPerCluster = 0.0
                NumNodesConnected = 0.0
                InitialConnectTimeout = Unchecked.defaultof<_>
                SkipUnavailable = false
                Seeds = [||]
            }

    /// Smart constructors for TypesValidation
    [<RequireQualifiedAccess>]
    module TypesValidationBuilders =
        /// Creates a GreaterThan with default values
        let greaterThan () : TypesValidation =
            TypesValidation.GreaterThan {
                Type = "greater_than"
                Constraint = 0.0
            }
        /// Creates a IncludedIn with default values
        let includedIn () : TypesValidation =
            TypesValidation.IncludedIn {
                Type = "included_in"
                Constraint = [||]
            }
        /// Creates a LessThan with default values
        let lessThan () : TypesValidation =
            TypesValidation.LessThan {
                Type = "less_than"
                Constraint = 0.0
            }
        /// Creates a ListType with default values
        let listType () : TypesValidation =
            TypesValidation.ListType {
                Type = "list_type"
                Constraint = ""
            }
        /// Creates a Regex with default values
        let regex () : TypesValidation =
            TypesValidation.Regex {
                Type = "regex"
                Constraint = ""
            }

    /// Smart constructors for ExplainLifecycleLifecycleExplain
    [<RequireQualifiedAccess>]
    module ExplainLifecycleLifecycleExplainBuilders =
        /// Creates a False with default values
        let ``false`` () : ExplainLifecycleLifecycleExplain =
            ExplainLifecycleLifecycleExplain.False {
                Index = Unchecked.defaultof<_>
                Managed = "false"
            }
        /// Creates a True with default values
        let ``true`` () : ExplainLifecycleLifecycleExplain =
            ExplainLifecycleLifecycleExplain.True {
                Action = Option.None
                ActionTime = Option.None
                ActionTimeMillis = Option.None
                Age = Option.None
                AgeInMillis = Option.None
                FailedStep = Option.None
                FailedStepRetryCount = Option.None
                Index = Unchecked.defaultof<_>
                IndexCreationDate = Option.None
                IndexCreationDateMillis = Option.None
                IsAutoRetryableError = Option.None
                LifecycleDate = Option.None
                LifecycleDateMillis = Option.None
                Managed = "true"
                Phase = Option.None
                PhaseTime = Option.None
                PhaseTimeMillis = Option.None
                Policy = Option.None
                PreviousStepInfo = Option.None
                RepositoryName = Option.None
                SnapshotName = Option.None
                ShrinkIndexName = Option.None
                Step = Option.None
                StepInfo = Option.None
                StepTime = Option.None
                StepTimeMillis = Option.None
                PhaseExecution = Option.None
                TimeSinceIndexCreation = Option.None
                Skip = false
            }

    /// Smart constructors for TypesRepository
    [<RequireQualifiedAccess>]
    module TypesRepositoryBuilders =
        /// Creates a Azure with default values
        let azure () : TypesRepository =
            TypesRepository.Azure {
                Uuid = Option.None
                Type = "azure"
                Settings = Option.None
            }
        /// Creates a Fs with default values
        let fs () : TypesRepository =
            TypesRepository.Fs {
                Uuid = Option.None
                Type = "fs"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Gcs with default values
        let gcs () : TypesRepository =
            TypesRepository.Gcs {
                Uuid = Option.None
                Type = "gcs"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a S3 with default values
        let s3 () : TypesRepository =
            TypesRepository.S3 {
                Uuid = Option.None
                Type = "s3"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Source with default values
        let source () : TypesRepository =
            TypesRepository.Source {
                Uuid = Option.None
                Type = "source"
                Settings = Unchecked.defaultof<_>
            }
        /// Creates a Url with default values
        let url () : TypesRepository =
            TypesRepository.Url {
                Uuid = Option.None
                Type = "url"
                Settings = Unchecked.defaultof<_>
            }

